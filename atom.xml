<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason Jin</title>
  
  <subtitle>迎着光 风再大 又何妨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jinzhengxu.github.io/"/>
  <updated>2020-05-17T02:51:35.540Z</updated>
  <id>http://jinzhengxu.github.io/</id>
  
  <author>
    <name>Jinzhengxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>R.I.P. for John Horton Conway</title>
    <link href="http://jinzhengxu.github.io/2020/05/15/r-i-p-for-john-horton-conway/"/>
    <id>http://jinzhengxu.github.io/2020/05/15/r-i-p-for-john-horton-conway/</id>
    <published>2020-05-15T14:36:13.000Z</published>
    <updated>2020-05-17T02:51:35.540Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="元胞自动机" scheme="http://jinzhengxu.github.io/tags/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Poj 1659 Frogs’ Neighborhood Havel–Hakimi算法</title>
    <link href="http://jinzhengxu.github.io/2019/11/12/poj-1659-frogs-neighborhood-havel-hakimi-suan-fa/"/>
    <id>http://jinzhengxu.github.io/2019/11/12/poj-1659-frogs-neighborhood-havel-hakimi-suan-fa/</id>
    <published>2019-11-12T01:10:32.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Poj-1659-Frogs’-Neighborhood"><a href="#Poj-1659-Frogs’-Neighborhood" class="headerlink" title="Poj 1659 Frogs’ Neighborhood"></a>Poj 1659 Frogs’ Neighborhood</h2><p><a href="http://poj.org/problem?id=1659" target="_blank" rel="noopener">题目地址</a></p><p>如果提前了解到Havel–Hakimi算法，这道题就十分简单了。</p><p>HH算法是用来解决简单可图化问题，即给定一个有限多的非负整数序列，是否存在一个简单图使得其度序列恰好为该序列。</p><p>下面给出一个不可简单图化例子：</p><pre><code>    原始序列：3 5 4 2 5 2==&gt; 排序后得：5 5 4 3 2 2==&gt; 第一递归：0 4 3 2 1 1==&gt; 第一排序：4 3 2 1 1 0==&gt; 第二递归：0 2 1 0 0 0==&gt; 第二排序：2 1 0 0 0 0==&gt; 第三递归：0 0 -1 0 0 0</code></pre><p>下面给出一个可以简单图化的例子：</p><pre><code>    原始序列：3 5 3 5 3 5==&gt; 排序后得：5 5 5 3 3 3==&gt; 第一递归：0 4 4 2 2 2==&gt; 第一排序：4 4 2 2 2 0==&gt; 第二递归：0 3 1 1 1 0==&gt; 第二排序：3 1 1 1 0 0==&gt; 第三递归：0 0 0 0 0 0</code></pre><p>AC代码：</p><table><thead><tr><th>Memory</th><th>Time</th></tr></thead><tbody><tr><td>216k</td><td>0MS</td></tr></tbody></table><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">struct</span> Lake<span class="token punctuation">{</span>  <span class="token keyword">int</span> index<span class="token punctuation">;</span>  <span class="token keyword">int</span> Frognum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>bool <span class="token function">acompare</span><span class="token punctuation">(</span>Lake lhs<span class="token punctuation">,</span> Lake rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>Frognum <span class="token operator">></span> rhs<span class="token punctuation">.</span>Frognum<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Lake lake<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> Lakenum<span class="token punctuation">;</span>    <span class="token keyword">int</span> answer<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>Lakenum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Lakenum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      cin<span class="token operator">>></span>lake<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Frognum<span class="token punctuation">;</span>      lake<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token operator">=</span>i<span class="token punctuation">;</span>      ##cout<span class="token operator">&lt;&lt;</span>lake<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>lake<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Frognum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Lakenum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">sort</span><span class="token punctuation">(</span>lake<span class="token punctuation">,</span>lake<span class="token operator">+</span>Lakenum<span class="token punctuation">,</span>acompare<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> index<span class="token operator">=</span>lake<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Frognum<span class="token punctuation">;</span>      ##<span class="token keyword">int</span> jumpout<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      ##<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>Lakenum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span>lake<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Frognum<span class="token punctuation">;</span>      ##cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      lake<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Frognum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>index<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        answer<span class="token punctuation">[</span>lake<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>lake<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        answer<span class="token punctuation">[</span>lake<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>lake<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        lake<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Frognum<span class="token operator">-</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> JOJO<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Lakenum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>lake<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Frognum<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"NO"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>          JOJO<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>JOJO<span class="token punctuation">)</span><span class="token punctuation">{</span>      cout<span class="token operator">&lt;&lt;</span><span class="token string">"YES"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Lakenum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>Lakenum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>answer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>      cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Poj-1659-Frogs’-Neighborhood&quot;&gt;&lt;a href=&quot;#Poj-1659-Frogs’-Neighborhood&quot; class=&quot;headerlink&quot; title=&quot;Poj 1659 Frogs’ Neighborhood&quot;&gt;&lt;/a&gt;Po
      
    
    </summary>
    
      <category term="程序设计" scheme="http://jinzhengxu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Havel–Hakimi算法" scheme="http://jinzhengxu.github.io/tags/Havel%E2%80%93Hakimi%E7%AE%97%E6%B3%95/"/>
    
      <category term="Poj" scheme="http://jinzhengxu.github.io/tags/Poj/"/>
    
      <category term="图论" scheme="http://jinzhengxu.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>2019MLA</title>
    <link href="http://jinzhengxu.github.io/2019/11/02/2019mla/"/>
    <id>http://jinzhengxu.github.io/2019/11/02/2019mla/</id>
    <published>2019-11-02T00:25:18.000Z</published>
    <updated>2020-04-24T16:00:54.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Developing-Advanced-Telechnology-for-Better-Access-of-Information"><a href="#Developing-Advanced-Telechnology-for-Better-Access-of-Information" class="headerlink" title="Developing Advanced Telechnology for Better Access of Information"></a>Developing Advanced Telechnology for Better Access of Information</h2><ul><li>Serach System</li></ul><p>QDC：</p><pre><code>QueryDocumentClick</code></pre><p>Postation Bias: User prefer top diucuments</p><ul><li>Recommanded System</li></ul><p>用户可以和系统交互</p><hr><h2 id="图像的非监督增强匹配"><a href="#图像的非监督增强匹配" class="headerlink" title="图像的非监督增强匹配"></a>图像的非监督增强匹配</h2><ul><li>小样本学习</li></ul><p>困难：Data Capture，需求就是降低数据标注量，如果使用Few—shot Learning， 只使用几张样本就可以完成学习。 即Semi—Supervised Learing，将标注传播。 对数据进行增广，将突袭那个旋转旋转等，这样损失函数会有两个，分别来自原图想和增广图像。</p><p>，使用计算机图新洒狗血生成呢个的图片进行学习最后应用到实际生活中，和传统做法不一样的地方，在中呢格式数据上做分布时，泛数对齐（SCV Best mention）。</p><p>Mult—Instance Learning</p><p>Mult—Label Learing： Car——Street——Bulding 之间有联系，根据这个分类</p><p>Co—Traning： 根据内容做分类器，在根据link做一个分类器，当没有标签的数据经过有网络时，先过分类器，如果获得一个表较好的标注，那就认为其有标注。</p><ul><li>图像的非监督增强匹配</li></ul><p>字体的结构很相似，比如学习字的边旁笔画，借鉴DTW 动态时间扭曲，使用DPW 动态位置扭曲，两个模块位置和相似性的互相迭代。还可以将相似性度量用在其他字体的识别上, TOP1可以达到80%-90%，Top5 可以达到 98%-99%</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Developing-Advanced-Telechnology-for-Better-Access-of-Information&quot;&gt;&lt;a href=&quot;#Developing-Advanced-Telechnology-for-Better-Access-of-I
      
    
    </summary>
    
      <category term="机器学习" scheme="http://jinzhengxu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MLA" scheme="http://jinzhengxu.github.io/tags/MLA/"/>
    
  </entry>
  
  <entry>
    <title>telegram实现定时QQ发信——再也不用每天宿舍签到啦！</title>
    <link href="http://jinzhengxu.github.io/2019/10/26/telegram-shi-xian-ding-shi-qq-fa-xin-zai-ye-bu-yong-mei-tian-su-she-qian-dao-la/"/>
    <id>http://jinzhengxu.github.io/2019/10/26/telegram-shi-xian-ding-shi-qq-fa-xin-zai-ye-bu-yong-mei-tian-su-she-qian-dao-la/</id>
    <published>2019-10-26T11:31:11.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>作为一个马上要去美帝的留学党，突然强行被指派成了舍长？王德发，舍长也就算了，还要每天10:30在QQ群发布查寝情况？看着一个个没事就出去开房的舍友，emmmmmm，我就这个表情</p><p><img src="https://s2.ax1x.com/2019/10/26/KDZfOI.jpg" alt="KDZfOI.jpg"></p><p>不如就写个bot来替我每天发“人齐了”签到吧(๑•̀ㅂ•́)و✧。</p><h2 id="你需要有"><a href="#你需要有" class="headerlink" title="你需要有"></a>你需要有</h2><hr><ul><li>海外VPS一台(Debian 9)</li><li>telegram帐号</li><li>一个额外的QQ帐号</li><li>Windows 用户需要 SSH 客户端</li></ul><p>VPS的选择和配置可以参考我的这篇 <a href="http://jinzhnegxu.online/2019/03/14/Ubuntu18.04下通过Vultr服务搭建vps科学上网/" target="_blank" rel="noopener">Ubuntu18.04下通过Vultr服务搭建vps科学上网</a> ，VPS功能多多还能拿来科学上网建议小伙伴们搞一个。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><hr><p><img src="https://s2.ax1x.com/2019/10/26/KDJkgP.png" alt="KDJkgP.png"></p><h2 id="telegram配置bot"><a href="#telegram配置bot" class="headerlink" title="telegram配置bot"></a>telegram配置bot</h2><p>首先在telegram中搜索BotFather，找到以后向<a href="https://t.me/BotFather" target="_blank" rel="noopener">@BotFather</a>发送<code>/newbot</code>创建一个新的机器人。然后指定这个 Bot 的名称与用户名（用户名必须以 bot 结尾）。创建成功后BotFather会向你提供一个密钥token，这个密钥是bot 的唯一ID，注意不要泄漏。</p><p><img src="https://s2.ax1x.com/2019/10/26/KDa4nx.png" alt="KDa4nx.png"></p><p>接下来对 Bot 进行进一步的配置：允许 Bot 读取非指令信息、允许将 Bot 添加进群组、以及提供指令列表。</p><p>发送 /setprivacy 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Disable”.<br>发送 /setjoingroups 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Enable”.<br>发送 /setcommands 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后发送如下内容：</p><pre><code>link - 将会话绑定到 Telegram 群组chat - 生成会话头recog - 回复语音消息以进行识别extra - 获取更多功能</code></pre><p>然后找到机器人<a href="https://t.me/get_id_bot" target="_blank" rel="noopener">@get_id_bot</a>发送<code>/start</code>，获得自己帐号的chat_id</p><h2 id="VPS安装docker"><a href="#VPS安装docker" class="headerlink" title="VPS安装docker"></a>VPS安装docker</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> remove docker docker-engine docker.io containerd runc$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> \    apt-transport-https \    ca-certificates \    curl \    gnupg2 \    software-properties-common$ curl -fsSL https://download.docker.com/linux/debian/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key add -$ <span class="token function">sudo</span> apt-key fingerprint 0EBFCD88pub   4096R/0EBFCD88 2017-02-22      Key fingerprint <span class="token operator">=</span> 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid                  Docker Release <span class="token punctuation">(</span>CE deb<span class="token punctuation">)</span> <span class="token operator">&lt;</span>docker@docker.com<span class="token operator">></span>sub   4096R/F273FCD8 2017-02-22</code></pre><h3 id="安装新版本"><a href="#安装新版本" class="headerlink" title="安装新版本"></a>安装新版本</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce docker-ce-cli containerd.io</code></pre><p>选择一个版本：</p><pre class=" language-bash"><code class="language-bash">$ apt-cache madison docker-ce  docker-ce <span class="token operator">|</span> 5:18.09.1~3-0~debian-stretch <span class="token operator">|</span> https://download.docker.com/linux/debian stretch/stable amd64 Packages  docker-ce <span class="token operator">|</span> 5:18.09.0~3-0~debian-stretch <span class="token operator">|</span> https://download.docker.com/linux/debian stretch/stable amd64 Packages  docker-ce <span class="token operator">|</span> 18.06.1~ce~3-0~debian        <span class="token operator">|</span> https://download.docker.com/linux/debian stretch/stable amd64 Packages  docker-ce <span class="token operator">|</span> 18.06.0~ce~3-0~debian        <span class="token operator">|</span> https://download.docker.com/linux/debian stretch/stable amd64 Packages  <span class="token punctuation">..</span>.</code></pre><p>假如我选择的是<code>5:18.09.1~3-0~debian-stretch</code>那下面的VERSION_STRING就是<code>5:18.09.1~3-0~debian-stretch</code>：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce<span class="token operator">=</span><span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">></span> docker-ce-cli<span class="token operator">=</span><span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">></span> containerd.io</code></pre><p>检查是否安装成功：</p><pre><code>$ sudo docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly....</code></pre><h2 id="VPS部署EFB，CoolQ和telegram-cli"><a href="#VPS部署EFB，CoolQ和telegram-cli" class="headerlink" title="VPS部署EFB，CoolQ和telegram-cli"></a>VPS部署EFB，CoolQ和telegram-cli</h2><h3 id="安装EFBZ主端-CoolQ从端"><a href="#安装EFBZ主端-CoolQ从端" class="headerlink" title="安装EFBZ主端,CoolQ从端"></a>安装EFBZ主端,CoolQ从端</h3><p>ssh登录vps后安装相关依赖：</p><pre class=" language-bash"><code class="language-bash">$ apt <span class="token function">install</span> python3 python3-pip python3-pil python3-setuptools python3-numpy python3-yaml python3-requests ffmpeg libmagic-dev libwebp-dev vim -y</code></pre><p>安装EFB：</p><pre class=" language-bash"><code class="language-bash">$ pip3 <span class="token function">install</span> ehforwarderbot efb-telegram-master efb-qq-slave</code></pre><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><h4 id="创建-EFB-配置文件"><a href="#创建-EFB-配置文件" class="headerlink" title="创建 EFB 配置文件"></a>创建 EFB 配置文件</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p ~/.ehforwarderbot/profiles/qq/$ vim ~/.ehforwarderbot/profiles/qq/config.yaml</code></pre><p>输入以下内容:</p><pre><code>master_channel: blueset.telegramslave_channels:- milkice.qq</code></pre><h4 id="创建ETM-配置文件"><a href="#创建ETM-配置文件" class="headerlink" title="创建ETM 配置文件"></a>创建ETM 配置文件</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p ~/.ehforwarderbot/profiles/qq/blueset.telegram$ vim ~/.ehforwarderbot/profiles/qq/blueset.telegram/config.yaml</code></pre><p>输入以下内容:</p><pre><code>token: &quot;值为你在 @BotFather 处获得的 bot token&quot;admins:- 值为你在 @get_id_bot 处获得的 chat id</code></pre><h4 id="创建-EQS-配置文件"><a href="#创建-EQS-配置文件" class="headerlink" title="创建 EQS 配置文件"></a>创建 EQS 配置文件</h4><p>CoolQ：</p><pre class=" language-bash"><code class="language-bash">$ docker pull richardchien/cqhttp:latest$ <span class="token function">mkdir</span> coolq$ docker run -ti --rm --name cqhttp-test --net<span class="token operator">=</span><span class="token string">"host"</span> \     -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>/coolq:/home/user/coolq     `<span class="token comment" spellcheck="true"># mount coolq folder` \</span>     -p 9000:9000                         `<span class="token comment" spellcheck="true"># 网页noVNC端口` \</span>     -p 5700:5700                         `<span class="token comment" spellcheck="true"># 酷Q对外提供的API接口的端口` \</span>     -e VNC_PASSWD<span class="token operator">=</span>MAX8char               `<span class="token comment" spellcheck="true"># 请修改 VNC 密码！！！！` \</span>     -e COOLQ_PORT<span class="token operator">=</span>5700                   `<span class="token comment" spellcheck="true"># 酷Q对外提供的API接口的端口` \</span>     -e COOLQ_ACCOUNT<span class="token operator">=</span>123456              `<span class="token comment" spellcheck="true"># 在此输入要登录的QQ号，虽然可选但是建议填入` \</span>     -e CQHTTP_POST_URL<span class="token operator">=</span>http://127.0.0.1:8000   `<span class="token comment" spellcheck="true"># efb-qq-slave监听的端口/地址 用于接受传入的消息` \</span>     -e CQHTTP_SERVE_DATA_FILES<span class="token operator">=</span>yes       `<span class="token comment" spellcheck="true"># 允许以HTTP方式访问酷Q数据文件` \</span>     -e CQHTTP_ACCESS_TOKEN<span class="token operator">=</span>ac0f790e1fb74ebcaf45da77a6f9de47  `<span class="token comment" spellcheck="true"># Access Token` \</span>     -e CQHTTP_POST_MESSAGE_FORMAT<span class="token operator">=</span>array  `<span class="token comment" spellcheck="true"># 回传消息时使用数组（必选）` \</span>     richardchien/cqhttp:latest</code></pre><p>将 docker run 命令中的参数根据注释改为相应数值</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p ~/.ehforwarderbot/profiles/qq/milkice.qq$ vim ~/.ehforwarderbot/profiles/qq/milkice.qq/config.yaml</code></pre><p>输入以下内容:</p><pre><code>Client: CoolQ # 指定要使用的 QQ 客户端（此处为CoolQ）CoolQ:type: HTTP # 指定 efb-qq-slave 与 酷Q 通信的方式 现阶段仅支持HTTPaccess_token: ac0f790e1fb74ebcaf45da77a6f9de47api_root: http://127.0.0.1:5700/ # 酷Q API接口地址/端口host: 127.0.0.1 # efb-qq-slave 所监听的地址用于接收消息port: 8000 # 同上is_pro: true # 若为酷Q Pro则为true，反之为falseair_option: # 包含于 air_option 的配置选项仅当 is_pro 为 false 时才有效upload_to_smms: true # 将来自 EFB主端(通常是Telegram) 的图片上传到 sm.ms 服务器并以链接的形式发送到 QQ 端</code></pre><h2 id="启动EFB"><a href="#启动EFB" class="headerlink" title="启动EFB"></a>启动EFB</h2><p>在浏览器内访问 http://&lt;vps的ip&gt;:9000</p><p>请在noVNC终端中输入上述配置选项中的 VNC 密码登录，并使用QQ账户和密码在酷Q中登录QQ账号</p><pre class=" language-bash"><code class="language-bash">$ ehforwarderbot --profile qq</code></pre><h2 id="将QQ群链接telegram-group"><a href="#将QQ群链接telegram-group" class="headerlink" title="将QQ群链接telegram_group"></a>将QQ群链接telegram_group</h2><p>搜寻到刚刚创建的bot，发送<code>/start</code>开始服务。</p><p>创建一个新的telegram群组，将bot邀请到群组中，然后私聊bot发送<code>/link</code>，bot会返回一个列表，在其中选择你想要链接的群组。链接成功后，只要在当前telegram群组中发信就会自动被转发到链接的QQ群中。</p><p>邀请机器人<a href="https://t.me/getidsbot" target="_blank" rel="noopener">@getidsbot</a>进群，并记录群组的chat_id。</p><h2 id="VPS上使用crontab和telegram-cli定时发送"><a href="#VPS上使用crontab和telegram-cli定时发送" class="headerlink" title="VPS上使用crontab和telegram-cli定时发送"></a>VPS上使用crontab和telegram-cli定时发送</h2><h3 id="安装telegram-cli"><a href="#安装telegram-cli" class="headerlink" title="安装telegram-cli"></a>安装telegram-cli</h3><p>telegram-cli是一个非官方telegram版本，可以使用命令行操作。</p><p>安装依赖：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y <span class="token function">git</span> libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev <span class="token function">make</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libssl1.0-dev$ <span class="token function">git</span> clone --recursive https://github.com/vysheng/tg.git <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> tg$ ./configure$ <span class="token function">make</span></code></pre><h3 id="激活-API"><a href="#激活-API" class="headerlink" title="激活 API"></a>激活 API</h3><p>安装好后，我们需要去拿到 telegram 的密钥。访问 telegram 的网站<a href="https://my.telegram.org/apps" target="_blank" rel="noopener">https://my.telegram.org/apps</a>.在官网中新建一个app，得到public key。</p><p>新建一个文件，然后把 public key 的内容复制进去并保存</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">vi</span> /root/tg-server.pub</code></pre><h3 id="登录telegram-cli"><a href="#登录telegram-cli" class="headerlink" title="登录telegram-cli"></a>登录telegram-cli</h3><pre class=" language-bash"><code class="language-bash">$ /root/tg/bin/telegram-cli -k /root/tg-server.pub</code></pre><p>第一次登录需要从telegram上接受验证码，之后就ky自动登录了</p><h3 id="crontab实现定时发送"><a href="#crontab实现定时发送" class="headerlink" title="crontab实现定时发送"></a>crontab实现定时发送</h3><p>修改默认编辑器：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">export</span> VISUAL<span class="token operator">=</span>vim</code></pre><p>新建crontab任务：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">crontab</span> -e</code></pre><p>输入任务：</p><pre><code>* 10 * * * /root/tg/bin/telegram-cli -k /root/tg-server.pub -WR -e &quot;msg 群组chat_id 信息内容&quot;</code></pre><p>其中第五个星号分别是分钟，小时，日，月，星期，这个指令的意思是每天10:00执行命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;作为一个马上要去美帝的留学党，突然强行被指派成了舍长？王德发，舍长也就算了，还要每天10:30在QQ群发布查寝情况？看着一个
      
    
    </summary>
    
    
      <category term="telegram" scheme="http://jinzhengxu.github.io/tags/telegram/"/>
    
      <category term="ehforwarderbot" scheme="http://jinzhengxu.github.io/tags/ehforwarderbot/"/>
    
      <category term="corntab" scheme="http://jinzhengxu.github.io/tags/corntab/"/>
    
      <category term="telegram-cli" scheme="http://jinzhengxu.github.io/tags/telegram-cli/"/>
    
      <category term="docker" scheme="http://jinzhengxu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu下使用masm进行汇编实验</title>
    <link href="http://jinzhengxu.github.io/2019/10/10/zai-ubuntu-xia-shi-yong-masm-jin-xing-hui-bian-shi-yan/"/>
    <id>http://jinzhengxu.github.io/2019/10/10/zai-ubuntu-xia-shi-yong-masm-jin-xing-hui-bian-shi-yan/</id>
    <published>2019-10-10T10:51:50.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<p>windows下我们常常使用masm作为学习汇编语言的环境，Linux虽然有nasm等强大的开源软件，但是nasm的debug，编译等都与lab中使用masm的方式不同，但是masm对于linux的适配并不是非常完美。很多人选择重新开一个windows xp虚拟机来进行masm的安装，根据<code>禁止套娃</code>的原则，这里介绍集中可以在ubuntu下使用masm的方法。</p><h3 id="安装dosbox"><a href="#安装dosbox" class="headerlink" title="安装dosbox"></a>安装dosbox</h3><p>ubuntu在软件商店中提供了dosbox，之间安装即可。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> apt <span class="token function">install</span> dosbox</code></pre><h3 id="下载masm文件夹"><a href="#下载masm文件夹" class="headerlink" title="下载masm文件夹"></a>下载masm文件夹</h3><p>从<a href="https://drive.google.com/folderview?id=0B1DiPkxLHBZHTWVQVVNlYVptU3M&usp=sharing" target="_blank" rel="noopener">这里</a>下载文件并加压</p><h3 id="masm使用"><a href="#masm使用" class="headerlink" title="masm使用"></a>masm使用</h3><p>首先在masm文件夹下新建一个你的<code>.asm</code>文件，或者你也可以直接号使用masm文件夹下自带的<code>count99.asm</code>文件。</p><p>然后新建一个终端，输入：</p><pre class=" language-bash"><code class="language-bash">$ dosbox</code></pre><p>打开dosbox，将masm文件夹挂载：</p><pre class=" language-bash"><code class="language-bash">Z:\SET BLASTER+A220 I7 D1 H5 T6Z:\<span class="token operator">></span> <span class="token function">mount</span> c: ~/Downloads/masmDrive C is mounted as local directory /home/jason/Downloads/masm</code></pre><p>输入命令<code>mount c: ~/Downloads/masm</code>，注意这里的文件地址是你的电脑当前用户主目录下的地址。</p><p>进入挂载后的Drive C并查看文件：</p><pre class=" language-bash"><code class="language-bash">Z:\<span class="token operator">></span>c:C:\<span class="token operator">></span>dir</code></pre><p>编译并连接<code>.asm</code>文件：</p><pre class=" language-bash"><code class="language-bash">C:\<span class="token operator">></span>masm count99<span class="token punctuation">;</span>C:\<span class="token operator">></span>link count99<span class="token punctuation">;</span></code></pre><p>进入debug：</p><pre class=" language-bash"><code class="language-bash">C:\<span class="token operator">></span>debug count99.exe</code></pre><p>然后我们就进入了debug环境，接下来就可以进行实验了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;windows下我们常常使用masm作为学习汇编语言的环境，Linux虽然有nasm等强大的开源软件，但是nasm的debug，编译等都与lab中使用masm的方式不同，但是masm对于linux的适配并不是非常完美。很多人选择重新开一个windows xp虚拟机来进行ma
      
    
    </summary>
    
      <category term="底层" scheme="http://jinzhengxu.github.io/categories/%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="masm" scheme="http://jinzhengxu.github.io/tags/masm/"/>
    
      <category term="ubuntu" scheme="http://jinzhengxu.github.io/tags/ubuntu/"/>
    
      <category term="汇编语言" scheme="http://jinzhengxu.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>The 5*5 plan for my summer training</title>
    <link href="http://jinzhengxu.github.io/2019/07/21/the-5-5-plan-for-my-summer-training/"/>
    <id>http://jinzhengxu.github.io/2019/07/21/the-5-5-plan-for-my-summer-training/</id>
    <published>2019-07-21T02:38:17.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5×5计划"><a href="#5×5计划" class="headerlink" title="5×5计划"></a>5×5计划</h4><h5 id="The-basic-content"><a href="#The-basic-content" class="headerlink" title="The basic content"></a>The basic content</h5><table><thead><tr><th>Workout A</th><th>Workout B</th></tr></thead><tbody><tr><td>深蹲 5x5</td><td>深蹲 5x5</td></tr><tr><td>卧推 5x5</td><td>推举 5x5</td></tr><tr><td>臂屈伸 5x5</td><td>硬拉 1x5</td></tr><tr><td>引体向上 5x5</td><td>山羊挺身 5x5</td></tr></tbody></table><h5 id="A-plan"><a href="#A-plan" class="headerlink" title="A plan"></a>A plan</h5><table><thead><tr><th>日期</th><th>训练内容</th></tr></thead><tbody><tr><td>Day1</td><td>Workout A</td></tr><tr><td>Day2</td><td></td></tr><tr><td>Day3</td><td>Workout B</td></tr><tr><td>Day4</td><td>人体旗帜</td></tr><tr><td>Day5</td><td>Workout A</td></tr><tr><td>Day6</td><td></td></tr><tr><td>Day7</td><td>引体向上</td></tr></tbody></table><h5 id="B-plan"><a href="#B-plan" class="headerlink" title="B plan"></a>B plan</h5><table><thead><tr><th>日期</th><th>训练内容</th></tr></thead><tbody><tr><td>Day1</td><td>Workout B</td></tr><tr><td>Day2</td><td></td></tr><tr><td>Day3</td><td>Workout A</td></tr><tr><td>Day4</td><td>人体旗帜</td></tr><tr><td>Day5</td><td>Workout B</td></tr><tr><td>Day6</td><td></td></tr><tr><td>Day7</td><td>引体向上</td></tr></tbody></table><h4 id="热身组设置"><a href="#热身组设置" class="headerlink" title="热身组设置"></a>热身组设置</h4><table><thead><tr><th>深蹲</th><th>重量</th><th>次数</th><th>组数</th></tr></thead><tbody><tr><td>空杆</td><td>20.41kg</td><td>5</td><td>2</td></tr><tr><td></td><td>40kg</td><td>5</td><td>1</td></tr><tr><td></td><td>60kg</td><td>3</td><td>1</td></tr><tr><td></td><td>80kg</td><td>2</td><td>1</td></tr><tr><td>正式组</td><td>100kg</td><td>5</td><td>3</td></tr></tbody></table><table><thead><tr><th>卧推</th><th>重量</th><th>次数</th><th>组数</th></tr></thead><tbody><tr><td>空杆</td><td>20.41kg</td><td>5</td><td>2</td></tr><tr><td></td><td>35kg</td><td>5</td><td>1</td></tr><tr><td></td><td>55kg</td><td>3</td><td>1</td></tr><tr><td></td><td>70kg</td><td>2</td><td>1</td></tr><tr><td>正式组</td><td>80kg</td><td>5</td><td>3</td></tr></tbody></table><table><thead><tr><th>硬拉</th><th>重量</th><th>次数</th><th>组数</th></tr></thead><tbody><tr><td></td><td>60kg</td><td>5</td><td>2</td></tr><tr><td></td><td>80kg</td><td>5</td><td>1</td></tr><tr><td></td><td>100kg</td><td>5</td><td>1</td></tr><tr><td></td><td>125kg</td><td>5</td><td>1</td></tr><tr><td>正式组</td><td>140kg</td><td>5</td><td>1</td></tr></tbody></table><table><thead><tr><th>推举</th><th>重量</th><th>次数</th><th>组数</th></tr></thead><tbody><tr><td>空杆</td><td>20.41kg</td><td>5</td><td>2</td></tr><tr><td></td><td>35kg</td><td>5</td><td>1</td></tr><tr><td></td><td>45kg</td><td>3</td><td>1</td></tr><tr><td></td><td>50kg</td><td>2</td><td>1</td></tr><tr><td>正式组</td><td>60kg</td><td>5</td><td>3</td></tr></tbody></table><table><thead><tr><th>力量翻</th><th>重量</th><th>次数</th><th>组数</th></tr></thead><tbody><tr><td>空杆</td><td>20.41kg</td><td>5</td><td>2</td></tr><tr><td></td><td>35kg</td><td>5</td><td>1</td></tr><tr><td></td><td>45kg</td><td>3</td><td>1</td></tr><tr><td></td><td>50kg</td><td>2</td><td>1</td></tr><tr><td>正式组</td><td>60kg</td><td>3</td><td>5</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5×5计划&quot;&gt;&lt;a href=&quot;#5×5计划&quot; class=&quot;headerlink&quot; title=&quot;5×5计划&quot;&gt;&lt;/a&gt;5×5计划&lt;/h4&gt;&lt;h5 id=&quot;The-basic-content&quot;&gt;&lt;a href=&quot;#The-basic-content&quot; class
      
    
    </summary>
    
      <category term="Workout" scheme="http://jinzhengxu.github.io/categories/Workout/"/>
    
    
      <category term="5*5" scheme="http://jinzhengxu.github.io/tags/5-5/"/>
    
  </entry>
  
  <entry>
    <title>Google Open Day，2019</title>
    <link href="http://jinzhengxu.github.io/2019/06/13/google-open-day-2019/"/>
    <id>http://jinzhengxu.github.io/2019/06/13/google-open-day-2019/</id>
    <published>2019-06-13T05:42:37.000Z</published>
    <updated>2020-04-24T16:00:54.080Z</updated>
    
    <content type="html"><![CDATA[<p>今天来到了融科中心4-7f的Google北京，非常高兴今天认识了许多优秀的同学，也感谢主办方Google北京、Linedin、团中央完美的活动安排，特别是午餐真的招待的非常不错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来到了融科中心4-7f的Google北京，非常高兴今天认识了许多优秀的同学，也感谢主办方Google北京、Linedin、团中央完美的活动安排，特别是午餐真的招待的非常不错。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>鸟哥的Linux私房菜-9-Shell Scripts</title>
    <link href="http://jinzhengxu.github.io/2019/05/22/niao-ge-de-linux-si-fang-cai-9-shell-scripts/"/>
    <id>http://jinzhengxu.github.io/2019/05/22/niao-ge-de-linux-si-fang-cai-9-shell-scripts/</id>
    <published>2019-05-22T03:20:53.000Z</published>
    <updated>2020-04-24T16:00:54.100Z</updated>
    
    <content type="html"><![CDATA[<p>shell脚本就是将一些命令集合起来一起执行，类似于程序的编写，但是不需要compile</p><h4 id="What-is-Shell-Scripts"><a href="#What-is-Shell-Scripts" class="headerlink" title="What is Shell Scripts"></a>What is Shell Scripts</h4><p>Shell脚本是利用shell功能所写的一个 <strong><em>程序Program</em></strong> 。这个程序是使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式、管道命令与数据流重定向结合在一起，以达到我们想要的功能。</p><h5 id="为何要学习Shell-Scripts"><a href="#为何要学习Shell-Scripts" class="headerlink" title="为何要学习Shell Scripts"></a>为何要学习Shell Scripts</h5><h6 id="自动化管理的重要根据"><a href="#自动化管理的重要根据" class="headerlink" title="自动化管理的重要根据"></a>自动化管理的重要根据</h6><h6 id="跟踪与管理系统-的重要工作"><a href="#跟踪与管理系统-的重要工作" class="headerlink" title="跟踪与管理系统 的重要工作"></a>跟踪与管理系统 的重要工作</h6><h6 id="简单入侵检测功能"><a href="#简单入侵检测功能" class="headerlink" title="简单入侵检测功能"></a>简单入侵检测功能</h6><h6 id="连续命令单一化"><a href="#连续命令单一化" class="headerlink" title="连续命令单一化"></a>连续命令单一化</h6><p><strong><em>汇整一些在 command line 下达的连续指令,将他写入 scripts 当中,而由直接执行 scripts 来启动一连串的 command line 指令输入!</em></strong></p><h6 id="简易的数据处理"><a href="#简易的数据处理" class="headerlink" title="简易的数据处理"></a>简易的数据处理</h6><p><strong><em>shell script 用在系统管理上面是很好的一项工具,但是用在处理大量数值运算上, 就不够好了,因为 Shell scripts 的速度较慢,且使用的 CPU 资源较多,造成主机资源的分配不良。</em></strong></p><h6 id="跨平台支持与学习历程较短"><a href="#跨平台支持与学习历程较短" class="headerlink" title="跨平台支持与学习历程较短"></a>跨平台支持与学习历程较短</h6><h5 id="第一个Shell-Scripts程序"><a href="#第一个Shell-Scripts程序" class="headerlink" title="第一个Shell Scripts程序"></a>第一个Shell Scripts程序</h5><ol><li>指令的执行是从上而下、从左而右的分析与执行;</li><li>指令的下达就如同第四章内提到的: 指令、选项与参数间的多个空白都会被忽略掉;</li><li>空白行也将被忽略掉,并且 [tab] 按键所推开的空白同样视为空格键;</li><li>如果读取到一个 Enter 符号 (CR) ,就尝试开始执行该行 (或该串) 命令;</li><li>至于如果一行的内容太多,则可以使用『 [Enter] 』来延伸至下一行;</li><li>『 # 』可做为批注!任何加在 # 后面的资料将全部被视为批注文字而被忽略!</li><li>如何执行命令<code>bash shell</code>,<code>sh shell.sh</code>,<code>/root/home/user/shell.sh</code>,<code>./shell.sh</code></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#Program:</span><span class="token comment" spellcheck="true">#       This program shows "Hello WOrld" in screen</span>PATH<span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<span class="token function">export</span> PATH<span class="token keyword">echo</span> -e <span class="token string">"Hello World \a \n"</span><span class="token keyword">exit</span> 0</code></pre><ol><li>第一行不同于其他注释 <code>#!/bin/bash</code>在声明这个脚本使用的bash名称，第一行也称为shebang行</li><li>环境变量 的设置可以免去脚本中复杂的引用<h5 id="写Shell-Scripts的良好习惯"><a href="#写Shell-Scripts的良好习惯" class="headerlink" title="写Shell Scripts的良好习惯"></a>写Shell Scripts的良好习惯</h5>在脚本的文件开头处写好注释，包括但不限于：</li></ol><ul><li><p>脚本的功能</p></li><li><p>脚本的版本信息</p></li><li><p>脚本的作者于联络方式</p></li><li><p>脚本的版权声明方式</p></li><li><p>脚本的History</p></li><li><p>脚本内较特殊的命令</p></li><li><p>脚本运行时需要的环境变量</p><h4 id="简单的Shell-Scripts练习"><a href="#简单的Shell-Scripts练习" class="headerlink" title="简单的Shell Scripts练习"></a>简单的Shell Scripts练习</h4><h5 id="简单范例"><a href="#简单范例" class="headerlink" title="简单范例"></a>简单范例</h5></li><li><p>交互式脚本：变量内容有用户决定</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#Program:</span><span class="token comment" spellcheck="true">#       User input his first name and last name, the prog output his full name</span>PATH<span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<span class="token function">export</span> PATH<span class="token function">read</span> -p <span class="token string">"Please input your first name: "</span> firstname<span class="token function">read</span> -p <span class="token string">"Please input your last name: "</span> lastname<span class="token keyword">echo</span> -e <span class="token string">" \n Your full name is: <span class="token variable">${firstname}</span> <span class="token variable">${lastname}</span>"</span></code></pre></li><li><p>随日期变化</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#Program:</span><span class="token comment" spellcheck="true">#       Insert date into filename</span>PATH<span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<span class="token function">export</span> PATH<span class="token keyword">echo</span> -e <span class="token string">"I will use 'touch' command to create 3 file."</span><span class="token function">read</span> -p <span class="token string">"Please input your filename:"</span> fileuserfilename<span class="token operator">=</span>$<span class="token punctuation">{</span>fileuser:-<span class="token string">"filename"</span><span class="token punctuation">}</span>date1<span class="token operator">=</span><span class="token punctuation">$(</span>date --date<span class="token operator">=</span><span class="token string">'2 days ago'</span> +%Y%m%d<span class="token punctuation">)</span>date2<span class="token operator">=</span><span class="token punctuation">$(</span>date --date<span class="token operator">=</span><span class="token string">'1 days ago'</span> +%Y%m%d<span class="token punctuation">)</span>date3<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%Y%m%d<span class="token variable">)</span></span>file1<span class="token operator">=</span><span class="token variable">${filename}</span><span class="token variable">${date1}</span>file2<span class="token operator">=</span><span class="token variable">${filename}</span><span class="token variable">${date2}</span>file3<span class="token operator">=</span><span class="token variable">${filename}</span><span class="token variable">${date3}</span><span class="token function">touch</span> <span class="token string">"<span class="token variable">${file1}</span>"</span><span class="token function">touch</span> <span class="token string">"<span class="token variable">${file3}</span>"</span><span class="token function">touch</span> <span class="token string">"<span class="token variable">${file2}</span>"</span></code></pre></li></ul><ul><li><p>数值运算<br>使用<code>$(())</code>来实现整数数值运算</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#Program:</span><span class="token comment" spellcheck="true">#       cross two number</span>PATH<span class="token operator">=</span>/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin<span class="token function">export</span> PATH<span class="token keyword">echo</span> -e <span class="token string">"Input two number,the I multiplying them! \n"</span><span class="token function">read</span> -p <span class="token string">"first number"</span> first<span class="token function">read</span> -p <span class="token string">"second number"</span> secondtotal<span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>${first}<span class="token operator">*</span>${second}<span class="token variable">))</span></span><span class="token keyword">echo</span> -e <span class="token string">"\n The result of <span class="token variable">${first}</span>*<span class="token variable">${second}</span> ==> <span class="token variable">${total}</span>"</span></code></pre></li></ul><h5 id="script的执行方式的差异source，sh-script，-script"><a href="#script的执行方式的差异source，sh-script，-script" class="headerlink" title="script的执行方式的差异source，sh script，./script"></a>script的执行方式的差异source，sh script，./script</h5><h4 id="善用判断式"><a href="#善用判断式" class="headerlink" title="善用判断式"></a>善用判断式</h4><h5 id="利用test指令的测试功能"><a href="#利用test指令的测试功能" class="headerlink" title="利用test指令的测试功能"></a>利用test指令的测试功能</h5><h5 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号[]"></a>利用判断符号[]</h5><h5 id="Shell-Scripts的默认变量（-0，-1…）"><a href="#Shell-Scripts的默认变量（-0，-1…）" class="headerlink" title="Shell Scripts的默认变量（$0，$1…）"></a>Shell Scripts的默认变量（$0，$1…）</h5><h4 id="条件判断式"><a href="#条件判断式" class="headerlink" title="条件判断式"></a>条件判断式</h4><h5 id="利用if…then"><a href="#利用if…then" class="headerlink" title="利用if…then"></a>利用if…then</h5><h5 id="利用case…esac判断"><a href="#利用case…esac判断" class="headerlink" title="利用case…esac判断"></a>利用case…esac判断</h5><h5 id="利用function功能"><a href="#利用function功能" class="headerlink" title="利用function功能"></a>利用function功能</h5><h4 id="循环loop"><a href="#循环loop" class="headerlink" title="循环loop"></a>循环loop</h4><h5 id="while-do-done-util-do-done-不定循环"><a href="#while-do-done-util-do-done-不定循环" class="headerlink" title="while do done,util do done(不定循环)"></a>while do done,util do done(不定循环)</h5><h5 id="for…do…done-固定循环"><a href="#for…do…done-固定循环" class="headerlink" title="for…do…done(固定循环)"></a>for…do…done(固定循环)</h5><h5 id="for…do…done的数值处理"><a href="#for…do…done的数值处理" class="headerlink" title="for…do…done的数值处理"></a>for…do…done的数值处理</h5><h5 id="搭配随机数与数组的实验"><a href="#搭配随机数与数组的实验" class="headerlink" title="搭配随机数与数组的实验"></a>搭配随机数与数组的实验</h5><h4 id="Shell-Scripts的追踪与Debug"><a href="#Shell-Scripts的追踪与Debug" class="headerlink" title="Shell Scripts的追踪与Debug"></a>Shell Scripts的追踪与Debug</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;shell脚本就是将一些命令集合起来一起执行，类似于程序的编写，但是不需要compile&lt;/p&gt;
&lt;h4 id=&quot;What-is-Shell-Scripts&quot;&gt;&lt;a href=&quot;#What-is-Shell-Scripts&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="程序设计" scheme="http://jinzhengxu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Linux" scheme="http://jinzhengxu.github.io/tags/Linux/"/>
    
      <category term="Shell Scripts" scheme="http://jinzhengxu.github.io/tags/Shell-Scripts/"/>
    
      <category term="Shell" scheme="http://jinzhengxu.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux(8)-正则表达式与文件格式化处理</title>
    <link href="http://jinzhengxu.github.io/2019/05/19/niao-ge-de-linux-si-fang-cai-8-zheng-ze-biao-da-shi-yu-wen-jian-ge-shi-hua-chu-li/"/>
    <id>http://jinzhengxu.github.io/2019/05/19/niao-ge-de-linux-si-fang-cai-8-zheng-ze-biao-da-shi-yu-wen-jian-ge-shi-hua-chu-li/</id>
    <published>2019-05-19T06:44:00.000Z</published>
    <updated>2020-04-24T16:00:54.100Z</updated>
    
    <content type="html"><![CDATA[<p>简单的说,正则表达式就是用在字符串的处理上面的一项『表示式』。正则表达式并不是一个工具程序,而是一个字符串处理的标准依据,如果您想要以正则表达式的方式处理字符串,就得要使用支持正则表达式的工具程序才行, 这类的工具程序很多,例如 vi, sed, awk 等等。</p><p><strong><em>正则表达式与通配符是完全不一样的东西</em></strong> ,通配符 (wildcard) 代表的是 bash 操作接口的一个功能』,但正则表达式则是一种字符串处理的表示方式</p><h4 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h4><p>正则表达式就是处理字符串的方法,他是以行为单位来进行字符串的处理行为, 正则表达式透过一些特殊符号的辅助,可以让使用者轻易的达到『搜寻/删除/取代』某特定字符串的处理程序。</p><p>正则表达式基本上是一种『表示法』, 只要工具程序支持这种表示法,那么该工具程序就可以用来作为正则表达式的字符串处理之用。</p><ul><li>正则表达式对于系统管理员的用途</li></ul><p>系统的『错误讯息登录文件』 的内容记载了系统产生的所有讯息,包含系统是否被『入侵』的记录数据。但是系统的数据量太大了,系统管理员每天要接受海量讯息数据, 从千百行的资料<br>里面找出一行有问题的讯息,这个时候,就可以透过『正则表达式』的功能,将这些登录的信息进行处理, 仅取出『有问题』的信息来进行分析。</p><ul><li>正则表达式的广泛用途</li></ul><p>目前两大邮件服务器软件 sendmail与 postfix 以及支持邮件服务器的相关分析软件,都支持正则表达式的比对功能</p><ul><li>正则表达式与 Shell 在 Linux 当中的角色定位</li></ul><p>正则表达式,与前一章的 BASH 就有点像是数学的九九表一样,是 Linux 基础当中的基础,虽然也是最难的部分，不论是对于系统的认识与系统的管理部分,他都有很棒的辅助</p><ul><li>延伸的正则表达式</li></ul><p>正则表达式的字符串表示方式依照不同的严谨度而分为: 基础正则表达式与延伸正则表达式。</p><p>延伸型正则表达式除了简单的一组字符串处理之外,还可以作群组的字符串处理, 例如进行搜寻 Jason 或 netman 或 lman 的搜寻,注意,是『或(or)』而不是『和(and)』的处理, 此时就需要延伸正则表达式的帮助啦!藉由特殊的『 ( 』与『 | 』等字符的协助, 就能够达到这样的目的。</p><h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><p>既然正则表达式是处理字符串的一种表示方式,那么对字符排序有影响的 <strong><em>语系数据</em></strong> 就会对正则表达式的结果有影响。</p><h5 id="语系对正则表达式的影响"><a href="#语系对正则表达式的影响" class="headerlink" title="语系对正则表达式的影响"></a>语系对正则表达式的影响</h5><p>同语系的编码数据并不相同,所以就会造成数据截取结果的差异。</p><p>For example</p><pre><code>LANG=C     时:0 1 2 3 4 ... A B C D ... Z a b c d ...zLANG=zh_TW 时:0 1 2 3 4 ... a A b B c C d D ... z Z</code></pre><p>使用 [A-Z] 时, 会发现 LANG=C 确实可以仅捉到大写字符 (因为是连续的) ,但是如果LANG=zh_TW.big5 时,连同小写的 b-z 也会被截取出来。</p><p><strong><em>使用正则表达式时,需要特别留意当时环境的语系为何, 否则可能会发现与别人不相同的撷取结果</em></strong></p><h6 id="特殊符号表："><a href="#特殊符号表：" class="headerlink" title="特殊符号表："></a>特殊符号表：</h6><table><thead><tr><th>特殊符号</th><th>代表意义</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>代表英文大小写字符及数字,亦即 0-9, A-Z, a-z</td></tr><tr><td>[:alpha:]</td><td>代表任何英文大小写字符,亦即 A-Z, a-z</td></tr><tr><td>[:blank:]</td><td>代表空格键与 [Tab] 按键两者</td></tr><tr><td>[:cntrl:]</td><td>代表键盘上面的控制按键,亦即包括 CR, LF, Tab, Del.. 等等</td></tr><tr><td>[:digit:]</td><td>代表数字而已,亦即 0-9</td></tr><tr><td>[:graph:]</td><td>除了空格符 (空格键与 [Tab] 按键) 外的其他所有按键</td></tr><tr><td>[:lower:]</td><td>代表小写字符,亦即 a-z</td></tr><tr><td>[:print:]</td><td>代表任何可以被打印出来的字符</td></tr><tr><td>[:punct:]</td><td>代表标点符号 (punctuation symbol),亦即:” ‘ ? ! ; : # $…</td></tr><tr><td>[:upper:]</td><td>代表大写字符,亦即 A-Z</td></tr><tr><td>[:space:]</td><td>任何会产生空白的字符,包括空格键, [Tab], CR 等等</td></tr><tr><td>[:xdigit:]</td><td>代表 16 进位的数字类型,因此包括: 0-9, A-F, a-f 的数字与字符</td></tr></tbody></table><h5 id="grep的一线高级选项"><a href="#grep的一线高级选项" class="headerlink" title="grep的一线高级选项"></a>grep的一线高级选项</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> <span class="token punctuation">[</span>-A<span class="token punctuation">]</span> <span class="token punctuation">[</span>-B<span class="token punctuation">]</span> <span class="token punctuation">[</span>--color<span class="token operator">=</span>auto<span class="token punctuation">]</span> <span class="token string">'搜寻字符串'</span> filename选项与参数:-A :后面可加数字,为 after 的意思,除了列出该行外,后续的 n 行也列出来<span class="token punctuation">;</span>-B :后面可加数字,为 befer 的意思,除了列出该行外,前面的 n 行也列出来<span class="token punctuation">;</span>--color<span class="token operator">=</span>auto 可将正确的那个撷取数据列出颜色$ <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> inteldrmfb<span class="token punctuation">[</span>    2.972950<span class="token punctuation">]</span> fb: switching to inteldrmfb from EFI VGA<span class="token punctuation">[</span>    3.263535<span class="token punctuation">]</span> fbcon: inteldrmfb <span class="token punctuation">(</span>fb0<span class="token punctuation">)</span> is primary device<span class="token punctuation">[</span>    3.263601<span class="token punctuation">]</span> i915 0000:00:02.0: fb0: inteldrmfb frame buffer device<span class="token comment" spellcheck="true"># dmesg 可列出核心产生的讯息!包括硬件侦测的流程也会显示出来。</span><span class="token comment" spellcheck="true"># 使用的显卡是 inteldrmfb 核显,透过 grep 来 inteldrmfb的相关信息,可发现如上信息。</span>$ <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> -n --color<span class="token operator">=</span>auto <span class="token string">'inteldrmfb'</span>910:<span class="token punctuation">[</span>    2.972950<span class="token punctuation">]</span> fb: switching to inteldrmfb from EFI VGA926:<span class="token punctuation">[</span>    3.263535<span class="token punctuation">]</span> fbcon: inteldrmfb <span class="token punctuation">(</span>fb0<span class="token punctuation">)</span> is primary device928:<span class="token punctuation">[</span>    3.263601<span class="token punctuation">]</span> i915 0000:00:02.0: fb0: inteldrmfb frame buffer device<span class="token comment" spellcheck="true">#除了 inteldrmfb 会有特殊颜色来表示之外,最前面还有行号,其实颜色显示已经是默认在 alias 当中了!</span>$ <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> -n -A3 -B2 --color<span class="token operator">=</span>auto <span class="token string">'inteldrmfb'</span>908-<span class="token punctuation">[</span>    2.972948<span class="token punctuation">]</span> <span class="token punctuation">[</span>drm<span class="token punctuation">]</span> Memory usable by graphics device <span class="token operator">=</span> 4096M909-<span class="token punctuation">[</span>    2.972950<span class="token punctuation">]</span> checking generic <span class="token punctuation">(</span>b0000000 e10000<span class="token punctuation">)</span> vs hw <span class="token punctuation">(</span>b0000000 10000000<span class="token punctuation">)</span>910:<span class="token punctuation">[</span>    2.972950<span class="token punctuation">]</span> fb: switching to inteldrmfb from EFI VGA911-<span class="token punctuation">[</span>    2.972961<span class="token punctuation">]</span> Console: switching to colour dummy device 80x25912-<span class="token punctuation">[</span>    2.973096<span class="token punctuation">]</span> <span class="token punctuation">[</span>drm<span class="token punctuation">]</span> Replacing VGA console driver913-<span class="token punctuation">[</span>    2.979952<span class="token punctuation">]</span> <span class="token punctuation">[</span>drm<span class="token punctuation">]</span> Supports vblank timestamp caching Rev 2 <span class="token punctuation">(</span>21.10.2013<span class="token punctuation">)</span>.--924-<span class="token punctuation">[</span>    2.995577<span class="token punctuation">]</span> usb 1-8: SerialNumber: 0001925-<span class="token punctuation">[</span>    3.124110<span class="token punctuation">]</span> usb 1-9: new full-speed USB device number 4 using xhci_hcd926:<span class="token punctuation">[</span>    3.263535<span class="token punctuation">]</span> fbcon: inteldrmfb <span class="token punctuation">(</span>fb0<span class="token punctuation">)</span> is primary device927-<span class="token punctuation">[</span>    3.263578<span class="token punctuation">]</span> Console: switching to colour frame buffer device 320x90928:<span class="token punctuation">[</span>    3.263601<span class="token punctuation">]</span> i915 0000:00:02.0: fb0: inteldrmfb frame buffer device929-<span class="token punctuation">[</span>    3.277635<span class="token punctuation">]</span> usb 1-9: New USB device found, idVendor<span class="token operator">=</span>06cb, idProduct<span class="token operator">=</span>009a930-<span class="token punctuation">[</span>    3.277636<span class="token punctuation">]</span> usb 1-9: New USB device strings: Mfr<span class="token operator">=</span>0, Product<span class="token operator">=</span>0, SerialNumber<span class="token operator">=</span>1931-<span class="token punctuation">[</span>    3.277637<span class="token punctuation">]</span> usb 1-9: SerialNumber: 727eb8862574<span class="token comment" spellcheck="true">#在关键词所在行的前两行与后三行也一起捉出来显示</span></code></pre><p>grep 在数据中查寻一个字符串时,是以 “整行” 为单位来进行的。</p><h5 id="基础正则表达式练习"><a href="#基础正则表达式练习" class="headerlink" title="基础正则表达式练习"></a>基础正则表达式练习</h5><p>使用命令下载数据</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wget</span> http://linux.vbird.org/linux_basic/0330regularex/regular_express.txt</code></pre><p>前提：</p><ul><li>语系已经使用『 export LANG=C; export LC_ALL=C 』的设定值;</li><li>grep 已经使用 alias 设定成为『 grep –color=auto 』</li></ul><pre class=" language-bash"><code class="language-bash">$ localeLANG<span class="token operator">=</span>en_US.UTF-8LANGUAGE<span class="token operator">=</span>LC_CTYPE<span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span>LC_NUMERIC<span class="token operator">=</span>zh_CN.UTF-8LC_TIME<span class="token operator">=</span>zh_CN.UTF-8LC_COLLATE<span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span>LC_MONETARY<span class="token operator">=</span>zh_CN.UTF-8LC_MESSAGES<span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span>LC_PAPER<span class="token operator">=</span>zh_CN.UTF-8LC_NAME<span class="token operator">=</span>zh_CN.UTF-8LC_ADDRESS<span class="token operator">=</span>zh_CN.UTF-8LC_TELEPHONE<span class="token operator">=</span>zh_CN.UTF-8LC_MEASUREMENT<span class="token operator">=</span>zh_CN.UTF-8LC_IDENTIFICATION<span class="token operator">=</span>zh_CN.UTF-8LC_ALL<span class="token operator">=</span><span class="token comment" spellcheck="true">#查看一下当前语系</span>$  <span class="token function">export</span> LANG<span class="token operator">=</span>C LC_ALL<span class="token operator">=</span>C</code></pre><p>文件内容：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">vi</span> regular_express.txt<span class="token string">"Open Source"</span> is a good mechanism to develop programs.apple is my favorite food.Football game is not use feet only.this dress doesn<span class="token string">'t fit me.However, this dress is about $ 3183 dollars.GNU is free air not free beer.Her hair is very beauty.I can'</span>t finish the test.Oh<span class="token operator">!</span> The soup taste good.motorcycle is cheap than car.This window is clear.the symbol <span class="token string">'*'</span> is represented as start.Oh<span class="token operator">!</span>    My god<span class="token operator">!</span>The gd software is a library <span class="token keyword">for</span> drafting programs.You are the best is mean you are the no. 1.The world <span class="token operator">&lt;</span>Happy<span class="token operator">></span> is the same with <span class="token string">"glad"</span><span class="token keyword">.</span>I like dog.google is the best tools <span class="token keyword">for</span> search keyword.goooooogle yes<span class="token operator">!</span>go<span class="token operator">!</span> go<span class="token operator">!</span> Let's go.<span class="token comment" spellcheck="true"># I am VBird</span></code></pre><p>文件共有 22 行,最底下一行为空白行。</p><h6 id="搜寻特定字符串"><a href="#搜寻特定字符串" class="headerlink" title="搜寻特定字符串"></a>搜寻特定字符串</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -n <span class="token string">'the'</span> regular_express.txt8:I can<span class="token string">'t finish the test.12:the symbol '</span>*' is represented as start.15:You are the best is mean you are the no. 1.16:The world <span class="token operator">&lt;</span>Happy<span class="token operator">></span> is the same with <span class="token string">"glad"</span><span class="token keyword">.</span>18:google is the best tools <span class="token keyword">for</span> search keyword.</code></pre><h6 id="反向选择"><a href="#反向选择" class="headerlink" title="反向选择"></a>反向选择</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -vn <span class="token string">'the'</span> regular_express.txt1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.2:apple is my favorite food.3:Football game is not use feet only.4:this dress doesn<span class="token string">'t fit me.5:However, this dress is about $ 3183 dollars.6:GNU is free air not free beer.7:Her hair is very beauty.9:Oh! The soup taste good.10:motorcycle is cheap than car.11:This window is clear.13:Oh!    My god!14:The gd software is a library for drafting programs.17:I like dog.19:goooooogle yes!20:go! go! Let'</span>s go.21:<span class="token comment" spellcheck="true"># I am VBird</span>22:</code></pre><h6 id="取得不论大小写的-the-这个字符串"><a href="#取得不论大小写的-the-这个字符串" class="headerlink" title="取得不论大小写的 the 这个字符串"></a>取得不论大小写的 the 这个字符串</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -in <span class="token string">'the'</span> regular_express.txt8:I can<span class="token string">'t finish the test.9:Oh! The soup taste good.12:the symbol '</span>*' is represented as start.14:The gd software is a library <span class="token keyword">for</span> drafting programs.15:You are the best is mean you are the no. 1.16:The world <span class="token operator">&lt;</span>Happy<span class="token operator">></span> is the same with <span class="token string">"glad"</span><span class="token keyword">.</span>18:google is the best tools <span class="token keyword">for</span> search keyword.</code></pre><ul><li>利用中括号 [] 来搜寻集合字符<pre class=" language-bash"><code class="language-bash">$  <span class="token function">grep</span> -n <span class="token string">'t[ae]st'</span> regular_express.txt8:I can't finish the test.9:Oh<span class="token operator">!</span> The soup taste good.<span class="token comment" spellcheck="true"># 其实 [] 里面不论有几个字符,他都仅代表某『一个』字符</span></code></pre><h6 id="利用-取反"><a href="#利用-取反" class="headerlink" title="利用^取反"></a>利用^取反</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -n <span class="token string">'oo'</span> regular_express.txt1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.2:apple is my favorite food.3:Football game is not use feet only.9:Oh<span class="token operator">!</span> The soup taste good.18:google is the best tools <span class="token keyword">for</span> search keyword.19:goooooogle yes<span class="token operator">!</span>$ <span class="token function">grep</span> -n <span class="token string">'[^g]oo'</span> regular_express.txt2:apple is my favorite food.3:Football game is not use feet only.18:google is the best tools <span class="token keyword">for</span> search keyword.19:goooooogle yes<span class="token operator">!</span>$ <span class="token function">grep</span> -n <span class="token string">'[^a-z]oo'</span> regular_express.txt$ <span class="token function">grep</span> -n <span class="token string">'[^[:lower:]]oo'</span> regular_express.txt3:Football game is not use feet only.<span class="token comment" spellcheck="true"># oo 前面不想要有小写字符</span><span class="token comment" spellcheck="true"># [:lower:] 就是 a-z 的意思,那么 [a-z]就是 [[:lower:]]</span>$ <span class="token function">grep</span> -n <span class="token string">'[0-9]'</span> regular_express.txt$ <span class="token function">grep</span> -n <span class="token string">'[[:digit:]]'</span> regular_express.txt5:However, this dress is about $ 3183 dollars.15:You are the best is mean you are the no. 1.</code></pre><h6 id="行首与行尾字符"><a href="#行首与行尾字符" class="headerlink" title="行首与行尾字符 ^ $"></a>行首与行尾字符 ^ $</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -n <span class="token string">'^the'</span> regular_express.txt12:the symbol <span class="token string">'*'</span> is represented as start.$ <span class="token function">grep</span> -n <span class="token string">'^[a-z]'</span> regular_express.txt$ <span class="token function">grep</span> -n <span class="token string">'^[[:lower:]]'</span> regular_express.txt2:apple is my favorite food.4:this dress doesn<span class="token string">'t fit me.10:motorcycle is cheap than car.12:the symbol '</span>*<span class="token string">' is represented as start.18:google is the best tools for search keyword.19:goooooogle yes!20:go! go! Let'</span>s go.$ <span class="token function">grep</span> -n <span class="token string">'^[^a-zA-z]'</span> regular_express.txt$ <span class="token function">grep</span> -n <span class="token string">'^[^[:alpha:]]'</span> regular_express.txt1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.21:<span class="token comment" spellcheck="true"># I am VBird</span><span class="token comment" spellcheck="true">#^ 符号,在字符集合符号(括号[])之内与之外是不同的! 在 [] 内代表『反向选择』</span><span class="token comment" spellcheck="true">#在 [] 之外则代表定位在行首的意义!</span></code></pre><h6 id="行尾结束为小数点"><a href="#行尾结束为小数点" class="headerlink" title="行尾结束为小数点 (.)"></a>行尾结束为小数点 (.)</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -n <span class="token string">'\.$'</span> regular_express.txt1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.2:apple is my favorite food.3:Football game is not use feet only.4:this dress doesn<span class="token string">'t fit me.10:motorcycle is cheap than car.11:This window is clear.12:the symbol '</span>*<span class="token string">' is represented as start.15:You are the best is mean you are the no. 1.16:The world &lt;Happy> is the same with "glad".17:I like dog.18:google is the best tools for search keyword.20:go! go! Let'</span>s go.</code></pre><h6 id="Windows-平台的软件对于断行字符的判断问题"><a href="#Windows-平台的软件对于断行字符的判断问题" class="headerlink" title="Windows 平台的软件对于断行字符的判断问题"></a>Windows 平台的软件对于断行字符的判断问题</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> -An regular_express.txt <span class="token operator">|</span> <span class="token function">head</span> -n 10 <span class="token operator">|</span> <span class="token function">tail</span> -n 65 However, this dress is about $ 3183 dollars.^M$6 GNU is <span class="token function">free</span> air not <span class="token function">free</span> beer.^M$7 Her hair is very beauty.^M$8 I can't finish the test.^M$9 Oh<span class="token operator">!</span> The soup taste good.^M$10 motorcycle is cheap than car.$<span class="token comment" spellcheck="true">#5~9 行为 Windows 的断行字符 (^M$) ,而正常的 Linux 应该仅有第 10 行显示的那样 ($)</span></code></pre></li><li>找出来,哪一行是『空白行』<pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -n <span class="token string">'^$'</span> regular_express.txt22:$ <span class="token function">grep</span> -v <span class="token string">'^$'</span> /etc/rsyslog.conf <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">'^#'</span><span class="token comment" spellcheck="true"># 结果仅有 14 行,其中第一个『 -v '^$' 』代表『不要空白行』,</span><span class="token comment" spellcheck="true"># 第二个『 -v '^#' 』代表『不要开头是 # 的那行』喔!</span></code></pre><h6 id="任意一个字符-与重复字符"><a href="#任意一个字符-与重复字符" class="headerlink" title="任意一个字符 . 与重复字符 *"></a>任意一个字符 . 与重复字符 *</h6></li></ul><ul><li>. (小数点):代表『一定有一个任意字符』的意思;</li></ul><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -n <span class="token string">'g..d'</span> regular_express.txt  1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.  9:Oh<span class="token operator">!</span> The soup taste good.  16:The world <span class="token operator">&lt;</span>Happy<span class="token operator">></span> is the same with <span class="token string">"glad"</span><span class="token keyword">.</span></code></pre><ul><li>* (星号):代表『重复前一个字符, 0 到无穷多次』的意思,为组合形态<pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -n <span class="token string">'ooo*'</span> regular_express.txt1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.2:apple is my favorite food.3:Football game is not use feet only.9:Oh<span class="token operator">!</span> The soup taste good.18:google is the best tools <span class="token keyword">for</span> search keyword.19:goooooogle yes<span class="token operator">!</span>$ <span class="token function">grep</span> -n <span class="token string">'goo*g'</span> regular_express.txt18:google is the best tools <span class="token keyword">for</span> search keyword.19:goooooogle yes<span class="token operator">!</span>$ <span class="token function">grep</span> -n <span class="token string">'g*g'</span> regular_express.txt1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.3:Football game is not use feet only.9:Oh<span class="token operator">!</span> The soup taste good.13:Oh<span class="token operator">!</span>My god<span class="token operator">!</span>14:The gd software is a library <span class="token keyword">for</span> drafting programs.16:The world <span class="token operator">&lt;</span>Happy<span class="token operator">></span> is the same with <span class="token string">"glad"</span><span class="token keyword">.</span>17:I like dog.18:google is the best tools <span class="token keyword">for</span> search keyword.19:goooooogle yes<span class="token operator">!</span>20:go<span class="token operator">!</span> go<span class="token operator">!</span> Let<span class="token string">'s go.$ grep -n '</span>g.*g<span class="token string">' regular_express.txt1:"Open Source" is a good mechanism to develop programs.14:The gd software is a library for drafting programs.18:google is the best tools for search keyword.19:goooooogle yes!20:go! go! Let'</span>s go.$ <span class="token function">grep</span> -n <span class="token string">'[0-9][0-9]*'</span> regular_express.txt5:However, this dress is about $ 3183 dollars.15:You are the best is mean you are the no. 1.</code></pre><h6 id="限定连续-RE-字符范围"><a href="#限定连续-RE-字符范围" class="headerlink" title="限定连续 RE 字符范围 {}"></a>限定连续 RE 字符范围 {}</h6>因为 { 与 } 的符号在 shell 是有特殊意义的,因此, 我们必须要使用跳脱字符 \ 来让他失去特殊意义才行。<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 找到两个 o</span>1:<span class="token string">"Open Source"</span> is a good mechanism to develop programs.$ <span class="token function">grep</span> -n <span class="token string">'o\{2\}'</span> regular_express.txt2:apple is my favorite food.3:Football game is not use feet only.9:Oh<span class="token operator">!</span> The soup taste good.18:google is the best tools <span class="token keyword">for</span> search keyword.19:goooooogle yes<span class="token operator">!</span><span class="token comment" spellcheck="true"># g 后面接 2 到 5 个 o ,然后再接一个 g 的字符串</span>$ <span class="token function">grep</span> -n <span class="token string">'go\{2,5\}g'</span> regular_express.txt18:google is the best tools <span class="token keyword">for</span> search keyword.$ <span class="token function">grep</span> -n <span class="token string">'go\{2,\}g'</span> regular_express.txt18:google is the best tools <span class="token keyword">for</span> search keyword.19:goooooogle yes<span class="token operator">!</span></code></pre></li></ul><h5 id="基础正则表达式字符集合"><a href="#基础正则表达式字符集合" class="headerlink" title="基础正则表达式字符集合"></a>基础正则表达式字符集合</h5><table><thead><tr><th>RE 字符</th><th>意义与范例</th></tr></thead><tbody><tr><td>^word</td><td>意义:待搜寻的字符串(word)在行首</td></tr><tr><td>word$</td><td>意义:待搜寻的字符串(word)在行尾</td></tr><tr><td>.</td><td>意义:代表『一定有一个任意字符』的字符</td></tr><tr><td>\</td><td>意义:跳脱字符,将特殊符号的特殊意义去除</td></tr><tr><td>*</td><td>意义:重复零个到无穷多个的前一个 RE 字符</td></tr><tr><td>[list]</td><td>意义:字符集合的 RE 字符,里面列出想要撷取的字符</td></tr><tr><td>[n1-n2]</td><td>意义:字符集合的 RE 字符,里面列出想要撷取的字符范围</td></tr><tr><td>[^list]</td><td>意义:字符集合的 RE 字符,里面列出不要的字符串或范围</td></tr><tr><td>{n,m}</td><td>意义:连续 n 到 m 个的『前一个 RE 字符』意义:若为 {n} 则是连续 n 个的前一个 RE 字符,意义:若是 {n,} 则是连续 n 个以上的前一个 RE 字符!</td></tr></tbody></table><p><strong><em>『正则表达式的特殊字符』与一般在指令列输入指令的『通配符』并不相同。</em></strong><br>通配符当中的 * 代表的是『 0 ~ 无限多个字符』的意思,但是在正则表达式当中, * 则是『重复 0<br>到无穷多个的前一个 RE 字符』的意思</p><h5 id="sed工具"><a href="#sed工具" class="headerlink" title="sed工具"></a>sed工具</h5><p>sed 本身是一个管线命令,可以分析 standard input。 而且 sed还可以将数据进行取代、删除、新增、截取特定行等等的功能。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sed</span> <span class="token punctuation">[</span>-nefr<span class="token punctuation">]</span> <span class="token punctuation">[</span>动作<span class="token punctuation">]</span>选项与参数:-n :使用安静<span class="token punctuation">(</span>silent<span class="token punctuation">)</span>模式。在一般 <span class="token function">sed</span> 的用法中,所有来自 STDIN 的数据一般都会被列出到屏幕上。但如果加上 -n 参数后,则只有经过 <span class="token function">sed</span> 特殊处理的那一行<span class="token punctuation">(</span>或者动作<span class="token punctuation">)</span>才会被列出来。-e :直接在指令列模式上进行 <span class="token function">sed</span> 的动作编辑<span class="token punctuation">;</span>-f :直接将 <span class="token function">sed</span> 的动作写在一个文件内, -f filename 则可以执行 filename 内的 <span class="token function">sed</span> 动作<span class="token punctuation">;</span>-r :sed 的动作支持的是延伸型正则表达式的语法。<span class="token punctuation">(</span>预设是基础正则表达式语法<span class="token punctuation">)</span>-i :直接修改读取的文件内容,而不是由屏幕输出。动作说明:<span class="token punctuation">[</span>n1<span class="token punctuation">[</span>,n2<span class="token punctuation">]</span><span class="token punctuation">]</span>functionn1, n2 :不见得会存在,一般代表『选择进行动作的行数』,举例来说,如果我的动作是需要在 10 到 20 行之间进行的,则『 10,20<span class="token punctuation">[</span>动作行为<span class="token punctuation">]</span> 』<span class="token keyword">function</span> ：a :新增, a 的后面可以接字符串,而这些字符串会在新的一行出现<span class="token punctuation">(</span>目前的下一行<span class="token punctuation">)</span>~c :取代, c 的后面可以接字符串,这些字符串可以取代 n1,n2 之间的行<span class="token operator">!</span>d :删除,因为是删除啊,所以 d 后面通常不接任何咚咚<span class="token punctuation">;</span>i :插入, i 的后面可以接字符串,而这些字符串会在新的一行出现<span class="token punctuation">(</span>目前的上一行<span class="token punctuation">)</span><span class="token punctuation">;</span>p :打印,亦即将某个选择的数据印出。通常 p 会与参数 <span class="token function">sed</span> -n 一起运作~s :取代,可以直接进行取代的工作哩<span class="token operator">!</span>通常这个 s 的动作可以搭配正则表达式<span class="token operator">!</span>例如 1,20s/old/new/g 就是啦</code></pre><ul><li>以行为单位的新增/删除功能<pre class=" language-bash"><code class="language-bash">$ <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5d'</span>   1    root:x:0:0:root:/root:/bin/bash   6    games:x:5:60:games:/usr/games:/usr/sbin/nologin   7    man:x:6:12:man:/var/cache/man:/usr/sbin/nologin<span class="token comment" spellcheck="true">#,原本应该是要下达 sed -e 才对,没有 -e 也行</span>$  <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2a Drink tea or ......\> or drink beer ?'</span>   1    root:x:0:0:root:/root:/bin/bash   2    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinDrink tea or <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>or drink beer ?   3    bin:x:2:2:bin:/bin:/usr/sbin/nologin</code></pre><h6 id="以行为单位的取代与显示功能"><a href="#以行为单位的取代与显示功能" class="headerlink" title="以行为单位的取代与显示功能"></a>以行为单位的取代与显示功能</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5c NO 2-5 number'</span>  1    root:x:0:0:root:/root:/bin/bashNO 2-5 number  6    games:x:5:60:games:/usr/games:/usr/sbin/nologin$ <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'5,7p'</span>       5    sync:x:4:65534:sync:/bin:/bin/sync       6    games:x:5:60:games:/usr/games:/usr/sbin/nologin       7    man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</code></pre><h6 id="部分数据的搜寻并取代的功能"><a href="#部分数据的搜寻并取代的功能" class="headerlink" title="部分数据的搜寻并取代的功能"></a>部分数据的搜寻并取代的功能</h6></li></ul><p>sed 的搜寻与取代的与 vi 相当的类似</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sed</span> <span class="token string">'s/要被取代的字符串/新的字符串/g'</span>$ /sbin/ifconfig eth0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>inet 192.168.1.100mtu 1500netmask 255.255.255.0inet6 fe80::5054:ff:fedf:e174ether 52:54:00:df:e1:74broadcast 192.168.1.255prefixlen 64txqueuelen 1000scopeid 0x20<span class="token operator">&lt;</span>link<span class="token operator">></span><span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>$ /sbin/ifconfig eth0 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'inet '</span>inet 192.168.1.100netmask 255.255.255.0broadcast 192.168.1.255<span class="token comment" spellcheck="true"># 当场仅剩下一行!要注意, CentOS 7 与 CentOS 6 以前的 ifconfig 指令输出结果不太相同,</span><span class="token comment" spellcheck="true"># 鸟哥这个范例主要是针对 CentOS 7 以后的喔!接下来,我们要将开始到 addr: 通通删除,</span><span class="token comment" spellcheck="true"># 就是像底下这样:</span><span class="token comment" spellcheck="true"># inet 192.168.1.100 netmask 255.255.255.0</span><span class="token comment" spellcheck="true"># 上面的删除关键在于『 ^.*inet broadcast 192.168.1.255』啦!正则表达式出现! ^_^</span>$ /sbin/ifconfig eth0 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'inet '</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.*inet //g'</span>192.168.1.100netmask 255.255.255.0broadcast 192.168.1.255<span class="token comment" spellcheck="true"># 仔细与上个步骤比较一下,前面的部分不见了!接下来则是删除后续的部分,亦即:</span>192.168.1.100netmask 255.255.255.0broadcast 192.168.1.255<span class="token comment" spellcheck="true"># 此时所需的正则表达式为:『 ' *netmask.*$ 』就是啦!</span>$ /sbin/ifconfig eth0 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'inet '</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.*inet //g'</span> \<span class="token operator">></span><span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ *netmask.*$//g'</span>192.168.1.100$ <span class="token function">cat</span> /etc/man_db.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'MAN'</span><span class="token comment" spellcheck="true"># MANDATORY_MANPATH</span>manpath_element<span class="token comment" spellcheck="true"># MANPATH_MAP path_element manpath_element</span><span class="token comment" spellcheck="true"># MANDB_MAP global_manpath [relative_catpath]</span><span class="token comment" spellcheck="true"># every automatically generated MANPATH includes these fields</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">(</span>后面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span>删除掉批注之后的数据<span class="token operator">!</span>$ <span class="token function">cat</span> /etc/man_db.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'MAN'</span><span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/#.*$//g'</span>MANDATORY_MANPATH/usr/man<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">(</span>后面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token comment" spellcheck="true"># 从上面可以看出来,原本批注的数据都变成空白行啦!所以,接下来要删除掉空白行</span>$ <span class="token function">cat</span> /etc/man_db.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'MAN'</span><span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/#.*$//g'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/^$/d'</span>MANDATORY_MANPATH /usr/manMANDATORY_MANPATH /usr/share/manMANDATORY_MANPATH /usr/local/share/man<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">(</span>后面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre><h6 id="直接修改文件内容-危险动作"><a href="#直接修改文件内容-危险动作" class="headerlink" title="直接修改文件内容(危险动作)"></a>直接修改文件内容(危险动作)</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sed</span> -i <span class="token string">'s/\.$/\!/g'</span> regular_express.txt<span class="token comment" spellcheck="true"># 上头的 -i 选项可以让你的 sed 直接去修改后面接的文件内容而不是由屏幕输出喔!</span><span class="token comment" spellcheck="true"># 这个范例是用在取代!请您自行 cat 该文件去查阅结果啰</span><span class="token function">sed</span> -i <span class="token string">'<span class="token variable">$a</span> # This is a test'</span> regular_express.txt</code></pre><p>sed 的『 -i 』选项可以直接修改文件内容,这功能非常有帮助!举例来说,如果你有一个 100 万行<br>的文件,你要在第 100 行加某些文字,此时使用 vim 可能会疯掉!因为文件太大了!那怎办?就利<br>用 sed 啊!透过 sed 直接修改/取代的功能,你甚至不需要使用 vim 去修订!</p><h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> -v <span class="token string">'^$'</span> regular_express.txt <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token string">'^#'</span></code></pre><p>需要使用到管线命令来搜寻两次!那么如果使用延伸型的正则表达式,我们可以简化为:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">egrep</span> -v <span class="token string">'^$|^#'</span> regular_express.txt</code></pre><table><thead><tr><th>RE 字符</th><th>意义与范例</th></tr></thead><tbody><tr><td>+</td><td>意义:重复『一个或一个以上』的前一个 RE 字符</td></tr><tr><td>?</td><td>意义:『零个或一个』的前一个 RE 字符</td></tr><tr><td>|</td><td>意义:用或( or )的方式找出数个字符串</td></tr><tr><td>()</td><td>意义:找出『群组』字符串</td></tr><tr><td>()+</td><td>意义:多个重复群组的判别</td></tr></tbody></table><h4 id="文件的格式化与相关处理"><a href="#文件的格式化与相关处理" class="headerlink" title="文件的格式化与相关处理"></a>文件的格式化与相关处理</h4><h5 id="格式化打印：printf"><a href="#格式化打印：printf" class="headerlink" title="格式化打印：printf"></a>格式化打印：printf</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">printf</span> <span class="token string">'打印格式'</span> 实际内容选项与参数:关于格式方面的几个特殊样式:\a 警告声音输出\b 退格键<span class="token punctuation">(</span>backspace<span class="token punctuation">)</span>\f 清除屏幕 <span class="token punctuation">(</span>form feed<span class="token punctuation">)</span>\n 输出新的一行\r 亦即 Enter 按键\t 水平的 <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 按键\v 垂直的 <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 按键\xNN NN 为两位数的数字,可以转换数字成为字符。关于 C 程序语言内,常见的变数格式%ns 那个 n 是数字, s 代表 string ,亦即多少个字符<span class="token punctuation">;</span>%ni 那个 n 是数字, i 代表 integer ,亦即多少整数字数<span class="token punctuation">;</span>%N.nf 那个 n 与 N 都是数字, f 代表 floating <span class="token punctuation">(</span>浮点<span class="token punctuation">)</span>,如果有小数字数,假设我共要十个位数,但小数点有两位,即为 %10.2f 啰<span class="token operator">!</span></code></pre><pre class=" language-bash"><code class="language-bash">$ <span class="token function">printf</span> <span class="token string">'%s\t %s\t %s\t %s\t %s\t \n'</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> printf.txt<span class="token variable">)</span></span>Name     Chinese     English     Math     AverageDmTsai     80     60     92     77.33VBird     75     55     80     70.00Ken     60     90     70     73.33$ <span class="token function">printf</span> <span class="token string">'%10s %5i %5i %5i %8.2f \n'</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> printf.txt <span class="token operator">|</span> <span class="token function">grep</span> -v Name<span class="token variable">)</span></span>DmTsai 80 60 92 77.33VBird 75 55 80 70.00Ken 60 90 70 73.33</code></pre><p>printf 除了可以格式化处理之外,他还可以依据 ASCII 的数字与图形对应来显示数据(注 3)! 举<br>例来说 16 进位的 45 可以得到什么 ASCII 的显示图 (其实是字符)?</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">printf</span> <span class="token string">'\x45\n'</span>E<span class="token comment" spellcheck="true"># 这东西也很好玩~他可以将数值转换成为字符,如果你会写 script 的话,</span><span class="token comment" spellcheck="true"># 可以自行测试一下,由 20~80 之间的数值代表的字符是啥喔! ^_^</span></code></pre><h5 id="awk数据处理工具"><a href="#awk数据处理工具" class="headerlink" title="awk数据处理工具"></a>awk数据处理工具</h5><p>awk 也是一个非常棒的数据处理工具!相较于 sed 常常作用于一整个行的处理, awk 则比较倾向<br>于一行当中分成数个『字段』来处理。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">awk</span> <span class="token string">'条件类型 1{动作 1} 条件类型 2{动作 2} ...'</span> filename</code></pre><p>awk 主要是处理『每一行的字段内的数据』,而默认的『字段的分隔符为 “空格键” 或 “[tab]键” 』</p><pre class=" language-bash"><code class="language-bash">last -n 5jason    pts/0        j                Tue May 21 13:40   still logged <span class="token keyword">in</span>jason    :1           :1               Tue May 21 13:40   still logged <span class="token keyword">in</span><span class="token function">reboot</span>   system boot  4.15.0-50-generi Tue May 21 13:40   still runningjason    pts/0        j                Tue May 21 09:21 - down   <span class="token punctuation">(</span>03:00<span class="token punctuation">)</span>jason    :1           :1               Tue May 21 09:21 - 12:22  <span class="token punctuation">(</span>03:00<span class="token punctuation">)</span>wtmp begins Fri May  3 22:10:08 2019$ last -n 5 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span> "\t" <span class="token variable">$4</span>"\t"<span class="token variable">$5</span>}'</span>jason    Tue    Mayjason    Tue    May<span class="token function">reboot</span>    4.15.0-50-generi    Tuejason    Tue    Mayjason    Tue    Maywtmp    May    3</code></pre><p>每一行的每个字段都是有变量名称的,那就是 $1, $2… 等变量名称</p><ul><li>读入第一行,并将第一行的资料填入 $0, $1, $2…. 等变数当中;</li><li>依据 “条件类型” 的限制,判断是否需要进行后面的 “动作”;</li><li>做完所有的动作与条件类型;</li><li>若还有后续的『行』的数据,则重复上面 1~3 的步骤,直到所有的数据都读完为止。</li></ul><p>awk 是『以行为一次处理的单位』, 而『以字段为最小的处理单位』</p><p>| 变量名称| 代表意义|<br>| NF | 每一行 ($0) 拥有的字段总数 |<br>| NR | 目前 awk 所处理的是『第几行』数据 |<br>| FS | 目前的分隔字符,默认是空格键 |</p><p>awk 后续的所有动作是以单引号『 ‘ 』括住的,由于单引号与双引号都必须是成对的, 所以, awk 的格式内容如果想要以 print 打印时,记得非变量的文字部分,包含上一小节 printf 提到的格式中,都需要使用双引号来定义出来!因为单引号已经是 awk 的指令固定用法了!</p><pre class=" language-bash"><code class="language-bash">last -n 5 <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span> "\t lines: " NR"\t colums: " NF}'</span>jason     lines: 1     colums: 10jason     lines: 2     colums: 10<span class="token function">reboot</span>     lines: 3     colums: 10jason     lines: 4     colums: 10jason     lines: 5     colums: 10     lines: 6     colums: 0wtmp     lines: 7     colums: 7</code></pre><ul><li>awk 的逻辑运算字符<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{FS=":"} <span class="token variable">$3</span> &lt; 10 {print <span class="token variable">$1</span> "\t" <span class="token variable">$3</span>}'</span>root:x:0:0:root:/root:/bin/bashdaemon    1bin    2sys    3<span class="token function">sync</span>    4games    5<span class="token function">man</span>    6lp    7mail    8news    9</code></pre>因为我们读入第一行的时候,那些变数 $1,$2… 默认还是以空格键为分隔的,所以虽然我们定义了 FS=”:” 了, 但是却仅能在第二行后才开始生效。<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'BEGIN {FS=":"} <span class="token variable">$3</span> &lt; 10 {print <span class="token variable">$1</span> "\t " <span class="token variable">$3</span>}'</span>root 0bin 1daemon 2<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">(</span>以下省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre>假设我有一个薪资数据表档名为 pay.txt ,内容是这样的:<pre><code>Name     1st   2nd   3thVBird  23000 24000 25000DMTsai 21000 20000 23000Bird2  43000 42000 41000</code></pre></li><li>第一行只是说明,所以第一行不要进行加总 (NR==1 时处理);</li><li>第二行以后就会有加总的情况出现 (NR&gt;=2 以后处理)<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> pay.txt <span class="token operator">|</span>  <span class="token function">awk</span> <span class="token string">'NR==1{printf "%10s %10s %10s %10s %10s\n",<span class="token variable">$1</span>,<span class="token variable">$2</span>,<span class="token variable">$3</span>,<span class="token variable">$4</span>,"Total" }NR>=2{total = <span class="token variable">$2</span> + <span class="token variable">$3</span> + <span class="token variable">$4</span>printf "%10s %10d %10d %10d %10.2f\n", <span class="token variable">$1</span>, <span class="token variable">$2</span>, <span class="token variable">$3</span>, <span class="token variable">$4</span>, total}'</span>    Name        1st        2nd        3th      Total   VBird      23000      24000      25000   72000.00  DMTsai      21000      20000      23000   64000.00   Bird2      43000      42000      41000  126000.00</code></pre></li><li>awk 的指令间隔:所有 awk 的动作,亦即在 {} 内的动作,如果有需要多个指令辅助时,可利用分号『;』间隔, 或者直接以 [Enter] 按键来隔开每个指令,例如上面的范例中,鸟哥共按了三次 [enter] 喔!</li><li>逻辑运算当中,如果是『等于』的情况,则务必使用两个等号『==』!</li><li>格式化输出时,在 printf 的格式设定当中,务必加上 \n ,才能进行分行!</li><li>与 bash shell 的变量不同,在 awk 当中,变量可以直接使用,不需加上 $ 符号。</li></ul><p>awk的动作内 {} 也是支持 if (条件) 的</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> pay.txt <span class="token operator">|</span> \<span class="token operator">></span> <span class="token function">awk</span> <span class="token string">'{if(NR==1) printf "%10s %10s %10s %10s %10s\n",<span class="token variable">$1</span>,<span class="token variable">$2</span>,<span class="token variable">$3</span>,<span class="token variable">$4</span>,"Total"}> NR>=2{total = <span class="token variable">$2</span> + <span class="token variable">$3</span> + <span class="token variable">$4</span>> printf "%10s %10d %10d %10d %10.2f\n", <span class="token variable">$1</span>, <span class="token variable">$2</span>, <span class="token variable">$3</span>, <span class="token variable">$4</span>, total}'</span></code></pre><h5 id="文件比对工具"><a href="#文件比对工具" class="headerlink" title="文件比对工具"></a>文件比对工具</h5><p><strong><em>同一个软件包的不同版本之间,比较配置文件与原始档的差异</em></strong></p><h6 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h6><p>diff 就是用在比对两个文件之间的差异的,并且是以行为单位来比对的!一般是用在 ASCII 纯文本<br>档的比对上。 由于是以行为比对的单位,因此 <strong><em>diff 通常是用在同一的文件(或软件)的新旧版本差异上</em></strong></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> -p /tmp/testpw <span class="token operator">&lt;=</span><span class="token operator">=</span>先建立测试用的目录$ <span class="token function">cd</span> /tmp/testpw$ <span class="token function">cp</span> /etc/passwd passwd.old$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">'4d'</span> -e <span class="token string">'6c no six line'</span> <span class="token operator">></span> passwd.new<span class="token comment" spellcheck="true"># 注意一下, sed 后面如果要接超过两个以上的动作时,每个动作前面得加 -e 才行!</span><span class="token comment" spellcheck="true"># 透过这个动作,在 /tmp/testpw 里面便有新旧的 passwd 文件存在了!</span>$ <span class="token function">diff</span> <span class="token punctuation">[</span>-bBi<span class="token punctuation">]</span> from-file to-file选项与参数:from-file :一个档名,作为原始比对文件的档名<span class="token punctuation">;</span>to-file :一个档名,作为目的比对文件的档名<span class="token punctuation">;</span>注意,from-file 或 to-file 可以 - 取代,那个 - 代表『Standard input』之意。-b :忽略一行当中,仅有多个空白的差异<span class="token punctuation">(</span>例如 <span class="token string">"about me"</span> 与 <span class="token string">"about         me"</span> 视为相同-B :忽略空白行的差异。-i :忽略大小写的不同。$ <span class="token function">diff</span> passwwd.old passwd.new4d3<span class="token operator">&lt;</span> sys:x:3:3:sys:/dev:/usr/sbin/nologin6c5<span class="token operator">&lt;</span> games:x:5:60:games:/usr/games:/usr/sbin/nologin---<span class="token operator">></span> no six line</code></pre><p>不要用 diff 去比对两个完全不相干的文件,因为比不出</p><p>diff 也可以比对整个目录下的差异</p><p>举例来说,我们想要了解一下不同的开机执行等级 (runlevel) 内容有啥不同?假设你已经知道执行等级 0 与 5 的启动脚本分别放置到/etc/rc0.d 及 /etc/rc5.d , 则我们可以将两个目录比对一下:</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">diff</span> /etc/rc0.d/ /etc/rc5.d/Only <span class="token keyword">in</span> /etc/rc0.d/: K01alsa-utilsOnly <span class="token keyword">in</span> /etc/rc0.d/: K01avahi-daemon</code></pre><h6 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h6><p>cmp 主要也是在比对两个文件,他主要利用『字节』单位去比对, 因此,当然也可以比对 binary file</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cmp</span> passwd.old passwd.newpasswd.old passwd.new differ: byte 120, line 4<span class="token comment" spellcheck="true">#第一个发现的不同点在第四行,而且字节数是在第 120 个字节处</span></code></pre><h6 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h6><p>将旧的文件升级成为新的文件</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">diff</span> -Naur passwd.old passwd.new <span class="token operator">></span> passwd.patch$ <span class="token function">cat</span> passwd.patch--- passwd.old 2015-07-14 22:37:43.322535054 +0800+++ passwd.new 2015-07-14 22:38:03.010535054 +0800@@ -1,9 +1,8 @@<span class="token operator">&lt;=</span><span class="token operator">=</span>新旧文件的信息<span class="token operator">&lt;=</span><span class="token operator">=</span>新旧文件要修改数据的界定范围,旧档在 1-9 行,新檔在 1-8 行root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin-adm:x:3:4:adm:/var/adm:/sbin/nologin<span class="token operator">&lt;=</span><span class="token operator">=</span>左侧文件删除lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin-sync:x:5:0:sync:/sbin:/bin/sync <span class="token operator">&lt;=</span><span class="token operator">=</span>左侧文件删除+no six line <span class="token operator">&lt;=</span><span class="token operator">=</span>右侧新档加入shutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologin$ patch -pN <span class="token operator">&lt;</span> patch_file <span class="token operator">&lt;=</span><span class="token operator">=</span>更新$ patch -R -pN <span class="token operator">&lt;</span> patch_file <span class="token operator">&lt;=</span><span class="token operator">=</span>还原选项与参数:-p :后面可以接『取消几层目录』的意思。-R :代表还原,将新的文件还原成原来旧的版本。patch -p0 <span class="token operator">&lt;</span> passwd.patchpatching <span class="token function">file</span> passwd.old$ ll passwd*-rw-r--r-- 1 jason jason 2433 5月  21 17:52 passwd.new-rw-r--r-- 1 jason jason  515 5月  21 18:13 passwd.new.rej-rw-r--r-- 1 jason jason 2433 5月  21 18:13 passwd.old-rw-r--r-- 1 jason jason  514 5月  21 18:13 passwd.patch</code></pre><p>这里会使用 -p0 呢?因为我们在比对新旧版的数据时是在同一个目录下, 因此不需要减去目<br>录</p><h5 id="文件打印设置：pr"><a href="#文件打印设置：pr" class="headerlink" title="文件打印设置：pr"></a>文件打印设置：pr</h5><p>如果你曾经使用过一些图形接口的文字处理软件的话,那么很容易发现,当我们在打印的时候, 可<br>以同时选择与设定每一页打印时的标头</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">pr</span> /etc/man_db.conf</code></pre><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li>正规表示法就是处理字符串的方法,他是以行为单位来进行字符串的处理行为;</li><li>正规表示法透过一些特殊符号的辅助,可以让使用者轻易的达到『搜寻/删除/取代』某特定字符串的处理程序;<br>只要工具程序支持正规表示法,那么该工具程序就可以用来作为正规表示法的字符串处理之用;</li><li>正规表示法与通配符是完全不一样的东西!通配符 (wildcard) 代表的是 bash 操作接口的一个功能, 但正规表示法则是一种字符串处理的表示方式!</li><li>使用 grep 或其他工具进行正规表示法的字符串比对时,因为编码的问题会有不同的状态,因此, 你最好<br>将 LANG 等变量设定为 C 或者是 en 等英文语系!</li><li>由于编码系统的不同,不同的语系 (LANG) 会造成正规表示法撷取资料的差异。因此可利用特殊符号如<br>[:upper:] 来替代编码范围较佳;</li><li>基础正规表示法的特殊字符有: *, ., [], [-], [^], ^, $ 等!</li><li>常见的支持正规表示法的工具软件有: grep , sed, vim 等等</li><li>printf 可以透过一些特殊符号来将数据进行格式化输出;</li><li>awk 可以使用『字段』为依据,进行数据的重新整理与输出;</li><li>文件的比对中,可利用 diff 及 cmp 进行比对,其中 diff 主要用在纯文本文件方面的新旧版本比对</li><li>patch 指令可以将旧版数据更新到新版 (主要亦由 diff 建立 patch 的补丁来源文件)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的说,正则表达式就是用在字符串的处理上面的一项『表示式』。正则表达式并不是一个工具程序,而是一个字符串处理的标准依据,如果您想要以正则表达式的方式处理字符串,就得要使用支持正则表达式的工具程序才行, 这类的工具程序很多,例如 vi, sed, awk 等等。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://jinzhengxu.github.io/tags/Linux/"/>
    
      <category term="正则表达式" scheme="http://jinzhengxu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实验--Iris</title>
    <link href="http://jinzhengxu.github.io/2019/05/09/ji-qi-xue-xi-shi-yan-iris-jiao-cheng/"/>
    <id>http://jinzhengxu.github.io/2019/05/09/ji-qi-xue-xi-shi-yan-iris-jiao-cheng/</id>
    <published>2019-05-09T03:24:12.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><h4 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h4><p>这可能是模式识别文献中最著名的数据库。费舍尔的论文是该领域的经典之作，至今仍被频繁引用。（例如，参见Duda＆Hart。）数据集包含3个类别，每个类别50个实例，其中每个类别指的是一种鸢尾花。一类可以与另一类线性判别; 后者不能彼此线性判别。</p><p>对于三种不同的鸢尾花进行分类任务, <strong><em>数据集没有缺省的信息</em></strong> ，目标简单明了，通俗易懂。从<a href="https://archive.ics.uci.edu/ml/datasets/Iris" target="_blank" rel="noopener">项目地址</a>下载号我们需要的数据集。</p><p>首先解压我们得到的数据，数据中有两个文件<code>iris.names</code>和<code>Iris.data</code>，前者是对当前数据集的一个简单解释，后者是我们将要训练的数据。</p><h4 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h4><p>下面是每一行数据中，都好分隔开的字段所代表的不同含义。</p><pre><code>1.萼片长度cm2.萼片宽度cm3.花瓣长度cm4.花瓣宽度cm5.类：- Iris Setosa- Iris Versicolour- Iris Virginica</code></pre><p>这里，将分别使用两种方法 LDA 线性判别分析和 SVM 支持向量机。</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>首先先来看一下数据的大体情况吧！</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ <span class="token function">cat</span> Iris.data  <span class="token comment" spellcheck="true">#观察原始数据集</span>5.1,3.5,1.4,0.2,04.9,3.0,1.4,0.2,04.7,3.2,1.3,0.2,04.6,3.1,1.5,0.2,05.0,3.6,1.4,0.2,05.4,3.9,1.7,0.4,04.6,3.4,1.4,0.3,05.0,3.4,1.5,0.2,04.4,2.9,1.4,0.2,04.9,3.1,1.5,0.1,05.4,3.7,1.5,0.2,04.8,3.4,1.6,0.2,04.8,3.0,1.4,0.1,04.3,3.0,1.1,0.1,05.8,4.0,1.2,0.2,05.7,4.4,1.5,0.4,05.4,3.9,1.3,0.4,05.1,3.5,1.4,0.3,05.7,3.8,1.7,0.3,05.1,3.8,1.5,0.3,05.4,3.4,1.7,0.2,05.1,3.7,1.5,0.4,04.6,3.6,1.0,0.2,05.1,3.3,1.7,0.5,04.8,3.4,1.9,0.2,05.0,3.0,1.6,0.2,05.0,3.4,1.6,0.4,05.2,3.5,1.5,0.2,05.2,3.4,1.4,0.2,04.7,3.2,1.6,0.2,04.8,3.1,1.6,0.2,05.4,3.4,1.5,0.4,05.2,4.1,1.5,0.1,05.5,4.2,1.4,0.2,04.9,3.1,1.5,0.1,05.0,3.2,1.2,0.2,05.5,3.5,1.3,0.2,04.9,3.1,1.5,0.1,04.4,3.0,1.3,0.2,05.1,3.4,1.5,0.2,05.0,3.5,1.3,0.3,04.5,2.3,1.3,0.3,04.4,3.2,1.3,0.2,05.0,3.5,1.6,0.6,05.1,3.8,1.9,0.4,04.8,3.0,1.4,0.3,05.1,3.8,1.6,0.2,04.6,3.2,1.4,0.2,05.3,3.7,1.5,0.2,05.0,3.3,1.4,0.2,07.0,3.2,4.7,1.4,16.4,3.2,4.5,1.5,16.9,3.1,4.9,1.5,15.5,2.3,4.0,1.3,16.5,2.8,4.6,1.5,15.7,2.8,4.5,1.3,16.3,3.3,4.7,1.6,14.9,2.4,3.3,1.0,16.6,2.9,4.6,1.3,15.2,2.7,3.9,1.4,15.0,2.0,3.5,1.0,15.9,3.0,4.2,1.5,16.0,2.2,4.0,1.0,16.1,2.9,4.7,1.4,15.6,2.9,3.6,1.3,16.7,3.1,4.4,1.4,15.6,3.0,4.5,1.5,15.8,2.7,4.1,1.0,16.2,2.2,4.5,1.5,15.6,2.5,3.9,1.1,15.9,3.2,4.8,1.8,16.1,2.8,4.0,1.3,16.3,2.5,4.9,1.5,16.1,2.8,4.7,1.2,16.4,2.9,4.3,1.3,16.6,3.0,4.4,1.4,16.8,2.8,4.8,1.4,16.7,3.0,5.0,1.7,16.0,2.9,4.5,1.5,15.7,2.6,3.5,1.0,15.5,2.4,3.8,1.1,15.5,2.4,3.7,1.0,15.8,2.7,3.9,1.2,16.0,2.7,5.1,1.6,15.4,3.0,4.5,1.5,16.0,3.4,4.5,1.6,16.7,3.1,4.7,1.5,16.3,2.3,4.4,1.3,15.6,3.0,4.1,1.3,15.5,2.5,4.0,1.3,15.5,2.6,4.4,1.2,16.1,3.0,4.6,1.4,15.8,2.6,4.0,1.2,15.0,2.3,3.3,1.0,15.6,2.7,4.2,1.3,15.7,3.0,4.2,1.2,15.7,2.9,4.2,1.3,16.2,2.9,4.3,1.3,15.1,2.5,3.0,1.1,15.7,2.8,4.1,1.3,16.3,3.3,6.0,2.5,25.8,2.7,5.1,1.9,27.1,3.0,5.9,2.1,26.3,2.9,5.6,1.8,26.5,3.0,5.8,2.2,27.6,3.0,6.6,2.1,24.9,2.5,4.5,1.7,27.3,2.9,6.3,1.8,26.7,2.5,5.8,1.8,27.2,3.6,6.1,2.5,26.5,3.2,5.1,2.0,26.4,2.7,5.3,1.9,26.8,3.0,5.5,2.1,25.7,2.5,5.0,2.0,25.8,2.8,5.1,2.4,26.4,3.2,5.3,2.3,26.5,3.0,5.5,1.8,27.7,3.8,6.7,2.2,27.7,2.6,6.9,2.3,26.0,2.2,5.0,1.5,26.9,3.2,5.7,2.3,25.6,2.8,4.9,2.0,27.7,2.8,6.7,2.0,26.3,2.7,4.9,1.8,26.7,3.3,5.7,2.1,27.2,3.2,6.0,1.8,26.2,2.8,4.8,1.8,26.1,3.0,4.9,1.8,26.4,2.8,5.6,2.1,27.2,3.0,5.8,1.6,27.4,2.8,6.1,1.9,27.9,3.8,6.4,2.0,26.4,2.8,5.6,2.2,26.3,2.8,5.1,1.5,26.1,2.6,5.6,1.4,27.7,3.0,6.1,2.3,26.3,3.4,5.6,2.4,26.4,3.1,5.5,1.8,26.0,3.0,4.8,1.8,26.9,3.1,5.4,2.1,26.7,3.1,5.6,2.4,26.9,3.1,5.1,2.3,25.8,2.7,5.1,1.9,26.8,3.2,5.9,2.3,26.7,3.3,5.7,2.5,26.7,3.0,5.2,2.3,26.3,2.5,5.0,1.9,26.5,3.0,5.2,2.0,26.2,3.4,5.4,2.3,25.9,3.0,5.1,1.8,2</code></pre><p>很容易理解，这里我们抽出一个字段来看</p><pre><code>    5.9   ,   3.0  ,   5.1   ,   1.8   , 2|萼片长度cm|萼片宽度cm|花瓣长度cm|花瓣宽度cm| 类 |</code></pre><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>好了既然我们已经知道数据是完整的，这里首先对原始数据预处理一下，改成比较适合的格式，这里可以使用python来完成，但是这里我是使用cut command将数据流重定向至一个信的csv文件，因为python还得编译的搞，不太舒服。</p><p>这里需要注意的两点是1.win下txt文件会在换行的时候加一个<code>^M</code>符号，虽然丢我们数据的处理可能不会产生影响，但是还是tr command去掉好了；2.在加入数据到csv文件时，不要忘记加入表头，否则一会数据分析的时候就很难看。</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Dat$ <span class="token keyword">echo</span> SepalLength,SepalWidth,PetalLength,\<span class="token operator">></span> PetalWidth,FClass <span class="token operator">></span> data.csvJason@X1:~/flower/Data$ <span class="token function">cat</span> Iris.data <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">'\r'</span> <span class="token operator">|</span><span class="token function">cut</span> -d<span class="token string">','</span> -f 1,2,3,4,5 <span class="token operator">>></span> data.csv<span class="token comment" spellcheck="true"># 没有返回错误信息，原目录下应该完成了转换。</span><span class="token comment" spellcheck="true"># 下面这条指令也有同样的效果</span>Jason@X1:~/flower/Data$ <span class="token function">cat</span> Iris.data <span class="token operator">|</span> <span class="token function">tr</span> -d <span class="token string">'\r'</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'BEGIN\{FS=","} {print <span class="token variable">$1</span>","<span class="token variable">$2</span>","<span class="token variable">$3</span>","<span class="token variable">$4</span>","<span class="token variable">$5</span>}'</span> <span class="token operator">>></span> real.csv<span class="token comment" spellcheck="true"># 看看格式是否正确</span>Jason@X1:~/flower/Data$ <span class="token function">xdg-open</span> data.csv</code></pre><p><img src="https://s2.ax1x.com/2019/05/15/ETsd2R.png" alt="ETsd2R.png"><br>好，可以看到我们的数据完美的被分隔了到了新建的<code>data.csv</code>中，这就非常舒服。</p><h4 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h4><p>利用<code>pandas</code>数据分析模块和<code>numpy</code>科学计算模块来分析数据。首先读入我们的数据：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFramedata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/data.csv'</span><span class="token punctuation">,</span>engine <span class="token operator">=</span> <span class="token string">'python'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'UTF-8'</span><span class="token punctuation">)</span>data_train <span class="token comment" spellcheck="true">#dataframe格式</span></code></pre><p>这里就可以看到data.csv中的数据了。但是只有数据表我们很难从中找出规律。所以接下来通过pandas中的方法来大体查看一下数据集的全貌。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> data_train.info<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>运行一下唉</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Dat$ py3 linear.py<span class="token punctuation">[</span>150 rows x 5 columns<span class="token punctuation">]</span><span class="token operator">&lt;</span>class <span class="token string">'pandas.core.frame.DataFrame'</span><span class="token operator">></span>RangeIndex: 150 entries, 0 to 149Data columns <span class="token punctuation">(</span>total 5 columns<span class="token punctuation">)</span>:SepalLength    150 non-null float64SepalWidth     150 non-null float64PetalLength    150 non-null float64PetalWidth     150 non-null float64FClass         150 non-null int64dtypes: float64<span class="token punctuation">(</span>4<span class="token punctuation">)</span>, int64<span class="token punctuation">(</span>1<span class="token punctuation">)</span>memory usage: 5.9 KBNone</code></pre><p>这里可以看到这150条记录都是非空的，并且前四个字段为float，最后一个为int型，看来Fisher没有故意搞我们，确实数据没有缺省。</p><p>然后我们再使用describe来看一下</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data_train<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span>       SepalLength  SepalWidth  PetalLength  PetalWidth      FClasscount   <span class="token number">150.000000</span>  <span class="token number">150.000000</span>   <span class="token number">150.000000</span>  <span class="token number">150.000000</span>  <span class="token number">150.000000</span>mean      <span class="token number">5.843333</span>    <span class="token number">3.054000</span>     <span class="token number">3.758667</span>    <span class="token number">1.198667</span>    <span class="token number">1.000000</span>std       <span class="token number">0.828066</span>    <span class="token number">0.433594</span>     <span class="token number">1.764420</span>    <span class="token number">0.763161</span>    <span class="token number">0.819232</span>min       <span class="token number">4.300000</span>    <span class="token number">2.000000</span>     <span class="token number">1.000000</span>    <span class="token number">0.100000</span>    <span class="token number">0.000000</span><span class="token number">25</span><span class="token operator">%</span>       <span class="token number">5.100000</span>    <span class="token number">2.800000</span>     <span class="token number">1.600000</span>    <span class="token number">0.300000</span>    <span class="token number">0.000000</span><span class="token number">50</span><span class="token operator">%</span>       <span class="token number">5.800000</span>    <span class="token number">3.000000</span>     <span class="token number">4.350000</span>    <span class="token number">1.300000</span>    <span class="token number">1.000000</span><span class="token number">75</span><span class="token operator">%</span>       <span class="token number">6.400000</span>    <span class="token number">3.300000</span>     <span class="token number">5.100000</span>    <span class="token number">1.800000</span>    <span class="token number">2.000000</span>max       <span class="token number">7.900000</span>    <span class="token number">4.400000</span>     <span class="token number">6.900000</span>    <span class="token number">2.500000</span>    <span class="token number">2.000000</span></code></pre><p>describe() 还是nice啊，我把describe的内容整理成一个表格，这样是不是更清晰一些</p><table><thead><tr><th></th><th>Min</th><th>Max</th><th>Mean</th><th>SD</th><th>Class</th><th>Correlation</th></tr></thead><tbody><tr><td>SepalLength</td><td>4.3</td><td>7.9</td><td>5.84</td><td>0.83</td><td>0.7826</td><td></td></tr><tr><td>SepalWidth</td><td>2.0</td><td>4.4</td><td>3.05</td><td>0.43</td><td>-0.4194</td><td></td></tr><tr><td>PetalLength</td><td>1.0</td><td>6.9</td><td>3.76</td><td>1.76</td><td>0.9490</td><td>(high!)</td></tr><tr><td>PetalWidth</td><td>0.1</td><td>2.5</td><td>1.20</td><td>0.76</td><td>0.9565</td><td>(high!)</td></tr></tbody></table><p>可以观察到，表格中最后两个item中Class的致是最高的，可以假设一下我们的花朵分类应该会跟这两个item关系密切（PS：因为要求用三次二分类做，所以这里我们可以现不用猜测数据简单关系）。</p><h4 id="PL和PW与属性结果的关系"><a href="#PL和PW与属性结果的关系" class="headerlink" title="PL和PW与属性结果的关系"></a>PL和PW与属性结果的关系</h4><p>第一个猜想是和PL，PW有关，看一下情况</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFramedata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltfig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>fig<span class="token punctuation">.</span>set<span class="token punctuation">(</span>alpha<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#设定图表颜色颜色</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_train<span class="token punctuation">.</span>PetalLength<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># x轴数据为PL</span>            data_train<span class="token punctuation">.</span>PetalWidth<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># y轴数据为PW</span>            s <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的大小</span>            c <span class="token operator">=</span> <span class="token string">'steelblue'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的颜色</span>            marker <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的形状</span>            alpha <span class="token operator">=</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的透明度</span>            <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_train<span class="token punctuation">.</span>PetalLength<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            data_train<span class="token punctuation">.</span>PetalWidth<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            s <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>            c <span class="token operator">=</span> <span class="token string">'green'</span><span class="token punctuation">,</span>            marker <span class="token operator">=</span> <span class="token string">'o'</span><span class="token punctuation">,</span>            alpha <span class="token operator">=</span> <span class="token number">0.9</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_train<span class="token punctuation">.</span>PetalLength<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            data_train<span class="token punctuation">.</span>PetalWidth<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            s <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>            c <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>            marker <span class="token operator">=</span> <span class="token string">'+'</span><span class="token punctuation">,</span>            alpha <span class="token operator">=</span> <span class="token number">0.9</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span>u<span class="token string">"Pw"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>u<span class="token string">"PW,PL realation to FCalss"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#标题</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span>u<span class="token string">"PL"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Dat$ py3 linear.py</code></pre><p><a href="https://imgchr.com/i/ExfvQA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/20/ExfvQA.png" alt="ExfvQA.png"></a><br>可以看到第一类鸢尾花Iris Setosa可以从后面两种中分离出来。</p><h4 id="SL和SW与属性结果的关系"><a href="#SL和SW与属性结果的关系" class="headerlink" title="SL和SW与属性结果的关系"></a>SL和SW与属性结果的关系</h4><p>这样还是制作一张散点图</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFramedata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltfig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>fig<span class="token punctuation">.</span>set<span class="token punctuation">(</span>alpha<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#设定图表颜色颜色</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_train<span class="token punctuation">.</span>SepalLength<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># x轴数据为PL</span>            data_train<span class="token punctuation">.</span>SepalWidth<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># y轴数据为PW</span>            s <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的大小</span>            c <span class="token operator">=</span> <span class="token string">'steelblue'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的颜色</span>            marker <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的形状</span>            alpha <span class="token operator">=</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 设置点的透明度</span>            <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_train<span class="token punctuation">.</span>SepalLength<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            data_train<span class="token punctuation">.</span>SepalWidth<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            s <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>            c <span class="token operator">=</span> <span class="token string">'green'</span><span class="token punctuation">,</span>            marker <span class="token operator">=</span> <span class="token string">'o'</span><span class="token punctuation">,</span>            alpha <span class="token operator">=</span> <span class="token number">0.9</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_train<span class="token punctuation">.</span>SepalLength<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            data_train<span class="token punctuation">.</span>SepalWidth<span class="token punctuation">[</span>data_train<span class="token punctuation">.</span>FClass<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            s <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>            c <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">,</span>            marker <span class="token operator">=</span> <span class="token string">'+'</span><span class="token punctuation">,</span>            alpha <span class="token operator">=</span> <span class="token number">0.9</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span>u<span class="token string">"Sw"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>u<span class="token string">"SW,SL realation to FCalss"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#标题</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span>u<span class="token string">"SL"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://s2.ax1x.com/2019/05/20/ExhuwV.png" alt="ExhuwV.png"><br>纳尼，看来SW分离不出来什么东西，和第一次是差不多的,看来通过某两对属性组就能分类的想法是不可能了。但是我们可以看出来，第一类鸢尾花无论是花瓣还是花萼都与后面两类差很多，分离出第一种化是比较容易的，重点放在如何分离拆开后两种花朵类型。</p><p>下面就要进入瞎猜的环节来看看还有哪些猜想是成立的，这里使用一个库函数帮我们理出所有的可能</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFramedata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltfig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>fig<span class="token punctuation">.</span>set<span class="token punctuation">(</span>alpha<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#设定图表颜色颜色</span><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> snssns<span class="token punctuation">.</span>pairplot<span class="token punctuation">(</span>data_train<span class="token punctuation">,</span>hue<span class="token operator">=</span><span class="token string">'FClass'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><a href="https://imgchr.com/i/ExhaTK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/20/ExhaTK.md.png" alt="ExhaTK.md.png"></a><br>看来在所有情况下Iris Versicolour和Iris Virginica都比较难区分。</p><h3 id="线性判别分析LDA"><a href="#线性判别分析LDA" class="headerlink" title="线性判别分析LDA"></a>线性判别分析LDA</h3><p>Linear Discriminant Analysis，器最主要的作用我觉得是对数据进行降维，通过将多维数据向更低空间投影，从而能获得一个易于理解的概念模型。</p><p>这里我们通过单个二分类问题的概念推到出多类线性判别分析。</p><h4 id="低维空间的选择"><a href="#低维空间的选择" class="headerlink" title="低维空间的选择"></a>低维空间的选择</h4><p>如何选择一个维度合适的空间，作为我们的特征空间呢？是将一个 d 维数据集投影到一个 k （ k&lt;d)维子空间中,如何选择k的大小。比如对于目前我们系哪有的数据集，就有2维或3维这两种降维选择。<br><a href="https://imgchr.com/i/EHTOqU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/16/EHTOqU.md.gif" alt="EHTOqU.md.gif"></a><br><img src="https://s2.ax1x.com/2019/05/16/EHHzg1.png" alt="EHHzg1.png"></p><p> 这里用到的方法是求特征向量,然后将器归总到类内散度矩阵和类间散度矩阵。<br>$$<br>\begin{align}<br> &amp; S_w=\Sigma_0+\Sigma_1=\sum_{x \in X_0}(x-\mu_0)(x-\mu_0)^T+\sum_{x \in X_1}(x-\mu_1)(x-\mu_1)^T \\<br> &amp; S_b=(\mu_0-\mu_1)(\mu_0-\mu_1)^T<br> \end{align}<br>$$</p><p> 每一个特征向量都对应一个特征值， 如果特征值的大小接近就代表我们投影到的空间维度比较合适。</p><h4 id="基本方法和步骤"><a href="#基本方法和步骤" class="headerlink" title="基本方法和步骤"></a>基本方法和步骤</h4><ul><li>计算数据集中不同类别数据的 d 维均值向量。</li><li>计算散度矩阵，包括类间、类内散度矩阵。</li><li>计算散度矩阵的特征向量 e1,e2,…,ed 和对应的特征值 λ1,λ2,…,λd。</li><li>特征向量按特征值大小降序排列，选前 k 个特征值对应的特征向量，组建一个 d×k 维矩阵——每一列就是一个特征向量。</li><li>用这个 d×k-维特征向量矩阵将样本变换到新的子空间。这一步可以写作矩阵乘法 $Y=X×W$ 。 X 是 n×d 维矩阵，表示 n 个样本； Y 是变换到子空间后的 n×k 维样本。</li></ul><h4 id="conjecture"><a href="#conjecture" class="headerlink" title="conjecture"></a>conjecture</h4><p>通过前面的一些基本分析，我们已经知道区分花朵类型的在四种特征里面，花瓣的长度、宽度更适合用来区分三种鸢尾花类别。但这是否正确还是要看一下结果,用直方图做一下映射</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> math<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFrame<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltlabel_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">'Iris-Setosa'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'Iris-Versicolor'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'Iris-Virginica'</span><span class="token punctuation">}</span>feature_dict <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>label <span class="token keyword">for</span> i<span class="token punctuation">,</span>label <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>data_train <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>data_train<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span>l <span class="token keyword">for</span> i<span class="token punctuation">,</span>l <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>feature_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span>X <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesy <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesfig<span class="token punctuation">,</span> axes <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span>nrows<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> ncols<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> ax<span class="token punctuation">,</span>cnt <span class="token keyword">in</span> zip<span class="token punctuation">(</span>axes<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># set bin sizes</span>    min_b <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>min<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    max_b <span class="token operator">=</span> math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>np<span class="token punctuation">.</span>max<span class="token punctuation">(</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    bins <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span>min_b<span class="token punctuation">,</span> max_b<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># plottling the histograms</span>    <span class="token keyword">for</span> lab<span class="token punctuation">,</span>col <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ax<span class="token punctuation">.</span>hist<span class="token punctuation">(</span>X<span class="token punctuation">[</span>y<span class="token operator">==</span>lab<span class="token number">-1</span><span class="token punctuation">,</span> cnt<span class="token punctuation">]</span><span class="token punctuation">,</span>                   color<span class="token operator">=</span>col<span class="token punctuation">,</span>                   label<span class="token operator">=</span><span class="token string">'class %s'</span> <span class="token operator">%</span>label_dict<span class="token punctuation">[</span>lab<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   bins<span class="token operator">=</span>bins<span class="token punctuation">,</span>                   alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token punctuation">)</span>    ylims <span class="token operator">=</span> ax<span class="token punctuation">.</span>get_ylim<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># plot annotation</span>    leg <span class="token operator">=</span> ax<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper right'</span><span class="token punctuation">,</span> fancybox<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>    leg<span class="token punctuation">.</span>get_frame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_alpha<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>set_ylim<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>ylims<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span>feature_dict<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Iris histogram #%s'</span> <span class="token operator">%</span>str<span class="token punctuation">(</span>cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># hide axis ticks</span>    ax<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> which<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span>            labelbottom<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> labelleft<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># remove axis spines</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"top"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"bottom"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'count'</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'count'</span><span class="token punctuation">)</span>fig<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><a href="https://imgchr.com/i/Exhy6A" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/20/Exhy6A.md.png" alt="Exhy6A.md.png"></a><br>仅凭这些简单的图形化展示，已经足以让我们得出结论：在四种特征里面，花瓣的长度、宽度更适合用来区分三种鸢尾花类别。</p><p>实际应用中，比起通过投影降维（此处即LDA），另一种比较好的办法是做特征筛选。像鸢尾花这样的低维数据集，看一眼直方图就能得到很多信息了。</p><h5 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h5><ul><li>计算数据的 d 维均值向量</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> math<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFrame<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltfeature_dict <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>label <span class="token keyword">for</span> i<span class="token punctuation">,</span>label <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>data_train <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>data_train<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span>l <span class="token keyword">for</span> i<span class="token punctuation">,</span>l <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>feature_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#print (data_train.tail())</span>X_src <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesy_src <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesX<span class="token punctuation">,</span> X_spl<span class="token punctuation">,</span> y<span class="token punctuation">,</span> y_spl <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X_src<span class="token punctuation">,</span> y_src<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y_src<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print (X.tail(),y.tail())</span>np<span class="token punctuation">.</span>set_printoptions<span class="token punctuation">(</span>precision<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>mean_vectors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> clo <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    mean_vectors<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">[</span>y<span class="token operator">==</span>clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Mean Vector FClass %s: %s\n'</span> <span class="token operator">%</span><span class="token punctuation">(</span>clo<span class="token number">-1</span><span class="token punctuation">,</span>mean_vectors<span class="token punctuation">[</span>clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>py一下</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ py3 LDA.pyMean Vector FClass 0: <span class="token punctuation">[</span>4.9886 3.4114 1.4886 0.2371<span class="token punctuation">]</span>Mean Vector FClass 1: <span class="token punctuation">[</span>5.9486 2.7314 4.2371 1.3086<span class="token punctuation">]</span>Mean Vector FClass 2: <span class="token punctuation">[</span>6.6829 3.0086 5.6314 2.0686<span class="token punctuation">]</span></code></pre><ul><li>计算散度矩阵<br>$$<br>S_w=\Sigma_0+\Sigma_1=\sum_{x \in X_0}(x-\mu_0)(x-\mu_0)^T+\sum_{x \in X_1}(x-\mu_1)(x-\mu_1)^T<br>$$<pre class=" language-python"><code class="language-python">S_W <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#4x4的矩阵</span><span class="token keyword">for</span> clo<span class="token punctuation">,</span>mv <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mean_vectors<span class="token punctuation">)</span><span class="token punctuation">:</span>  class_sc_mat <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> row <span class="token keyword">in</span> X<span class="token punctuation">[</span>y <span class="token operator">==</span> clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>      row<span class="token punctuation">,</span> mv <span class="token operator">=</span> row<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>      class_sc_mat <span class="token operator">+=</span> <span class="token punctuation">(</span>row<span class="token operator">-</span>mv<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>row<span class="token operator">-</span>mv<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span>  S_W <span class="token operator">+=</span> class_sc_mat<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类内散度矩阵:\n'</span><span class="token punctuation">,</span> S_W<span class="token punctuation">)</span></code></pre>py一下<pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ py3 LDA.py类内散度矩阵:<span class="token punctuation">[</span><span class="token punctuation">[</span>26.9126  9.7063 17.5711  3.2614<span class="token punctuation">]</span><span class="token punctuation">[</span> 9.7063 13.2583  5.7343  3.0851<span class="token punctuation">]</span><span class="token punctuation">[</span>17.5711  5.7343 19.4926  4.0283<span class="token punctuation">]</span><span class="token punctuation">[</span> 3.2614  3.0851  4.0283  3.8246<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre>$$<br>S_b=(\mu_0-\mu_1)(\mu_0-\mu_1)^T<br>$$</li></ul><pre class=" language-python"><code class="language-python">overall_mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>S_B <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>mean_vec <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>mean_vectors<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> X<span class="token punctuation">[</span>y<span class="token operator">==</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    mean_vec <span class="token operator">=</span> mean_vec<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    overall_mean <span class="token operator">=</span> overall_mean<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    S_B <span class="token operator">+=</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>mean_vec <span class="token operator">-</span> overall_mean<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>mean_vec <span class="token operator">-</span> overall_mean<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类间散度矩阵:\n'</span><span class="token punctuation">,</span> S_B<span class="token punctuation">)</span></code></pre><p>py一下</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ py3 LDA.py类间散度矩阵: <span class="token punctuation">[</span><span class="token punctuation">[</span> 50.5328 -13.205  124.6189  54.7119<span class="token punctuation">]</span> <span class="token punctuation">[</span>-13.205    8.1842 -36.7686 -14.6504<span class="token punctuation">]</span> <span class="token punctuation">[</span>124.6189 -36.7686 311.056  135.2389<span class="token punctuation">]</span> <span class="token punctuation">[</span> 54.7119 -14.6504 135.2389  59.263 <span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><ul><li>求解矩阵的广义特征值</li></ul><pre class=" language-bash"><code class="language-bash">eig_vals, eig_vecs <span class="token operator">=</span> np.linalg.eig<span class="token punctuation">(</span>np.linalg.inv<span class="token punctuation">(</span>S_W<span class="token punctuation">)</span>.dot<span class="token punctuation">(</span>S_B<span class="token punctuation">))</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>eig_vals<span class="token punctuation">))</span>:    eigvec_sc <span class="token operator">=</span> eig_vecs<span class="token punctuation">[</span>:,i<span class="token punctuation">]</span>.reshape<span class="token punctuation">(</span>4,1<span class="token punctuation">)</span>    print<span class="token punctuation">(</span><span class="token string">'\n特征向量 {}: \n{}'</span>.format<span class="token punctuation">(</span>i+1, eigvec_sc.real<span class="token punctuation">))</span>    print<span class="token punctuation">(</span><span class="token string">'特征值 {:}: {:.2e}'</span>.format<span class="token punctuation">(</span>i+1, eig_vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.real<span class="token punctuation">))</span></code></pre><p>py一下</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ py3 LDA.py特征向量 1:<span class="token punctuation">[</span><span class="token punctuation">[</span>-0.1895<span class="token punctuation">]</span> <span class="token punctuation">[</span>-0.3302<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.5051<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.7746<span class="token punctuation">]</span><span class="token punctuation">]</span>特征值 1: 3.23e+01特征向量 2:<span class="token punctuation">[</span><span class="token punctuation">[</span> 0.0448<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.5551<span class="token punctuation">]</span> <span class="token punctuation">[</span>-0.2891<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.7786<span class="token punctuation">]</span><span class="token punctuation">]</span>特征值 2: 3.72e-01特征向量 3:<span class="token punctuation">[</span><span class="token punctuation">[</span> 0.4887<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.1004<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.1842<span class="token punctuation">]</span> <span class="token punctuation">[</span>-0.8468<span class="token punctuation">]</span><span class="token punctuation">]</span>特征值 3: -4.92e-15特征向量 4:<span class="token punctuation">[</span><span class="token punctuation">[</span> 0.7403<span class="token punctuation">]</span> <span class="token punctuation">[</span>-0.3929<span class="token punctuation">]</span> <span class="token punctuation">[</span>-0.4662<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.2834<span class="token punctuation">]</span><span class="token punctuation">]</span>特征值 4: 2.78e-15</code></pre><p>特征向量和特征值代表了一个线性变换的形变程度，特征向量是形变的方向，特征值是形变的大小。</p><ul><li>选择线性判别器构成新的特征子空间</li></ul><p>将特征向量根据特征值的大小从高到低排序，然后选择前 k 个本征向量：</p><pre class=" language-python"><code class="language-python">eig_pairs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>eig_vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eig_vecs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>eig_vals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>eig_pairs <span class="token operator">=</span> sorted<span class="token punctuation">(</span>eig_pairs<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> k<span class="token punctuation">:</span> k<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'特征值:\n'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> eig_pairs<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>py一下</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ py3 LDA.py特征值:32.341821356487370.371713784453321874.915564356595094e-152.7775787346756613e-15</code></pre><p>我们将4d空间投影到2d空间上，所以选择前两个特征向量。在LDA中，线性判别器的数目最多是 c−1，c 是总的类别数，这是因为类内散布矩阵 SB 是 c 个秩为1或0的矩阵的和。</p><p>按特征值的大小得到降序排列的本征对之后，现在就可以组建我们的 k×d-维特征向量矩阵 W 了（此时大小为 4×2），这样就从最初的4维特征空间降到了2维的特征空间。</p><pre class=" language-python"><code class="language-python">W <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>eig_pairs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eig_pairs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'矩阵 W:\n'</span><span class="token punctuation">,</span> W<span class="token punctuation">.</span>real<span class="token punctuation">)</span></code></pre><p>py一下</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ py3 LDA.py矩阵 W: <span class="token punctuation">[</span><span class="token punctuation">[</span>-0.1895  0.0448<span class="token punctuation">]</span> <span class="token punctuation">[</span>-0.3302  0.5551<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.5051 -0.2891<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.7746  0.7786<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><ul><li>将样本变换到新的子空间中</li></ul><p>使用上一步刚刚计算出的 4×2-维矩阵 W， 将样本变换到新的特征空间上：</p><pre class=" language-python"><code class="language-python">X_lda <span class="token operator">=</span> X<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span>label_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">'Iris-Setosa'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'Iris-Versicolor'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'Iris-Virginica'</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">plot_step_lda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> label<span class="token punctuation">,</span>marker<span class="token punctuation">,</span>color <span class="token keyword">in</span> zip<span class="token punctuation">(</span>        range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'^'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token operator">=</span>X_lda<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>y <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                y<span class="token operator">=</span>X_lda<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>y <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                marker<span class="token operator">=</span>marker<span class="token punctuation">,</span>                color<span class="token operator">=</span>color<span class="token punctuation">,</span>                alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>                label<span class="token operator">=</span>label_dict<span class="token punctuation">[</span>label<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'LD1'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'LD2'</span><span class="token punctuation">)</span>    leg <span class="token operator">=</span> plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper right'</span><span class="token punctuation">,</span> fancybox<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    leg<span class="token punctuation">.</span>get_frame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_alpha<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'LDA: Iris projection onto the first 2 linear discriminants'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># hide axis ticks</span>    plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> which<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span>            labelbottom<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> labelleft<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># remove axis spines</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"top"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"bottom"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>tight_layout    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>plot_step_lda<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="结果绘图"><a href="#结果绘图" class="headerlink" title="结果绘图"></a>结果绘图</h4><p><img src="https://s2.ax1x.com/2019/05/20/ExhIpQ.png" alt="ExhIpQ.png"><br>上方散点图展示了我们通过 LDA 构建的新的特征子空间。可以看到第一个线性判别器“LD1”把不同类数据区分得不错，第二个线性判别器就不行了。其原因在上面已经做了简单解释。</p><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>然后就是对样本结果集的预测了。</p><pre class=" language-python"><code class="language-python">X_lda <span class="token operator">=</span> X<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span>label_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">'Iris-Setosa'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'Iris-Versicolor'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'Iris-Virginica'</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">plot_step_lda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> label<span class="token punctuation">,</span>marker<span class="token punctuation">,</span>color <span class="token keyword">in</span> zip<span class="token punctuation">(</span>        range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'^'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token operator">=</span>X_lda<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>y <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                y<span class="token operator">=</span>X_lda<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>y <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                marker<span class="token operator">=</span>marker<span class="token punctuation">,</span>                color<span class="token operator">=</span>color<span class="token punctuation">,</span>                alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>                label<span class="token operator">=</span>label_dict<span class="token punctuation">[</span>label<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'LD1'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'LD2'</span><span class="token punctuation">)</span>    leg <span class="token operator">=</span> plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper right'</span><span class="token punctuation">,</span> fancybox<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    leg<span class="token punctuation">.</span>get_frame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_alpha<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'LDA: Iris projection onto the first 2 linear discriminants'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># hide axis ticks</span>    plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> which<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span>            labelbottom<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> labelleft<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># remove axis spines</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"top"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"bottom"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>tight_layout    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>plot_step_lda<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>下面比较一下我们的模型和实际的测试集有多大的误差</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> math<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltfeature_dict <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>label <span class="token keyword">for</span> i<span class="token punctuation">,</span>label <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>data_train <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>data_train<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span>l <span class="token keyword">for</span> i<span class="token punctuation">,</span>l <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>feature_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#print (data_train.tail())</span>X_src <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesy_src <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesX<span class="token punctuation">,</span> X_spl<span class="token punctuation">,</span> y<span class="token punctuation">,</span> y_spl <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X_src<span class="token punctuation">,</span> y_src<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y_src<span class="token punctuation">)</span>np<span class="token punctuation">.</span>set_printoptions<span class="token punctuation">(</span>precision<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>mean_vectors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> clo <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    mean_vectors<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">[</span>y<span class="token operator">==</span>clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Mean Vector FClass %s: %s\n'</span> <span class="token operator">%</span><span class="token punctuation">(</span>clo<span class="token number">-1</span><span class="token punctuation">,</span>mean_vectors<span class="token punctuation">[</span>clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>S_W <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#4x4的矩阵</span><span class="token keyword">for</span> clo<span class="token punctuation">,</span>mv <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mean_vectors<span class="token punctuation">)</span><span class="token punctuation">:</span>    class_sc_mat <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> row <span class="token keyword">in</span> X<span class="token punctuation">[</span>y <span class="token operator">==</span> clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        row<span class="token punctuation">,</span> mv <span class="token operator">=</span> row<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        class_sc_mat <span class="token operator">+=</span> <span class="token punctuation">(</span>row<span class="token operator">-</span>mv<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>row<span class="token operator">-</span>mv<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span>    S_W <span class="token operator">+=</span> class_sc_mat<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类内散度矩阵:\n'</span><span class="token punctuation">,</span> S_W<span class="token punctuation">)</span>overall_mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>S_B <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>mean_vec <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>mean_vectors<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> X<span class="token punctuation">[</span>y<span class="token operator">==</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    mean_vec <span class="token operator">=</span> mean_vec<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    overall_mean <span class="token operator">=</span> overall_mean<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    S_B <span class="token operator">+=</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>mean_vec <span class="token operator">-</span> overall_mean<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>mean_vec <span class="token operator">-</span> overall_mean<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类间散度矩阵:\n'</span><span class="token punctuation">,</span> S_B<span class="token punctuation">)</span>eig_vals<span class="token punctuation">,</span> eig_vecs <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>eig<span class="token punctuation">(</span>np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>inv<span class="token punctuation">(</span>S_W<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>S_B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>eig_vals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    eigvec_sc <span class="token operator">=</span> eig_vecs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n特征向量 {}: \n{}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> eigvec_sc<span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'特征值 {:}: {:.2e}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> eig_vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token punctuation">)</span>eig_pairs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>eig_vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eig_vecs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>eig_vals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>eig_pairs <span class="token operator">=</span> sorted<span class="token punctuation">(</span>eig_pairs<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> k<span class="token punctuation">:</span> k<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'特征值:\n'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> eig_pairs<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>W <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>eig_pairs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eig_pairs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'矩阵 W:\n'</span><span class="token punctuation">,</span> W<span class="token punctuation">.</span>real<span class="token punctuation">)</span>X_lda <span class="token operator">=</span> X_spl<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span>label_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">'Iris-Setosa'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'Iris-Versicolor'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'Iris-Virginica'</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">plot_step_lda</span><span class="token punctuation">(</span>argX<span class="token punctuation">,</span>argy<span class="token punctuation">,</span>title<span class="token punctuation">)</span><span class="token punctuation">:</span>    ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> label<span class="token punctuation">,</span>marker<span class="token punctuation">,</span>color <span class="token keyword">in</span> zip<span class="token punctuation">(</span>        range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'^'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token operator">=</span>argX<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>argy <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                y<span class="token operator">=</span>argX<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>argy <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                marker<span class="token operator">=</span>marker<span class="token punctuation">,</span>                color<span class="token operator">=</span>color<span class="token punctuation">,</span>                alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>                label<span class="token operator">=</span>label_dict<span class="token punctuation">[</span>label<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'LD1'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'LD2'</span><span class="token punctuation">)</span>    leg <span class="token operator">=</span> plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper right'</span><span class="token punctuation">,</span> fancybox<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    leg<span class="token punctuation">.</span>get_frame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_alpha<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>title<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># hide axis ticks</span>    plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> which<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span>            labelbottom<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> labelleft<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># remove axis spines</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"top"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"bottom"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>tight_layout    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>y_pred<span class="token operator">=</span>y_spl<span class="token comment" spellcheck="true">#print (data_train.tail())</span><span class="token comment" spellcheck="true">#print (X.tail())</span>plot_step_lda<span class="token punctuation">(</span>X_lda<span class="token punctuation">,</span>y_spl<span class="token punctuation">,</span><span class="token string">"The Orignal Test Set"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">:</span>        y_pred<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">elif</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">and</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">1.69</span><span class="token punctuation">:</span>        y_pred<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">elif</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">1.69</span><span class="token punctuation">:</span>        y_pred<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token comment" spellcheck="true">#print(y_pred)</span>plot_step_lda<span class="token punctuation">(</span>X_lda<span class="token punctuation">,</span>y_pred<span class="token punctuation">,</span><span class="token string">"The Prediction Of LDA"</span><span class="token punctuation">)</span></code></pre><p><img src="https://s2.ax1x.com/2019/05/20/EzPu0x.png" alt="EzPu0x.png"><br><img src="https://s2.ax1x.com/2019/05/20/EzPgun.png" alt="EzPgun.png"><br>可以看到我们只有一个数据点出现了误差。</p><h4 id="猜想验证"><a href="#猜想验证" class="headerlink" title="猜想验证"></a>猜想验证</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> math<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltfeature_dict <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>label <span class="token keyword">for</span> i<span class="token punctuation">,</span>label <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>data_train <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>data_train<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span>l <span class="token keyword">for</span> i<span class="token punctuation">,</span>l <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>feature_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#print (data_train.tail())</span>X_src <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesy_src <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesX<span class="token punctuation">,</span> X_spl<span class="token punctuation">,</span> y<span class="token punctuation">,</span> y_spl <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X_src<span class="token punctuation">,</span> y_src<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y_src<span class="token punctuation">)</span>np<span class="token punctuation">.</span>set_printoptions<span class="token punctuation">(</span>precision<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>mean_vectors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> clo <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    mean_vectors<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">[</span>y<span class="token operator">==</span>clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Mean Vector FClass %s: %s\n'</span> <span class="token operator">%</span><span class="token punctuation">(</span>clo<span class="token number">-1</span><span class="token punctuation">,</span>mean_vectors<span class="token punctuation">[</span>clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>S_W <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#2x2的矩阵</span><span class="token keyword">for</span> clo<span class="token punctuation">,</span>mv <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mean_vectors<span class="token punctuation">)</span><span class="token punctuation">:</span>    class_sc_mat <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> row <span class="token keyword">in</span> X<span class="token punctuation">[</span>y <span class="token operator">==</span> clo<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        row<span class="token punctuation">,</span> mv <span class="token operator">=</span> row<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mv<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        class_sc_mat <span class="token operator">+=</span> <span class="token punctuation">(</span>row<span class="token operator">-</span>mv<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>row<span class="token operator">-</span>mv<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span>    S_W <span class="token operator">+=</span> class_sc_mat<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类内散度矩阵:\n'</span><span class="token punctuation">,</span> S_W<span class="token punctuation">)</span>overall_mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>S_B <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>mean_vec <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>mean_vectors<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> X<span class="token punctuation">[</span>y<span class="token operator">==</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    mean_vec <span class="token operator">=</span> mean_vec<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    overall_mean <span class="token operator">=</span> overall_mean<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    S_B <span class="token operator">+=</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>mean_vec <span class="token operator">-</span> overall_mean<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>mean_vec <span class="token operator">-</span> overall_mean<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'类间散度矩阵:\n'</span><span class="token punctuation">,</span> S_B<span class="token punctuation">)</span>eig_vals<span class="token punctuation">,</span> eig_vecs <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>eig<span class="token punctuation">(</span>np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>inv<span class="token punctuation">(</span>S_W<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>S_B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>eig_vals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    eigvec_sc <span class="token operator">=</span> eig_vecs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n特征向量 {}: \n{}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> eigvec_sc<span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'特征值 {:}: {:.2e}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> eig_vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token punctuation">)</span>eig_pairs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>eig_vals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eig_vecs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>eig_vals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>eig_pairs <span class="token operator">=</span> sorted<span class="token punctuation">(</span>eig_pairs<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> k<span class="token punctuation">:</span> k<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'特征值:\n'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> eig_pairs<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>W <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>eig_pairs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eig_pairs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'矩阵 W:\n'</span><span class="token punctuation">,</span> W<span class="token punctuation">.</span>real<span class="token punctuation">)</span>X_lda <span class="token operator">=</span> X_spl<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span>label_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">'Iris-Setosa'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'Iris-Versicolor'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'Iris-Virginica'</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">plot_step_lda</span><span class="token punctuation">(</span>argX<span class="token punctuation">,</span>argy<span class="token punctuation">,</span>title<span class="token punctuation">)</span><span class="token punctuation">:</span>    ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> label<span class="token punctuation">,</span>marker<span class="token punctuation">,</span>color <span class="token keyword">in</span> zip<span class="token punctuation">(</span>        range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'^'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token operator">=</span>argX<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>argy <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                y<span class="token operator">=</span>argX<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>argy <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                marker<span class="token operator">=</span>marker<span class="token punctuation">,</span>                color<span class="token operator">=</span>color<span class="token punctuation">,</span>                alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>                label<span class="token operator">=</span>label_dict<span class="token punctuation">[</span>label<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'LD1'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'LD2'</span><span class="token punctuation">)</span>    leg <span class="token operator">=</span> plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper right'</span><span class="token punctuation">,</span> fancybox<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    leg<span class="token punctuation">.</span>get_frame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_alpha<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>title<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># hide axis ticks</span>    plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> which<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span>            labelbottom<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> labelleft<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># remove axis spines</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"top"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"bottom"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>tight_layout    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>y_pred<span class="token operator">=</span>y_spl<span class="token comment" spellcheck="true">#print (data_train.tail())</span><span class="token comment" spellcheck="true">#print (X.tail())</span>plot_step_lda<span class="token punctuation">(</span>X_lda<span class="token punctuation">,</span>y_spl<span class="token punctuation">,</span><span class="token string">"The Orignal Test Set"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">2.5</span><span class="token punctuation">:</span>        y_pred<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">elif</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">2.5</span> <span class="token operator">and</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">4.9</span><span class="token punctuation">:</span>        y_pred<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">elif</span> X_lda<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">4.9</span><span class="token punctuation">:</span>        y_pred<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token comment" spellcheck="true">#print(y_pred)</span>plot_step_lda<span class="token punctuation">(</span>X_lda<span class="token punctuation">,</span>y_pred<span class="token punctuation">,</span><span class="token string">"The Prediction Of LDA"</span><span class="token punctuation">)</span></code></pre><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Dat$ py3 conj.pyMean Vector FClass 0: <span class="token punctuation">[</span>1.4886 0.2371<span class="token punctuation">]</span>类内散度矩阵: <span class="token punctuation">[</span><span class="token punctuation">[</span>0.7954 0.1149<span class="token punctuation">]</span> <span class="token punctuation">[</span>0.1149 0.3417<span class="token punctuation">]</span><span class="token punctuation">]</span>类间散度矩阵: <span class="token punctuation">[</span><span class="token punctuation">[</span>184.6903  77.7966<span class="token punctuation">]</span> <span class="token punctuation">[</span> 77.7966  32.77  <span class="token punctuation">]</span><span class="token punctuation">]</span>特征向量 1:<span class="token punctuation">[</span><span class="token punctuation">[</span>0.7997<span class="token punctuation">]</span> <span class="token punctuation">[</span>0.6003<span class="token punctuation">]</span><span class="token punctuation">]</span>特征值 1: 2.76e+02特征向量 2:<span class="token punctuation">[</span><span class="token punctuation">[</span>-0.3882<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.9216<span class="token punctuation">]</span><span class="token punctuation">]</span>特征值 2: 0.00e+00特征值:275.72242108209240.0矩阵 W: <span class="token punctuation">[</span><span class="token punctuation">[</span> 0.7997 -0.3882<span class="token punctuation">]</span> <span class="token punctuation">[</span> 0.6003  0.9216<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p><img src="https://s2.ax1x.com/2019/05/20/EzF3yd.png" alt="EzF3yd.png"><br><img src="https://s2.ax1x.com/2019/05/20/EzF0Sg.png" alt="EzF0Sg.png"><br>这次分类错误了两个数据点，看来SW，SL对于分类也有一定的作用（虽然很小）</p><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><p>主成分分析（PCA）是一种统计过程，它使用正交变换将可能相关变量的一组观察值（每个实体都采用各种数值）转换为一组称为主成分的线性不相关变量值。如果有  ñ 观察与  p 变量，然后是不同主成分的数量 min(n-1,p)。这种转换的定义方式是第一主成分具有尽可能大的方差（即，尽可能多地考虑数据的可变性），并且每个后续成分依次在约束下具有最高的方差。它与前面的组件正交。得到的矢量（每个是变量的线性组合并包含n个观测值）是不相关的正交基组。PCA对原始变量的相对缩放敏感。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> math<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFrame<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltlabel_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">'Iris-Setosa'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'Iris-Versicolor'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'Iris-Virginica'</span><span class="token punctuation">}</span>feature_dict <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>label <span class="token keyword">for</span> i<span class="token punctuation">,</span>label <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>data_train <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>data_train<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span>l <span class="token keyword">for</span> i<span class="token punctuation">,</span>l <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>feature_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span>X <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'SL'</span><span class="token punctuation">,</span><span class="token string">'SW'</span><span class="token punctuation">,</span><span class="token string">'PL'</span><span class="token punctuation">,</span><span class="token string">'PW'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valuesy <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">'FClass'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token comment" spellcheck="true">#X_src = data_train[['SL','SW','PL','PW']].values</span><span class="token comment" spellcheck="true">#y_src = data_train['FClass'].values</span><span class="token comment" spellcheck="true">#X, X_spl, y, y_spl = train_test_split(X_src, y_src, test_size=0.3, random_state=42,stratify=y_src)</span><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>decomposition <span class="token keyword">import</span> PCA<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>discriminant_analysis <span class="token keyword">import</span> LinearDiscriminantAnalysis <span class="token keyword">as</span> LDAtarget_names <span class="token operator">=</span> label_dictpca <span class="token operator">=</span> PCA<span class="token punctuation">(</span>n_components<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>X_r <span class="token operator">=</span> pca<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>transform<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#X_p = pca.predict(X_spl)</span>lda <span class="token operator">=</span> LDA<span class="token punctuation">(</span>n_components<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>X_r2 <span class="token operator">=</span> lda<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">.</span>transform<span class="token punctuation">(</span>X<span class="token punctuation">)</span>X_p <span class="token operator">=</span> lda<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span>label_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">'Iris-Setosa'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">'Iris-Versicolor'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">'Iris-Virginica'</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">plot_step_lda</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span>title<span class="token punctuation">)</span><span class="token punctuation">:</span>    ax <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> label<span class="token punctuation">,</span>marker<span class="token punctuation">,</span>color <span class="token keyword">in</span> zip<span class="token punctuation">(</span>        range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'^'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token operator">=</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>y <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                y<span class="token operator">=</span>X<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>real<span class="token punctuation">[</span>y <span class="token operator">==</span> label<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                marker<span class="token operator">=</span>marker<span class="token punctuation">,</span>                color<span class="token operator">=</span>color<span class="token punctuation">,</span>                alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>                label<span class="token operator">=</span>label_dict<span class="token punctuation">[</span>label<span class="token number">-1</span><span class="token punctuation">]</span>                <span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'LD1'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'LD2'</span><span class="token punctuation">)</span>    leg <span class="token operator">=</span> plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper right'</span><span class="token punctuation">,</span> fancybox<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    leg<span class="token punctuation">.</span>get_frame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_alpha<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>title<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># hide axis ticks</span>    plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> which<span class="token operator">=</span><span class="token string">"both"</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span>            labelbottom<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token string">"off"</span><span class="token punctuation">,</span> labelleft<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># remove axis spines</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"top"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"bottom"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    ax<span class="token punctuation">.</span>spines<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>tight_layout    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>plot_step_lda<span class="token punctuation">(</span>X_r<span class="token punctuation">,</span><span class="token string">'PCA'</span><span class="token punctuation">)</span>plot_step_lda<span class="token punctuation">(</span>X_r2<span class="token punctuation">,</span><span class="token string">'LDA'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Percentage of variance explained for each components</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'explained variance ratio (first two components): %s'</span>      <span class="token operator">%</span> str<span class="token punctuation">(</span>pca<span class="token punctuation">.</span>explained_variance_ratio_<span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="支持向量机SVM"><a href="#支持向量机SVM" class="headerlink" title="支持向量机SVM"></a>支持向量机SVM</h3><h4 id="数据集分割"><a href="#数据集分割" class="headerlink" title="数据集分割"></a>数据集分割</h4><p>这里每个化的种类由50个item，所以我们抽出40个进行训练，剩下的10个做测试集，这里使用train_test_split函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFrame<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_splitdata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>x <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"SepalLength"</span><span class="token punctuation">,</span><span class="token string">"SepalWidth"</span><span class="token punctuation">,</span><span class="token string">"PetalLength"</span><span class="token punctuation">,</span><span class="token string">"PetalWidth"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>y <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">"FClass"</span><span class="token punctuation">]</span>x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y<span class="token punctuation">)</span></code></pre><h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><p>直接调用sklearn中的函数即可，完全不需要写逻辑。其实LDA也是，但是为了理解内容我们还是稍微写一下LDA的。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFrame<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegressiondata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>x <span class="token operator">=</span>data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"SepalLength"</span><span class="token punctuation">,</span><span class="token string">"SepalWidth"</span><span class="token punctuation">,</span><span class="token string">"PetalLength"</span><span class="token punctuation">,</span><span class="token string">"PetalWidth"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>y <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">"FClass"</span><span class="token punctuation">]</span>x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y<span class="token punctuation">)</span>classifier <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>classifier<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span></code></pre><p>最后py运行一下</p><h4 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFrame<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metricsdata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>x <span class="token operator">=</span>data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"SepalLength"</span><span class="token punctuation">,</span><span class="token string">"SepalWidth"</span><span class="token punctuation">,</span><span class="token string">"PetalLength"</span><span class="token punctuation">,</span><span class="token string">"PetalWidth"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>y <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">"FClass"</span><span class="token punctuation">]</span>x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这里本来是像使用40-10来分类的，结果发现这样使用后直接精度到0.98没太有优化空间了，所以改为35-15</span>classifier <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>classifier<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>prdt_y <span class="token operator">=</span> classifier<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>classification_report<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span>prdt_y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>accuracy_score<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span>prdt_y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>py一下</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Data$ py3 sdfs.py              precision    recall  f1-score   support           0       1.00      1.00      1.00        15           1       1.00      0.73      0.85        15           2       0.79      1.00      0.88        15   micro avg       0.91      0.91      0.91        45   macro avg       0.93      0.91      0.91        45weighted avg       0.93      0.91      0.91        450.9111111111111111</code></pre><p>可以看到对于Iris Setosa - Iris Versicolour - Iris Virginica三种不同的花，我们分类的精度，召回率， $F1$ ，最后显示的正确率。</p><h4 id="模型改进"><a href="#模型改进" class="headerlink" title="模型改进"></a>模型改进</h4><p>正确率只有0.9啊，太捞了。我们能不能继续优化一下来。</p><h5 id="软间隔与正则化"><a href="#软间隔与正则化" class="headerlink" title="软间隔与正则化"></a>软间隔与正则化</h5><p>women知道优化目标中的第一项用来描述超平面的间隔大小，另一项 $\sum^{m}_{i=1}\iota(f(x_i),y_i)$ 用来表示训练集上的误差，课些微更一般的形式</p><p>$$<br>\min \limits_f \Omega(f) + C \sum_{i=1}^{m} \iota(f(x_i),y_i)<br>$$</p><p>线性判别中， $C$ 这个正则化常数，用于对经验风险和结构风险进行折中，而我们的<code>LogisticRegression()</code>方法中也可以设置这个参数。我们长将正则化的程度降低，看看会有什么不一样的结果。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> classifier <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1e3</span><span class="token punctuation">)</span></code></pre><p>再次py一下我们可以发现正确率果然提高了一些</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Dat$ py3 sdfs.py              precision    recall  f1-score   support           0       1.00      1.00      1.00        15           1       0.83      1.00      0.91        15           2       1.00      0.80      0.89        15   micro avg       0.93      0.93      0.93        45   macro avg       0.94      0.93      0.93        45weighted avg       0.94      0.93      0.93        450.9333333333333333</code></pre><h5 id="solver参数"><a href="#solver参数" class="headerlink" title="solver参数"></a>solver参数</h5><p><code>LogisticRegression()</code>包含的参数当然不仅仅只有C，我们还可以选择其他的优化方法，这里就要用到我们的solver参数了。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> classifier <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1e3</span>，solver<span class="token operator">=</span><span class="token string">'lbfgs'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将优化器改为L-BFGS梯度下降优化</span></code></pre><p>可以自己py一下看看结果，这里就不再赘述了，但是需要注意的是，方法之间没有高低，根据第一章中的“没有免费午餐”定理，只有适合的才是最好的。下面是不同优化器:</p><pre><code>&#39;liblinear&#39;, &#39;newton-cg&#39;, &#39;lbfgs&#39;, &#39;sag&#39;, &#39;saga&#39;</code></pre><h5 id="multi-class参数"><a href="#multi-class参数" class="headerlink" title="multi_class参数"></a>multi_class参数</h5><p>这个参数的默认值为’ovr’,也就是将一个类的样例当作正例，其它类作为反例，来训练多个二分类器，和我们的思路是一样的；’multinomial’表示最小化多项式损失满足整个概率分布，也就是Softmax分类器。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> classifier <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1e3</span>，solver<span class="token operator">=</span><span class="token string">'sags'</span><span class="token punctuation">,</span>multi_class<span class="token operator">=</span><span class="token string">'multinomial'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#优化器改为随机平均梯度下降，multi改为Softmax</span></code></pre><p>这样处理之后，我们的精度达到了0.98，这样就十分可以了，继续处理有可能会出现过拟合的情况。</p><h5 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h5><p><img src="https://s2.ax1x.com/2019/05/20/Ex4m1H.png" alt="Ex4m1H.png"><br>观察一下混淆矩阵，我们的模型只在一个测试上分类错误！</p><h3 id="复制参数"><a href="#复制参数" class="headerlink" title="复制参数"></a>复制参数</h3><p>将我们训练的模型放入一个3*4的矩阵中，通过这个矩阵我们可以得到三个二元逻辑回归模型，系数矩阵就是coef，截距就是intercept。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> pandas <span class="token keyword">import</span> Series<span class="token punctuation">,</span>DataFrame<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> metricsdata_train<span class="token operator">=</span>pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'/home/jason/Documents/ML/flower/Data/data.csv'</span><span class="token punctuation">)</span>x <span class="token operator">=</span>data_train<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"SepalLength"</span><span class="token punctuation">,</span><span class="token string">"SepalWidth"</span><span class="token punctuation">,</span><span class="token string">"PetalLength"</span><span class="token punctuation">,</span><span class="token string">"PetalWidth"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>y <span class="token operator">=</span> data_train<span class="token punctuation">[</span><span class="token string">"FClass"</span><span class="token punctuation">]</span>x_train<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span>stratify<span class="token operator">=</span>y<span class="token punctuation">)</span>classifier <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span>C<span class="token operator">=</span><span class="token number">1e3</span><span class="token punctuation">)</span>classifier<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>prdt_y <span class="token operator">=</span> classifier<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span>coef <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>classifier<span class="token punctuation">.</span>coef_<span class="token punctuation">,</span>columns<span class="token operator">=</span>data_train<span class="token punctuation">.</span>columns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>coef<span class="token punctuation">[</span><span class="token string">"intercept"</span><span class="token punctuation">]</span> <span class="token operator">=</span> classifier<span class="token punctuation">.</span>intercept_<span class="token keyword">print</span> <span class="token punctuation">(</span>coef<span class="token punctuation">.</span>round<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>py一下，</p><pre class=" language-bash"><code class="language-bash">Jason@X1:~/flower/Dat$ py3 args.py   SepalLength  SepalWidth  PetalLength  PetalWidth  intercept0         1.31        2.91        -3.99       -1.96       0.681         0.97       -0.22        -0.25       -1.77       1.612        -2.28       -2.69         4.24        3.72      -2.29</code></pre><p>也就得到了三个线性回归方程<br>$$<br>\begin{align}<br>&amp; P(FClass==0)=\sigma(1.31SL+2.91SW-3.99PL-1.96PW+0.68) \\<br>&amp; P(FClass==0)=\sigma(0.97SL-0.22SW-0.25PL-1.77PW+1.61) \\<br>&amp; P(FClass==0)=\sigma(-2.28SL-2.69SW+4.24PL+3.72PW-2.29) \\<br>\end{align}<br>$$</p><h3 id="相关论文与参考资料："><a href="#相关论文与参考资料：" class="headerlink" title="相关论文与参考资料："></a>相关论文与参考资料：</h3><ul><li><p>Fisher，RA“在分类学问题中使用多次测量”年度优生学，7，第二部分，179-188（1936）; 同样在“对数学统计的贡献”（John Wiley，NY，1950）中。<br><a href="https://science.sciencemag.org/content/sci/111/2875/local/back-matter.pdf" target="_blank" rel="noopener">网站链接</a></p></li><li><p>Duda，RO，＆Hart，PE（1973）模式分类和场景分析。（Q327.D83）John Wiley＆Sons。国际标准书号0-471-22361-1。见第218页。<br><a href="http://www.cs.utsa.edu/~bylander/cs6243/hastie94discriminant.pdf" target="_blank" rel="noopener">网站链接</a></p></li><li><p>Dasarathy，BV（1980）“邻近地区：在部分暴露环境中识别的新系统结构和分类规则”。IEEE模式分析和机器智能交易，卷。PAMI-2，No.1,67-71。<br><a href="https://ieeexplore.ieee.org/document/4766972" target="_blank" rel="noopener">网站链接</a></p></li><li><p>Gates，GW（1972）“缩减的最近邻规则”。IEEE信息理论学报，1972年5月，431-433。 <a href="https://ieeexplore.ieee.org/document/1054809" target="_blank" rel="noopener">网站链接</a></p></li><li><p><a href="http://sklearn.lzjqsdd.com/auto_examples/decomposition/plot_pca_vs_lda.html#example-decomposition-plot-pca-vs-lda-py" target="_blank" rel="noopener">scikit learn</a></p></li><li><p><a href="http://sebastianraschka.com/Articles/2014_python_lda.html" target="_blank" rel="noopener">sebastianraschka’s blog</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;h4 id=&quot;数据下载&quot;&gt;&lt;a href=&quot;#数据下载&quot; class=&quot;headerlink&quot; title=&quot;数据下载&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="机器学习" scheme="http://jinzhengxu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://jinzhengxu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性判别" scheme="http://jinzhengxu.github.io/tags/%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB/"/>
    
      <category term="支持向量机" scheme="http://jinzhengxu.github.io/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    
      <category term="主成分分析" scheme="http://jinzhengxu.github.io/tags/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux(7)-认识与学习BASH</title>
    <link href="http://jinzhengxu.github.io/2019/05/06/niao-ge-de-linux-si-fang-cai-7-ren-shi-yu-xue-xi-bash/"/>
    <id>http://jinzhengxu.github.io/2019/05/06/niao-ge-de-linux-si-fang-cai-7-ren-shi-yu-xue-xi-bash/</id>
    <published>2019-05-06T04:58:52.000Z</published>
    <updated>2020-04-24T16:00:54.100Z</updated>
    
    <content type="html"><![CDATA[<h4 id="认识-BASH-这个-Shell"><a href="#认识-BASH-这个-Shell" class="headerlink" title="认识 BASH 这个 Shell"></a>认识 BASH 这个 Shell</h4><h5 id="硬件、核心与shell"><a href="#硬件、核心与shell" class="headerlink" title="硬件、核心与shell"></a>硬件、核心与shell</h5><p><img src="https://s2.ax1x.com/2019/05/09/EgZRIg.png" alt="EgZRIg.png"></p><pre class=" language-bash"><code class="language-bash">用户：通过命令或图形界面操作系统使用者界面：shell，application，KDE，接受来自使用者的指令，与核心进行沟通核心kernel:内存管理，CPU进程管理等硬件：CPU，内存，显卡等物理硬件bash</code></pre><p>壳程序的功能只是提供用户操作系统的一个接口。也就是说,只要能够操作应用程序的接口都能够称为壳程序。所以图形接口也是属于shell的。</p><h5 id="为何要学文字接口的shell"><a href="#为何要学文字接口的shell" class="headerlink" title="为何要学文字接口的shell"></a>为何要学文字接口的shell</h5><ul><li>文字接口的shell在不同的distribution里操作基本一致。</li><li>联机时文字接口的传输速度一定比较快, 而且,较不容易出现断线或者是信息外流的问题</li></ul><h5 id="系统的合法shell与-etc-shells的区别"><a href="#系统的合法shell与-etc-shells的区别" class="headerlink" title="系统的合法shell与/etc/shells的区别"></a>系统的合法shell与/etc/shells的区别</h5><p>早期shell有各种版本，Bourne SHell (sh) 、在 Sun 里头预设的 CSHell、 商业上常用的 K SHell、, 还有 TCSH 等等。现在超女个用的是基于GNU架构下发展的Bourne Again SHell（bash）。</p><p>通过检查<code>/etc/shells</code>文件可以检查由多少个shell可用</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/shells<span class="token comment" spellcheck="true"># /etc/shells: valid login shells</span>/bin/sh<span class="token punctuation">(</span>已经被 /bin/bash 所取代<span class="token punctuation">)</span>/bin/bash<span class="token punctuation">(</span>就是 Linux 预设的 shell<span class="token punctuation">)</span>/bin/rbash/bin/dash/usr/bin/tmux<span class="token punctuation">(</span>我自己安装的课分栏的shell<span class="token punctuation">)</span></code></pre><p>各家 shell 的功能都差不多,但是在某些语法的下达方面则有所不同， <strong><em>系统上合法的 shell 要写入 /etc/shells 这个文件</em></strong> ,系统某些服务在运作过程中,会去检查使用者能够使用的 shells ,而这些 shell 的查询就是藉由<code>/etc/shells</code> 这个文件。</p><p>使用者什么时候可以取得 shell 来工作？使用者预设会取得哪一个 shell ？登入的时候,系统就会分配一个 shell 让使用者来工作了。 而这个登入取得的 shell 就记录在<code>/etc/passwd</code> 这个文件内。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologin<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre><p>每一行的最后一个数据,就是使用者登入后可以取得的预设的 shell,root是 <code>/bin/bash</code> ,不过,系统账号 bin 与 daemon 等等,就使用 <code>/sbin/nologin</code>,某些 FTP 网站会去检查使用者的可用 shell ,而如果你不想要让这些用户使用 FTP 以外的主机资源时,可能会给予该使用者 <code>/sbin/nologin</code>,让使用者无法以其他服务登入主机。</p><h5 id="Bash-shell的功能"><a href="#Bash-shell的功能" class="headerlink" title="Bash shell的功能"></a>Bash shell的功能</h5><p>bash 主要的优点有底下几个:</p><pre><code>命令编修能力 history命令与文件补全功能　[Tab]命令别名设定功能 alias工作控制，前景背景控制　job control, foreground, background程序化脚本　shell script通配符　wildcard</code></pre><h6 id="命令编修能力-history"><a href="#命令编修能力-history" class="headerlink" title="命令编修能力 history"></a>命令编修能力 history</h6><p> bash能记忆使用过的指令,记录在家目录内的 ｀.bash_history｀文件内， 不过,需要留意的是,｀~/.bash_history｀ 记录的是前一次登入以前所执行过的指令, 而至于这一次登入所执行的指令都被暂存在内存中,注销系统后,该指令记忆才会记录到 ｀.bash_history｀ 当中。</p><ul><li>命令与文件补全功能　[Tab]<br>1)少打很多字; 2)确定输入的数据是正确的</li><li>命令别名设定功能 alias<br>在指令列输入 alias 就可以知道目前的命令别名，也可以直接下达命令来设定别名:</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">alias</span> lm<span class="token operator">=</span><span class="token string">'ls -al'</span></code></pre><ul><li>工作控制，前台后台控制　job control, foreground, background<br>工作控制(jobs)的用途更广, 可以随时将工作丢到后台中执行，而不怕不小心使用了<br>[Ctrl] + c 来停掉该程序。此外,也可以在单一登录的环境中,达到多任务的目的。</li><li>程序化脚本　shell script<br>以后在供雷讲唔</li><li>通配符　wildcard</li></ul><h5 id="查询指令是否为Bash-Shell的内建命令：type"><a href="#查询指令是否为Bash-Shell的内建命令：type" class="headerlink" title="查询指令是否为Bash Shell的内建命令：type"></a>查询指令是否为Bash Shell的内建命令：type</h5><p>利用 type 这个指令来观察指令是来自于外部指令(指的是其他非 bash 所提供的指令) 或是内建在 bash 当中的</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">type</span> <span class="token punctuation">[</span>-tpa<span class="token punctuation">]</span> name选项与参数::不加任何选项与参数时,type 会显示出 name 是外部指令还是 <span class="token function">bash</span> 内建指令-t:当加入 -t 参数时,type 会将 name 以底下这些字眼显示出他的意义:<span class="token function">file</span> :表示为外部指令<span class="token punctuation">;</span><span class="token function">alias</span> :表示该指令为命令别名所设定的名称<span class="token punctuation">;</span><span class="token function">builtin</span> :表示该指令为 <span class="token function">bash</span> 内建的指令功能<span class="token punctuation">;</span>-p :如果后面接的 name 为外部指令时,才会显示完整文件名<span class="token punctuation">;</span>-a :会由 PATH 变量定义的路径中,将所有含 name 的指令都列出来,包含 <span class="token function">alias</span></code></pre><p> type 也可以用来作为类似 which 指令的用途</p><h5 id="指令的下达与快速编辑按钮"><a href="#指令的下达与快速编辑按钮" class="headerlink" title="指令的下达与快速编辑按钮"></a>指令的下达与快速编辑按钮</h5><p>利用『 [Enter] 』来将 [Enter] 这个按键『跳脱!』开来,让 [Enter] 按键不再具有『开始执行』的功能!好让指令可以继续在下一行输入。需要特别留意, [Enter] 按键是紧接着反斜杠 () 的,两者中间没有其他字符。 因为 \ 仅跳过『紧接着的下一个字符』而已。</p><p>当所需要下达的命令特别长,或者是输入了一串错误的指令时,你快速的将这串指令<br>整个删除掉,可以使用其他的快速组合键。<br>常见的有底下这些:</p><table><thead><tr><th>组合键</th><th>功能与示范</th></tr></thead><tbody><tr><td>[ctrl]+u/[ctrl]+k</td><td>分别是从光标处向前删除指令串 ([ctrl]+u) 及向后删除指令串 ([ctrl]+k)。</td></tr><tr><td>[ctrl]+a/[ctrl]+e</td><td>分别是让光标移动到整个指令串的最前面 ([ctrl]+a) 或最后面 ([ctrl]+e)。</td></tr></tbody></table><p>在终端机 (tty) 上面登入后, Linux 就会依据 ``/etc/passwd` 文件的设定给我们一个 shell (预设是 bash),然后我们就可以依据上面的指令下达方式来操作 shell。</p><h4 id="shell的变量功能"><a href="#shell的变量功能" class="headerlink" title="shell的变量功能"></a>shell的变量功能</h4><ul><li><p>变量的可变性与方便性</p><p><a href="https://imgchr.com/i/EglPc4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/09/EglPc4.md.png" alt="EglPc4.md.png"></a><br>系统已经帮我们规划好 MAIL 这个变量,所以用户只要知道 mail 这个指令如何<br>使用即可, mail 会主动的取用 MAIL 这个变量,就能够如上图所示的取得自己的邮件信箱(注<br>意大小写,小写的 mail 是指令, 大写的 MAIL 则是变量名称。</p></li><li><p>影响 bash 环境操作的变量</p></li></ul><p><strong><em>在 Linux System 下面,所有的线程都是需要一个执行码</em></strong>, 而就如同上<br>面提到的,你『真正以 shell 来跟 Linux 沟通,是在正确的登入 Linux 之后!』这个时候你就有一<br>个 bash 的执行程序,也才可以真正的经由 bash 来跟系统沟通。而在进入 shell 之前,也正如同上面提到的,由于系统需要一些变量来提供他数据的存取 (或者是一些环境的设定参数值, 例如是<br>否要显示彩色等等的) ,所以就有一些所谓的『环境变量』 需要来读入系统中，这些环境变量例<br>如 PATH、HOME、MAIL、SHELL 等等,都是很重要的, 为了区别与自定义变量的不同,环境变<br>量通常以大写字符来表示。</p><ul><li><p>脚本程序设计 (shell script) 的好帮手</p><h5 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h5><p>变量就是以一组文字或符号等,来取代一些设定或者是一串保留的数据</p><h5 id="变量的取用与设定：echo，变量设置规则，unset"><a href="#变量的取用与设定：echo，变量设置规则，unset" class="headerlink" title="变量的取用与设定：echo，变量设置规则，unset"></a>变量的取用与设定：echo，变量设置规则，unset</h5><p>变量在被取用时,前面必须要加上『 $ 』才行</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$variable</span>$ <span class="token keyword">echo</span> <span class="token variable">$PATH</span>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin$ <span class="token keyword">echo</span> <span class="token variable">${PATH}</span>$ <span class="token keyword">echo</span> <span class="token variable">${HOME}</span> <span class="token comment" spellcheck="true">#显示出您的环境变量 HOME</span>$ <span class="token keyword">echo</span> <span class="token variable">${MAIL}</span> <span class="token comment" spellcheck="true">#显示出您的环境变量 MAIL</span>$ <span class="token keyword">echo</span> <span class="token variable">${myname}</span>     <span class="token comment" spellcheck="true">#没有任何数据～因为这个变量尚未被设定</span>     <span class="token comment" spellcheck="true">#每一种 shell 的语法都不相同~在变量的使用上,bash 在你没有设定的变量中强迫去</span>     <span class="token comment" spellcheck="true">#echo 时,它会显示出空的值。 在其他某些 shell 中,随便去 echo 一个不存在的变</span>     <span class="token comment" spellcheck="true">#量,它是会出现错误讯息</span>$ myname<span class="token operator">=</span>Jason$ <span class="token keyword">echo</span> <span class="token variable">${myname}</span>Jason　<span class="token comment" spellcheck="true">#变量设置完成</span></code></pre><p>变量的设定规则：</p></li><li><p>变量与变量内容以一个等号『=』来连结</p></li><li><p>等号两边不能直接接空格符</p></li><li><p>变量名称只能是英文字母与数字,但是开头字符不能是数字</p></li><li><p>变量内容若有空格符可使用双引号『”』或单引号『’』将变量内容结合起来</p><ul><li>双引号内的特殊字符如 $ 等,可以保有原本的特性</li><li>单引号内的特殊字符则仅为一般字符 (纯文本)</li></ul></li><li><p>可用『 \ 』将特殊符号(如 [Enter], $, , 空格符, ‘等)变成一般字符</p></li><li><p>在一串指令的执行中,还需要藉由其他额外的指令所提供的信息时,可以使用反单引号『<code>命令</code>』或 『$(命令)』</p></li><li><p>若该变量为扩增变量内容时,则可用 “$变量名称” 或 ${变量} 累加内容</p></li><li><p>若该变量需要在其他子程序执行,则需要以 export 来使变量变成环境变量:『export PATH』</p></li><li><p>通常大写字符为系统默认变量,自行设定变量可以使用小写字符,方便判断</p></li><li><p>取消变量的方法为使用 unset :『unset 变量名称』</p><pre class=" language-bash"><code class="language-bash">$ name<span class="token operator">=</span>Jason$ <span class="token keyword">echo</span> <span class="token variable">${name}</span>Jason$ <span class="token function">bash</span>  <span class="token comment" spellcheck="true">#进入到子程序</span>$ <span class="token keyword">echo</span> <span class="token variable">${name}</span>        <span class="token comment" spellcheck="true">#并没有刚刚设定的内容</span>$ <span class="token keyword">exit</span>  <span class="token comment" spellcheck="true">#子程序:离开这个子程序</span>$ <span class="token function">export</span> name$ <span class="token function">bash</span>$ <span class="token keyword">echo</span> <span class="token variable">${name}</span>Jason<span class="token comment" spellcheck="true">#在一般的状态下,父程序的自定义变量是无法在子程序内使用的。但是透过export将变量变成环境变量后,就能够在子程序底下应用了</span>$ <span class="token function">cd</span> /lib/modules/<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -r<span class="token variable">`</span></span>/kernel<span class="token comment" spellcheck="true"># 进入到目前核心的模块目录</span>$ <span class="token function">ls</span> -ld <span class="token variable"><span class="token variable">$(</span><span class="token function">locate</span> <span class="token function">crontab</span><span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 先以 locate 将文件名数据都列出来,再以 ls 指令来处理的意思</span>$ work<span class="token operator">=</span><span class="token string">"/cluster/server/work/taiwan_2015/003/"</span>$ <span class="token function">cd</span> <span class="token variable">$work</span><span class="token comment" spellcheck="true"># 使用其他目录作为我的模式工作目录时,只要变更 work 这个变数</span></code></pre></li></ul><h5 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h5><h6 id="用-env-观察环境变量与常见环境变量说明"><a href="#用-env-观察环境变量与常见环境变量说明" class="headerlink" title="用 env 观察环境变量与常见环境变量说明"></a>用 env 观察环境变量与常见环境变量说明</h6><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出目前的 shell 环境下的所有环境变量与其内容</span>$ <span class="token function">env</span>HOSTNAME<span class="token operator">=</span>study.centos.vbird <span class="token comment" spellcheck="true"># 这部主机的主机名</span>TERM<span class="token operator">=</span>xterm <span class="token comment" spellcheck="true"># 这个终端机使用的环境是什么类型</span>SHELL<span class="token operator">=</span>/bin/bash <span class="token comment" spellcheck="true"># 目前这个环境下,使用的 Shell 是哪一个程序?</span>HISTSIZE<span class="token operator">=</span>1000 <span class="token comment" spellcheck="true"># 『记录指令的笔数』在 CentOS 默认可记录 1000 笔</span>OLDPWD<span class="token operator">=</span>/home/dmtsai <span class="token comment" spellcheck="true"># 上一个工作目录的所在</span>LC_ALL<span class="token operator">=</span>en_US.utf8 <span class="token comment" spellcheck="true"># 由于语系的关系,鸟哥偷偷丢上来的一个设定</span>USER<span class="token operator">=</span>dmtsai <span class="token comment" spellcheck="true"># 使用者的名称啊!</span>LS_COLORS<span class="token operator">=</span>rs<span class="token operator">=</span>0:di<span class="token operator">=</span>01<span class="token punctuation">;</span>34:ln<span class="token operator">=</span>01<span class="token punctuation">;</span>36:mh<span class="token operator">=</span>00:pi<span class="token operator">=</span>40<span class="token punctuation">;</span>33:so<span class="token operator">=</span>01<span class="token punctuation">;</span>35:do<span class="token operator">=</span>01<span class="token punctuation">;</span>35:bd<span class="token operator">=</span>40<span class="token punctuation">;</span>33<span class="token punctuation">;</span>01:cd<span class="token operator">=</span>40<span class="token punctuation">;</span>33<span class="token punctuation">;</span>01:or<span class="token operator">=</span>40<span class="token punctuation">;</span>31<span class="token punctuation">;</span>01:mi<span class="token operator">=</span>01<span class="token punctuation">;</span>05<span class="token punctuation">;</span>37<span class="token punctuation">;</span>41:su<span class="token operator">=</span>37<span class="token punctuation">;</span>41:sg<span class="token operator">=</span>30<span class="token punctuation">;</span>43:ca<span class="token operator">=</span>30<span class="token punctuation">;</span>41:tw<span class="token operator">=</span>30<span class="token punctuation">;</span>42:ow<span class="token operator">=</span>34<span class="token punctuation">;</span>42:st<span class="token operator">=</span>37<span class="token punctuation">;</span>44:ex<span class="token operator">=</span>01<span class="token punctuation">;</span>32:*.tar<span class="token operator">=</span>01<span class="token punctuation">..</span>. <span class="token comment" spellcheck="true"># 一些颜色显示</span>MAIL<span class="token operator">=</span>/var/spool/mail/dmtsai <span class="token comment" spellcheck="true"># 这个用户所取用的 mailbox 位置</span>PATH<span class="token operator">=</span>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/binPWD<span class="token operator">=</span>/home/dmtsai <span class="token comment" spellcheck="true"># 目前用户所在的工作目录 (利用 pwd 取出!)</span>LANG<span class="token operator">=</span>zh_TW.UTF-8 <span class="token comment" spellcheck="true"># 这个与语系有关,底下会再介绍!</span>HOME<span class="token operator">=</span>/home/dmtsai <span class="token comment" spellcheck="true"># 这个用户的家目录啊!</span>LOGNAME<span class="token operator">=</span>dmtsai <span class="token comment" spellcheck="true"># 登入者用来登入的账号名称</span>_<span class="token operator">=</span>/usr/bin/env <span class="token comment" spellcheck="true"># 上一次使用的指令的最后一个参数(或指令本身)</span></code></pre><ul><li>HOME：代表用户的家目录。</li><li>SHELL：目前这个环境使用的 SHELL 是哪个程序</li><li>HISTSIZE： 历史记录的『笔数』</li><li>MAIL：使用 mail 这个指令在收信时,系统会去读取的邮件信箱文件 (mailbox)</li><li>PATH:执行文件搜寻的路径</li><li>LANG:语系数据</li><li>RANDOM:可以透过这个随机数文件相关的变量 ($RANDOM) 来随机取得随机数值喔。<br>在 BASH 的环境下,这个 RANDOM 变量的内容,介于 0~32767 之间.<pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">declare</span> -i number<span class="token operator">=</span><span class="token variable">$RANDOM*10</span>/32678<span class="token punctuation">;</span>\<span class="token operator">></span> <span class="token keyword">echo</span> <span class="token variable">${number}</span>2</code></pre><h6 id="用-set-观察所有变量-含环境变量与自定义变量"><a href="#用-set-观察所有变量-含环境变量与自定义变量" class="headerlink" title="用 set 观察所有变量 (含环境变量与自定义变量)"></a>用 set 观察所有变量 (含环境变量与自定义变量)</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">set</span>BASH<span class="token operator">=</span>/bin/bash <span class="token comment" spellcheck="true"># bash 的主程序放置路径</span>BASH_VERSINFO<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"4"</span> <span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"2"</span> <span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"46"</span> <span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"1"</span> <span class="token punctuation">[</span>4<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"release"</span> <span class="token punctuation">[</span>5<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"x86_64-redhat-linux-gnu"</span><span class="token punctuation">)</span>BASH_VERSION<span class="token operator">=</span><span class="token string">'4.2.46(1)-release'</span> <span class="token comment" spellcheck="true"># 这两行是 bash 的版本啊!</span>COLUMNS<span class="token operator">=</span>90 <span class="token comment" spellcheck="true"># 在目前的终端机环境下,使用的字段有几个字符长度</span>HISTFILE<span class="token operator">=</span>/home/dmtsai/.bash_history <span class="token comment" spellcheck="true"># 历史命令记录的放置文件,隐藏档</span>HISTFILESIZE<span class="token operator">=</span>1000 <span class="token comment" spellcheck="true"># 存起来(与上个变量有关)的文件之指令的最大纪录笔数。</span>HISTSIZE<span class="token operator">=</span>1000 <span class="token comment" spellcheck="true"># 目前环境下,内存中记录的历史命令最大笔数。</span>IFS<span class="token operator">=</span>$<span class="token string">' \t\n'</span> <span class="token comment" spellcheck="true"># 预设的分隔符</span>LINES<span class="token operator">=</span>20 <span class="token comment" spellcheck="true"># 目前的终端机下的最大行数</span>MACHTYPE<span class="token operator">=</span>x86_64-redhat-linux-gnu <span class="token comment" spellcheck="true"># 安装的机器类型</span>OSTYPE<span class="token operator">=</span>linux-gnu <span class="token comment" spellcheck="true"># 操作系统的类型!</span>PS1<span class="token operator">=</span><span class="token string">'[\u@\h \W]\$ '</span> <span class="token comment" spellcheck="true"># PS1 就厉害了。这个是命令提示字符,也就是我们常见的[root@www ~] 或 [dmtsai ~]$ 的设定值啦!可以更动的!</span>PS2<span class="token operator">=</span><span class="token string">'> '</span> <span class="token comment" spellcheck="true"># 如果你使用跳脱符号 (\) 第二行以后的提示字符也</span>$ <span class="token comment" spellcheck="true"># 目前这个 shell 所使用的 PID</span>? <span class="token comment" spellcheck="true"># 刚刚执行完指令的回传值。</span></code></pre></li></ul><p><strong><em>基本上,在 Linux 预设的情况中,使用{大写的字母}来设定的变量<br>一般为系统内定需要的变量</em></strong></p><p>比较重要的几个变量：</p><h6 id="PS1-提示字符的设定"><a href="#PS1-提示字符的设定" class="headerlink" title="PS1:(提示字符的设定)"></a>PS1:(提示字符的设定)</h6><p>PS1 就是命令提示字符,每次按下 [Enter] 按键去执行某个指令后,最后要再次出现提示字符时, 就会主动去读取这个变数值了。每个 distributions 的bash 默认的 PS1 变量内容可能有些许的差异.</p><pre class=" language-bash"><code class="language-bash"> \d :可显示出『星期 月 日』的日期格式,如:<span class="token string">"Mon Feb 2"</span> \H :完整的主机名。举例来说,鸟哥的练习机为『study.centos.vbird』 \h :仅取主机名在第一个小数点之前的名字,如鸟哥主机则为『study』后面省略 \t :显示时间,为 24 小时格式的『HH:MM:SS』 \T :显示时间,为 12 小时格式的『HH:MM:SS』 \A :显示时间,为 24 小时格式的『HH:MM』 \@ :显示时间,为 12 小时格式的『am/pm』样式 \u :目前使用者的账号名称,如『dmtsai』 \v :BASH 的版本信息,如鸟哥的测试主机版本为 4.2.46<span class="token punctuation">(</span>1<span class="token punctuation">)</span>-release,仅取『4.2』显示 \w :完整的工作目录名称,由根目录写起的目录名称。但家目录会以 ~ 取代<span class="token punctuation">;</span> \W :利用 <span class="token function">basename</span> 函数取得工作目录名称,所以仅会列出最后一个目录名。 \# :下达的第几个指令。 \$ :提示字符,如果是 root 时,提示字符为 <span class="token comment" spellcheck="true"># ,否则就是 $ 啰~</span></code></pre><h6 id="关于本-shell-的-PID"><a href="#关于本-shell-的-PID" class="headerlink" title="$:(关于本 shell 的 PID)"></a>$:(关于本 shell 的 PID)</h6><p>代表的是『目前这个 Shell 的线程代号』,亦即是所谓的 PID(Process ID)。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> $$ <span class="token comment" spellcheck="true">#shell 的 PID</span></code></pre><h6 id="关于上个执行指令的回传值"><a href="#关于上个执行指令的回传值" class="headerlink" title="?:(关于上个执行指令的回传值)"></a>?:(关于上个执行指令的回传值)</h6><p>? 代表『上一个执行的指令所回传的值』,当我们执行某些指令时, 这些指令都会回传一个执行后的代码。一般来说,如果成功的执行该指令,则会回传一个 0 值，如果执行过程发生错误,就会回传『错误代码』</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token variable">$SHELL</span>/bin/bash  <span class="token comment" spellcheck="true">#Linux 预设使用 /bin/bash</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0          <span class="token comment" spellcheck="true">#因为没问题,所以回传值为 0</span>$ 12name<span class="token operator">=</span>Jaosn12name<span class="token operator">=</span>Jaosn: <span class="token function">command</span> not found <span class="token comment" spellcheck="true">#发生错误，bash 回报有问题</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>127 <span class="token comment" spellcheck="true">#错误代码回传值依据软件而有不同,可以利用这个代码来搜寻错误的原因</span>$ <span class="token keyword">echo</span> <span class="token variable">$?</span>0</code></pre><ul><li>OSTYPE, HOSTTYPE, MACHTYPE:(主机硬件与核心的等级)</li></ul><h6 id="export-自定义变量转成环境变量"><a href="#export-自定义变量转成环境变量" class="headerlink" title="export: 自定义变量转成环境变量"></a>export: 自定义变量转成环境变量</h6><p><strong><em>子程序仅会继承父程序的环境变量, 子程序不会继承父程序的自定义变量</em></strong>。<br>想要让该变量内容继续的在子程序中使用,那么就请执行:</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">export</span> 变量名称<span class="token comment" spellcheck="true"># 分享自己的变量设定给后来呼叫的文件或其他程序</span></code></pre><h5 id="影响显示结果的语系变量（locale）"><a href="#影响显示结果的语系变量（locale）" class="headerlink" title="影响显示结果的语系变量（locale）"></a>影响显示结果的语系变量（locale）</h5><pre class=" language-bash"><code class="language-bash">$ locale -a <span class="token comment" spellcheck="true">#当前系统支持了多少的语系</span>$ localeLANG<span class="token operator">=</span>en_US.UTF-8   <span class="token comment" spellcheck="true">#主语言的环境</span>LANGUAGE<span class="token operator">=</span>LC_CTYPE<span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span> <span class="token comment" spellcheck="true">#字符(文字)辨识的编码</span>LC_NUMERIC<span class="token operator">=</span>zh_CN.UTF-8 <span class="token comment" spellcheck="true">#数字系统的显示讯息</span>LC_TIME<span class="token operator">=</span>zh_CN.UTF-8 <span class="token comment" spellcheck="true">#时间系统的显示数据</span>LC_COLLATE<span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span> <span class="token comment" spellcheck="true">#字符串的比较与排序等</span>LC_MONETARY<span class="token operator">=</span>zh_CN.UTF-8 <span class="token comment" spellcheck="true">#币值格式的显示等</span>LC_MESSAGES<span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span> <span class="token comment" spellcheck="true">#讯息显示的内容,如菜单、错误讯息等</span>LC_PAPER<span class="token operator">=</span>zh_CN.UTF-8LC_NAME<span class="token operator">=</span>zh_CN.UTF-8LC_ADDRESS<span class="token operator">=</span>zh_CN.UTF-8LC_TELEPHONE<span class="token operator">=</span>zh_CN.UTF-8LC_MEASUREMENT<span class="token operator">=</span>zh_CN.UTF-8LC_IDENTIFICATION<span class="token operator">=</span>zh_CN.UTF-8LC_ALL<span class="token operator">=</span> <span class="token comment" spellcheck="true">#整体语系的环境</span></code></pre><p><strong><em>如果其他的语系变量都未设定, 且你有设定 LANG 或者是 LC_ALL 时,则其他的语系变量就会被这两个变量所取代</em></strong></p><h5 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="变量的有效范围"></a>变量的有效范围</h5><ul><li>环境变量=全局变量</li><li>自定义变数=局部变量<br>```bash</li></ul><p>1.当启动一个 shell,操作系统会分配一记忆区块给 shell 使用,此内存内之变量可让子程序取用<br>2.若在父程序利用 export 功能,可以让自定义变量的内容写到上述的记忆区块当中(环境变量);<br>3.当加载另一个 shell 时 (亦即启动子程序,而离开原本的父程序了),子 shell 可以将父<br>  shell 的环境变量所在的记忆区块导入自己的环境变量区块当中。</p><pre><code>这里需要注意的是 ***『环境变量』与『bash 的操作环境』*** 意思不太一样,举例来说, PS1 并不是环境变量。##### 变量键盘读取、数组与宣告read，array，declare+ read  ```bash  $ read [-pt] variable  选项与参数:  -p :后面接提示字符  -t :后面接等待的『秒数』  $ read atest  This is a test  # 此时光标会等待输入  $ echo ${atest}  This is a test # 刚刚输入的数据已经变成一个变量内容  $ read -p &quot;Please keyin your name: &quot; -t 30 named  Please keyin your name: Jason # 提示字符  $ echo ${named}  Jason #输入的数据又变成一个变量的内容了!</code></pre><ul><li><p>array</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">declare</span> -a var$ var<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"sdf"</span>$ var<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"sdfsd"</span>$ <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${var[1]}</span>,<span class="token variable">${var[2]}</span>"</span>sdf,sdfsd+ declare/typeset<span class="token keyword">declare</span> 或 typeset 是一样的功能,就是在『宣告变量的类型』。​```bash$ <span class="token keyword">declare</span> <span class="token punctuation">[</span>-aixr<span class="token punctuation">]</span> variable选项与参数:-a :将后面名为 variable 的变量定义成为数组 <span class="token punctuation">(</span>array<span class="token punctuation">)</span> 类型-i :将后面名为 variable 的变量定义成为整数数字 <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 类型-x :用法与 <span class="token function">export</span> 一样,就是将后面的 variable 变成环境变量<span class="token punctuation">;</span>-r :将变量设定成为 <span class="token function">readonly</span> 类型,该变量不可被更改内容,也不能 unset$ sum<span class="token operator">=</span>100+300+50$ <span class="token keyword">echo</span> <span class="token variable">${sum}</span>100+300+50 <span class="token comment" spellcheck="true">#没有计算加总，因为这是文字型态的变量属性</span>$ <span class="token keyword">declare</span> -i sum<span class="token operator">=</span>100+300+50$ <span class="token keyword">echo</span> <span class="token variable">${sum}</span>450$ <span class="token keyword">declare</span> -x <span class="token function">sum</span>$ <span class="token function">export</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">sum</span><span class="token keyword">declare</span> -ix sum<span class="token operator">=</span><span class="token string">"450"</span> <span class="token comment" spellcheck="true">#将 sum 变成环境变量</span>$ <span class="token keyword">declare</span> -r <span class="token function">sum</span>$ sum<span class="token operator">=</span>tesgting-bash: sum: <span class="token function">readonly</span> variable <span class="token comment" spellcheck="true">#sum 变成只读属性,不可更动</span>$ <span class="token keyword">declare</span> +x <span class="token function">sum</span> <span class="token comment" spellcheck="true"># 将 - 变成 + 可以进行『取消』动作</span>$ <span class="token keyword">declare</span> -p <span class="token function">sum</span> <span class="token comment" spellcheck="true">#-p 可以单独列出变量的类型</span><span class="token keyword">declare</span> -ir sum<span class="token operator">=</span><span class="token string">"450"</span> <span class="token comment" spellcheck="true">#只剩下 i, r 的类型,不具有 x</span></code></pre></li></ul><h5 id="与文件系统及程序的限制关系：ulimit"><a href="#与文件系统及程序的限制关系：ulimit" class="headerlink" title="与文件系统及程序的限制关系：ulimit"></a>与文件系统及程序的限制关系：ulimit</h5><p>bash 是可以『限制用户的某些系统资源』的,包括可以开启的文件数量, 可以使用的 CPU 时间,可以使用的内存总量等等。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ulimit</span> <span class="token punctuation">[</span>-SHacdfltu<span class="token punctuation">]</span> <span class="token punctuation">[</span>配额<span class="token punctuation">]</span>选项与参数:-H :hard limit ,严格的设定,必定不能超过这个设定的数值<span class="token punctuation">;</span>-S :soft limit ,警告的设定,可以超过这个设定值,但是若超过则有警告讯息。在设定上,通常 soft 会比 hard 小,举例来说,soft 可设定为 80 而 hard设定为 100,那么你可以使用到 90 <span class="token punctuation">(</span>因为没有超过 100<span class="token punctuation">)</span>,但介于 80~100 之间时,系统会有警告讯息通知你<span class="token operator">!</span>-a :后面不接任何选项与参数,可列出所有的限制额度<span class="token punctuation">;</span>-c :当某些程序发生错误时,系统可能会将该程序在内存中的信息写成文件<span class="token punctuation">(</span>除错用<span class="token punctuation">)</span>,这种文件就被称为核心文件<span class="token punctuation">(</span>core file<span class="token punctuation">)</span>。此为限制每个核心文件的最大容量。-f :此 shell 可以建立的最大文件容量<span class="token punctuation">(</span>一般可能设定为 2GB<span class="token punctuation">)</span>单位为 Kbytes-d :程序可使用的最大断裂内存<span class="token punctuation">(</span>segment<span class="token punctuation">)</span>容量<span class="token punctuation">;</span>-l :可用于锁定 <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> 的内存量-t :可使用的最大 CPU 时间 <span class="token punctuation">(</span>单位为秒<span class="token punctuation">)</span>-u :单一用户可以使用的最大进程<span class="token punctuation">(</span>process<span class="token punctuation">)</span>数量。$ <span class="token function">ulimit</span> -acore <span class="token function">file</span> size          <span class="token punctuation">(</span>blocks, -c<span class="token punctuation">)</span> 0data seg size           <span class="token punctuation">(</span>kbytes, -d<span class="token punctuation">)</span> unlimitedscheduling priority             <span class="token punctuation">(</span>-e<span class="token punctuation">)</span> 0<span class="token function">file</span> size               <span class="token punctuation">(</span>blocks, -f<span class="token punctuation">)</span> unlimitedpending signals                 <span class="token punctuation">(</span>-i<span class="token punctuation">)</span> 62599max locked memory       <span class="token punctuation">(</span>kbytes, -l<span class="token punctuation">)</span> 16384max memory size         <span class="token punctuation">(</span>kbytes, -m<span class="token punctuation">)</span> unlimited<span class="token function">open</span> files                      <span class="token punctuation">(</span>-n<span class="token punctuation">)</span> 1024pipe size            <span class="token punctuation">(</span>512 bytes, -p<span class="token punctuation">)</span> 8POSIX message queues     <span class="token punctuation">(</span>bytes, -q<span class="token punctuation">)</span> 819200real-time priority              <span class="token punctuation">(</span>-r<span class="token punctuation">)</span> 0stack size              <span class="token punctuation">(</span>kbytes, -s<span class="token punctuation">)</span> 8192cpu <span class="token function">time</span>               <span class="token punctuation">(</span>seconds, -t<span class="token punctuation">)</span> unlimitedmax user processes              <span class="token punctuation">(</span>-u<span class="token punctuation">)</span> 62599virtual memory          <span class="token punctuation">(</span>kbytes, -v<span class="token punctuation">)</span> unlimited<span class="token function">file</span> locks                      <span class="token punctuation">(</span>-x<span class="token punctuation">)</span> unlimited$ <span class="token function">ulimit</span> -f 10240 <span class="token comment" spellcheck="true">#限制用户仅能建立 10MBytes 以下的容量的文件</span></code></pre><h5 id="变量内容的删除，取代与替换Optional"><a href="#变量内容的删除，取代与替换Optional" class="headerlink" title="变量内容的删除，取代与替换Optional"></a>变量内容的删除，取代与替换Optional</h5><ul><li><p>变量内容的删除与取代</p><pre class=" language-bash"><code class="language-bash">$ path<span class="token operator">=</span><span class="token variable">${PATH}</span>$ <span class="token keyword">echo</span> <span class="token variable">${path}</span>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>path<span class="token comment" spellcheck="true">#/*local/bin:} #删除目录</span>$<span class="token punctuation">{</span>variable<span class="token comment" spellcheck="true">#/*local/bin:}</span>上面的特殊字体部分是关键词<span class="token operator">!</span>用在这种删除模式所必须存在的$<span class="token punctuation">{</span>variable<span class="token comment" spellcheck="true">#/*local/bin:}</span>这就是原本的变量名称,以上面范例二来说,这里就填写 path 这个『变量名称』啦<span class="token operator">!</span>$<span class="token punctuation">{</span>variable<span class="token comment" spellcheck="true">#/*local/bin:}</span>这是重点<span class="token operator">!</span>代表『从变量内容的最前面开始向右删除』,且仅删除最短的那个$<span class="token punctuation">{</span>variable<span class="token comment" spellcheck="true">#/*local/bin:}</span>代表要被删除的部分,由于 <span class="token comment" spellcheck="true"># 代表由前面开始删除,所以这里便由开始的 / 写起。</span>需要注意的是,我们还可以透过通配符 * 来取代 0 到无穷多个任意字符$ <span class="token keyword">echo</span> $<span class="token punctuation">{</span>path<span class="token comment" spellcheck="true">##/*:}</span>/home/dmtsai/bin<span class="token comment" spellcheck="true"># 变成 ## 之后『删除掉最长的那个数据』</span>$ <span class="token keyword">echo</span> <span class="token variable">${path%:*bin}</span>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin<span class="token comment" spellcheck="true"># 这个 % 符号代表由最后面开始向前删除!</span>$ <span class="token keyword">echo</span> <span class="token variable">${path%%:*bin}</span>/usr/local/bin<span class="token comment" spellcheck="true"># 同样的, %% 代表的则是最长的符合字符串</span>$ <span class="token keyword">echo</span> <span class="token variable">${path/sbin/SBIN}</span> <span class="token comment" spellcheck="true">#将 path 的变量内容内的 sbin 取代成大写 SBIN</span>$ <span class="token keyword">echo</span> <span class="token variable">${path//sbin/SBIN}</span> <span class="token comment" spellcheck="true">#如果是两条斜线,那么就变成所有符合的内容都会被取代喔</span></code></pre></li></ul><table><thead><tr><th>变量设定方式</th><th>说明</th></tr></thead><tbody><tr><td>${变量#关键词}</td><td>若变量内容从头开始的数据符合『关键词』,则将符合的最短数据删除</td></tr><tr><td>${变量##关键词}</td><td>若变量内容从头开始的数据符合『关键词』,则将符合的最长数据删除</td></tr><tr><td>${变量%关键词}</td><td>若变量内容从尾向前的数据符合『关键词』,则将符合的最短数据删除</td></tr><tr><td>${变量%%关键词}</td><td>若变量内容从尾向前的数据符合『关键词』,则将符合的最长数据删除</td></tr><tr><td>${变量/旧字符串/新字符串}</td><td>若变量内容符合『旧字符串』则『第一个旧字符串会被新字符串</td></tr><tr><td>${变量//旧字符串/新字符串}</td><td>若变量内容符合『旧字取代』若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串取代』</td></tr></tbody></table><ul><li>变量的测试与内容替换<pre class=" language-bash"><code class="language-bash">new_var<span class="token operator">=</span><span class="token variable">${old_var-content}</span>新的变量,主要用来取代旧变量。新旧变量名称其实常常是一样的new_var<span class="token operator">=</span><span class="token variable">${old_var-content}</span>这是本范例中的关键词部分<span class="token operator">!</span>必须要存在的哩<span class="token operator">!</span>new_var<span class="token operator">=</span><span class="token variable">${old_var-content}</span>旧的变量,被测试的项目<span class="token operator">!</span>new_var<span class="token operator">=</span><span class="token variable">${old_var-content}</span>变量的『内容』,在本范例中,这个部分是在『给予未设定变量的内容』</code></pre></li></ul><table><thead><tr><th>变量设定方式</th><th>str 没有设定</th><th>str 为空字符串</th><th>str 已设定非为空字符串</th></tr></thead><tbody><tr><td>var=${str-expr}</td><td>var=expr</td><td>var=</td><td>var=str</td></tr><tr><td>var=${str:-expr}</td><td>var=expr</td><td>var=expr</td><td>var=str</td></tr><tr><td>var=${str+expr}</td><td>var=</td><td>var=expr</td><td>var=expr</td></tr><tr><td>var=${str:+expr}</td><td>var=</td><td>var=</td><td>var=expr</td></tr><tr><td>var=${str=expr}</td><td>str=expr var=expr</td><td>str 不变 var=</td><td>str 不变 var=str</td></tr><tr><td>var=${str:=expr}</td><td>str=expr var=expr</td><td>str=expr var=expr</td><td>str 不变 var=str</td></tr><tr><td>var=${str?expr}</td><td>expr 输出至 stderr</td><td>var=</td><td>var=str</td></tr><tr><td>var=${str:?expr}</td><td>expr 输出至 stderr</td><td>expr 输出至 stderr</td><td>var=str</td></tr></tbody></table><h4 id="变量别名与历史命令"><a href="#变量别名与历史命令" class="headerlink" title="变量别名与历史命令"></a>变量别名与历史命令</h4><h5 id="命令别名设定-alias-unalias"><a href="#命令别名设定-alias-unalias" class="headerlink" title="命令别名设定: alias, unalias"></a>命令别名设定: alias, unalias</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">alias</span> lm<span class="token operator">=</span><span class="token string">'ls -al | more'</span></code></pre><p>alias 的定义规则与变量定义规则几乎相同』, 所以只要在 alias 后面加上{『别名』=’指令 选项…’ }</p><h5 id="历史命令-history"><a href="#历史命令-history" class="headerlink" title="历史命令:history"></a>历史命令:history</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">history</span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span>$ <span class="token function">history</span> <span class="token punctuation">[</span>-c<span class="token punctuation">]</span>$ <span class="token function">history</span> <span class="token punctuation">[</span>-raw<span class="token punctuation">]</span> histfiles选项与参数: n :数字,意思是『要列出最近的 n 笔命令行表』的意思<span class="token operator">!</span>-c :将目前的 shell 中的所有 <span class="token function">history</span> 内容全部消除-a :将目前新增的 <span class="token function">history</span> 指令新增入 histfiles 中,若没有加 histfiles ,则预设写入 ~/.bash_history-r :将 histfiles 的内容读到目前这个 shell 的 <span class="token function">history</span> 记忆中<span class="token punctuation">;</span>-w :将目前的 <span class="token function">history</span> 记忆内容写入 histfiles 中<span class="token operator">!</span>$ <span class="token operator">!</span>number$ <span class="token operator">!</span>command$ <span class="token operator">!</span><span class="token operator">!</span>选项与参数:number:执行第几笔指令的意思<span class="token punctuation">;</span><span class="token function">command</span> :由最近的指令向前搜寻『指令串开头为 command』的那个指令,并执行<span class="token punctuation">;</span><span class="token operator">!</span><span class="token operator">!</span> :就是执行上一个指令<span class="token punctuation">(</span>相当于按↑按键后,按 Enter<span class="token punctuation">)</span></code></pre><ul><li>同一账号同时多次登入的 history 写入问题</li></ul><p>bash 在同时以 root 的身份登入, 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到注销时才会更新记录文件,所以啰, 最后注销的那个 bash 才会是最后写入的数据。</p><h4 id="Bash-Shell-的操作环境"><a href="#Bash-Shell-的操作环境" class="headerlink" title="Bash Shell 的操作环境"></a>Bash Shell 的操作环境</h4><h5 id="路径与指令搜寻顺序"><a href="#路径与指令搜寻顺序" class="headerlink" title="路径与指令搜寻顺序"></a>路径与指令搜寻顺序</h5><p>指令运作的顺序可以这样看:</p><pre class=" language-bash"><code class="language-bash">1. 以相对/绝对路径执行指令,例如『 /bin/ls 』或『 ./ls 』<span class="token punctuation">;</span>2. 由 <span class="token function">alias</span> 找到该指令来执行<span class="token punctuation">;</span>3. 由 <span class="token function">bash</span> 内建的 <span class="token punctuation">(</span>builtin<span class="token punctuation">)</span> 指令来执行<span class="token punctuation">;</span>4. 透过 <span class="token variable">$PATH</span> 这个变量的顺序搜寻到的第一个指令来执行。</code></pre><p>/bin/ls 及单纯的 ls 看看,会发现使用 ls 有颜色但是 /bin/ls 则没有颜色。 因为 /bin/ls 是直接取用该指令来下达,而 ls 会因为『 alias ls=’ls –color=auto’ 』这个命令别名而先使用 。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">alias</span> echo<span class="token operator">=</span><span class="token string">'echo -n'</span>$ <span class="token function">type</span> -a <span class="token keyword">echo</span><span class="token keyword">echo</span> is aliased to <span class="token string">'echo -n'</span><span class="token keyword">echo</span> is a shell <span class="token function">builtin</span><span class="token keyword">echo</span> is /usr/bin/echo</code></pre><h5 id="bash-的进站与欢迎讯息-etc-issue-etc-motd"><a href="#bash-的进站与欢迎讯息-etc-issue-etc-motd" class="headerlink" title="bash 的进站与欢迎讯息: /etc/issue, /etc/motd"></a>bash 的进站与欢迎讯息: /etc/issue, /etc/motd</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/issueUbuntu 18.04.1 LTS \n \l</code></pre><table><thead><tr><th>issue 内的各代码意义</th></tr></thead><tbody><tr><td>\d 本地端时间的日期;</td></tr><tr><td>\l  显示第几个终端机接口;</td></tr><tr><td>\m  显示硬件的等级 (i386/i486/i586/i686…);</td></tr><tr><td>\n  显示主机的网络名称;</td></tr><tr><td>\O  显示 domain name;</td></tr><tr><td>\r  操作系统的版本 (相当于 uname -r)</td></tr><tr><td>\t  显示本地端时间的时间;</td></tr><tr><td>\S  操作系统的名称;</td></tr><tr><td>\v  操作系统的版本。</td></tr></tbody></table><p>当我们使用 telnet 连接到主机时,主机的登入画面就会显示 /etc/issue.net 而不是/etc/issue</p><p>要让使用者登入后取得一些讯息,例如您想要让大家都知道的讯息, 那么可以将讯息加入 /etc/motd 里面</p><h5 id="bash-的环境配置文件"><a href="#bash-的环境配置文件" class="headerlink" title="bash 的环境配置文件"></a>bash 的环境配置文件</h5><ul><li>login 与 non-login shell<ul><li>login shell:取得 bash 时需要完整的登入流程的,就称为 login shell。举例来说,你要由 tty1 ~ tty6 登入,需要输入用户的账号与密码,此时取得的 bash 就称为『 login shell 』;</li><li>non-login shell:取得 bash 接口的方法不需要重复登入的举动,举例来说,<ul><li>(1)你以 X window 登入 Linux 后,再以 X 的图形化接口启动终端机,此时那个终端接口并没有需要再次的输入账号与密码,那个 bash 的环境就称为 non-login shell 了。</li><li>(2)你在原本的 bash 环境下再次下达 bash 这个指令,同样的也没有输入账号密码, 那第二个 bash (子程序) 也是 non-login shell 。</li></ul></li></ul></li></ul><p>login shell 其实只会读取这两个配置文件:</p><pre class=" language-bash"><code class="language-bash">1. /etc/profile:这是系统整体的设定,你最好不要修改这个文件<span class="token punctuation">;</span>2. ~/.bash_profile 或 ~/.bash_login 或 ~/.profile:属于使用者个人设定,你要改自的数据,就写入这里<span class="token operator">!</span></code></pre><h6 id="etc-profile-login-shell-才会读"><a href="#etc-profile-login-shell-才会读" class="headerlink" title="/etc/profile (login shell 才会读)"></a>/etc/profile (login shell 才会读)</h6><p><strong><em>每个使用者登入取得 bash 时一定会读取的配置文件</em></strong></p><pre class=" language-bash"><code class="language-bash">PATH:会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录<span class="token punctuation">;</span>MAIL:依据账号设定好使用者的 mailbox 到 /var/spool/mail/账号名<span class="token punctuation">;</span>USER:根据用户的账号设定此一变量内容<span class="token punctuation">;</span>HOSTNAME:依据主机的 <span class="token function">hostname</span> 指令决定此一变量内容<span class="token punctuation">;</span>HISTSIZE:历史命令记录笔数。CentOS 7.x 设定为 1000 <span class="token punctuation">;</span>umask:包括 root 默认为 022 而一般用户为 002 等<span class="token operator">!</span></code></pre><p>/etc/profile 可不止会做这些事而已,他还会去呼叫外部的设定数据：</p><pre class=" language-bash"><code class="language-bash">/etc/profile.d/*sh:只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ,另外,使用者                   能够具有 r 的权限, 那么该文件就会被 /etc/profile 呼叫进来。在 CentOS 7.x 中,这个目录底                   下的文件规范了 <span class="token function">bash</span> 操作接口的颜色、 语系、ll 与 <span class="token function">ls</span> 指令的命令别名、vi 的命令别名、which                   的命令别名等等/etc/locale.conf:由 /etc/profile.d/lang.sh 呼叫进来的<span class="token operator">!</span>这也是我们决定 <span class="token function">bash</span> 预设使用何种语系的重要配置文件<span class="token operator">!</span>/usr/share/bash-completion/completions/*:命令补齐、档名补齐之外,还可以进行指令的选项/参数                                         补齐功能<span class="token operator">!</span>那就是从这个目录里面找到相对应的指令来处理的<span class="token comment" spellcheck="true"># bash 的 login shell 情况下所读取的整体环境配置文件其实只有 /etc/profile</span></code></pre><h6 id="bash-profile-login-shell-才会读"><a href="#bash-profile-login-shell-才会读" class="headerlink" title="~/.bash_profile (login shell 才会读)"></a>~/.bash_profile (login shell 才会读)</h6><p>login shell 的 bash 环境中,所读取的个人偏好配置文件其实主要有三个,依序分别是:</p><pre class=" language-bash"><code class="language-bash">1. ~/.bash_profile2. ~/.bash_login3. ~/.profile</code></pre><p><strong><em>bash 的 login shell 设定只会读取上面三个文件的其中一个, 而读取的顺序则是依照上面的顺序。</em></strong></p><h6 id="source-读入环境配置文件的指令"><a href="#source-读入环境配置文件的指令" class="headerlink" title="source :读入环境配置文件的指令"></a>source :读入环境配置文件的指令</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">source</span> 配置文件档名范例:将家目录的 ~/.bashrc 的设定读入目前的 <span class="token function">bash</span> 环境中$ <span class="token function">source</span> ~/.bashrc$. ~/.bashrc</code></pre><ul><li>~/.bashrc (non-login shell 会读)</li></ul><p>取得 non-login shell 时,该 bash 配置文件仅会读取 ~/.bashrc</p><h6 id="其他相关配置文件"><a href="#其他相关配置文件" class="headerlink" title="其他相关配置文件"></a>其他相关配置文件</h6><pre class=" language-bash"><code class="language-bash">/etc/man_db.conf：规范了使用 <span class="token function">man</span> 的时候, <span class="token function">man</span> page 的路径到哪里去寻找<span class="token operator">!</span>~/.bash_history~/.bash_logout：当我注销 <span class="token function">bash</span> 后,系统再帮我做完什么动作后才离开</code></pre><p><a href="https://imgchr.com/i/EoltnP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/14/EoltnP.md.png" alt="EoltnP.md.png"></a></p><h5 id="终端机的环境设定-stty-set"><a href="#终端机的环境设定-stty-set" class="headerlink" title="终端机的环境设定: stty, set"></a>终端机的环境设定: stty, set</h5><p>查阅目前的一些按键内容</p><pre class=" language-bash"><code class="language-bash">$ stty <span class="token punctuation">[</span>-a<span class="token punctuation">]</span>选项与参数:-a :将目前所有的 stty 参数列出来<span class="token punctuation">;</span>stty -aspeed 38400 baud<span class="token punctuation">;</span> rows 24<span class="token punctuation">;</span> columns 80<span class="token punctuation">;</span> line <span class="token operator">=</span> 0<span class="token punctuation">;</span>intr <span class="token operator">=</span> ^C<span class="token punctuation">;</span> quit <span class="token operator">=</span> ^\<span class="token punctuation">;</span> erase <span class="token operator">=</span> ^?<span class="token punctuation">;</span> <span class="token function">kill</span> <span class="token operator">=</span> ^U<span class="token punctuation">;</span> eof <span class="token operator">=</span> ^D<span class="token punctuation">;</span> eol <span class="token operator">=</span> <span class="token operator">&lt;</span>undef<span class="token operator">></span><span class="token punctuation">;</span>eol2 <span class="token operator">=</span> <span class="token operator">&lt;</span>undef<span class="token operator">></span><span class="token punctuation">;</span> swtch <span class="token operator">=</span> <span class="token operator">&lt;</span>undef<span class="token operator">></span><span class="token punctuation">;</span> start <span class="token operator">=</span> ^Q<span class="token punctuation">;</span> stop <span class="token operator">=</span> ^S<span class="token punctuation">;</span> susp <span class="token operator">=</span> ^Z<span class="token punctuation">;</span> rprnt <span class="token operator">=</span> ^R<span class="token punctuation">;</span>werase <span class="token operator">=</span> ^W<span class="token punctuation">;</span> lnext <span class="token operator">=</span> ^V<span class="token punctuation">;</span> discard <span class="token operator">=</span> ^O<span class="token punctuation">;</span> min <span class="token operator">=</span> 1<span class="token punctuation">;</span> <span class="token function">time</span> <span class="token operator">=</span> 0<span class="token punctuation">;</span>-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff-iuclc -ixany -imaxbel iutf8opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0isig icanon iexten <span class="token keyword">echo</span> echoe echok -echonl -noflsh -xcase -tostop -echoprtechoctl echoke -flusho -extproc$ stty erase ^h <span class="token comment" spellcheck="true">#用 [ctrl]+h 来进行字符的删除</span>intr <span class="token keyword">:</span> 送出一个 interrupt <span class="token punctuation">(</span>中断<span class="token punctuation">)</span> 的讯号给目前正在 run 的程序 <span class="token punctuation">(</span>就是终止啰<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>quit <span class="token keyword">:</span> 送出一个 quit 的讯号给目前正在 run 的程序<span class="token punctuation">;</span>erase <span class="token keyword">:</span> 向后删除字符,<span class="token function">kill</span> <span class="token keyword">:</span> 删除在目前指令列上的所有文字<span class="token punctuation">;</span>eof: End of <span class="token function">file</span> 的意思,代表『结束输入』start <span class="token keyword">:</span> 在某个程序停止后,重新启动他的 outputstop <span class="token keyword">:</span> 停止目前屏幕的输出<span class="token punctuation">;</span>susp <span class="token keyword">:</span> 送出一个 terminal stop 的讯号给正在 run 的程序。</code></pre><p>set以设定整个指令输出/输入的环境。 例如记录历史命令、显示错误内容等等。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">set</span> <span class="token punctuation">[</span>-uvCHhmBx<span class="token punctuation">]</span>选项与参数:-u :预设不启用。若启用后,当使用未设定变量时,会显示错误讯息<span class="token punctuation">;</span>-v :预设不启用。若启用后,在讯息被输出前,会先显示讯息的原始内容<span class="token punctuation">;</span>-x :预设不启用。若启用后,在指令被执行前,会显示指令内容<span class="token punctuation">(</span>前面有 ++ 符号<span class="token punctuation">)</span>-h :预设启用。与历史命令有关<span class="token punctuation">;</span>-H :预设启用。与历史命令有关<span class="token punctuation">;</span>-m :预设启用。与工作管理有关<span class="token punctuation">;</span>-B :预设启用。与刮号 <span class="token punctuation">[</span><span class="token punctuation">]</span> 的作用有关<span class="token punctuation">;</span>-C :预设不启用。若使用 <span class="token operator">></span> 等,则若文件存在时,该文件不会被覆盖。$ <span class="token keyword">echo</span> $- <span class="token comment" spellcheck="true">#显示目前所有的 set 设定值</span>himBHs</code></pre><table><thead><tr><th>组合按键</th><th>执行结果</th></tr></thead><tbody><tr><td>Ctrl + C</td><td>终止目前的命令</td></tr><tr><td>Ctrl + D</td><td>输入结束 (EOF),例如邮件结束的时候;</td></tr><tr><td>Ctrl + M</td><td>就是 Enter 啦!</td></tr><tr><td>Ctrl + S</td><td>暂停屏幕的输出</td></tr><tr><td>Ctrl + Q</td><td>恢复屏幕的输出Ctrl + U 在提示字符下,将整列命令删除</td></tr><tr><td>Ctrl + Z</td><td>『暂停』目前的命令</td></tr></tbody></table><h5 id="通配符与特殊符号"><a href="#通配符与特殊符号" class="headerlink" title="通配符与特殊符号"></a>通配符与特殊符号</h5><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>代表『 0 个到无穷多个』任意字符</td></tr><tr><td>?</td><td>代表『一定有一个』任意字符</td></tr><tr><td>[ ]</td><td>同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符, 可能是 a, b,c, d 这四个任何一个』</td></tr><tr><td>[ - ]</td><td>若有减号在中括号内时,代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字,因为数字的语系编码是连续的!</td></tr><tr><td>[^ ]</td><td>若中括号内的第一个字符为指数符号 (^) ,那表示『反向选择』,例如 [^abc] 代表 一定有一个字符,只要是非 a, b, c 的其他字符就接受的意思。</td></tr></tbody></table><table><thead><tr><th>符号</th><th>内容</th></tr></thead><tbody><tr><td>#</td><td>批注符号:这个最常被使用在 script 当中,视为说明!在后的数据均不执行</td></tr><tr><td>\</td><td>跳脱符号:将『特殊字符或通配符』还原成一般字符</td></tr><tr><td>|</td><td>管线 (pipe):分隔两个管线命令的界定(后两节介绍);</td></tr><tr><td>;</td><td>连续指令下达分隔符:连续性命令的界定 (注意!与管线命令并不相同)</td></tr><tr><td>~</td><td>用户的家目录</td></tr><tr><td>$</td><td>取用变数前导符:亦即是变量之前需要加的变量取代值</td></tr><tr><td>&amp;</td><td>工作控制 (job control):将指令变成背景下工作</td></tr><tr><td>!</td><td>逻辑运算意义上的『非』 not 的意思!</td></tr><tr><td>/</td><td>目录符号:路径分隔的符号</td></tr><tr><td>&gt;, &gt;&gt;</td><td>数据流重定向:输出定向,分别是『取代』与『累加』</td></tr><tr><td>&lt;, &lt;&lt;</td><td>数据流重定向:输入定向 (这两个留待下节介绍)</td></tr><tr><td>‘ ‘</td><td>单引号,不具有变量置换的功能 ($ 变为纯文本)</td></tr><tr><td>“ “</td><td>具有变量置换的功能! ($ 可保留相关功能)</td></tr><tr><td><code></code></td><td>两个『 ` 』中间为可以先执行的指令,亦可使用 $( )</td></tr><tr><td>( )</td><td>在中间为子 shell 的起始与结束</td></tr><tr><td>{ }</td><td>在中间为命令区块的组合!</td></tr><tr><td>#### 数据流重定向</td><td></td></tr><tr><td>redirec,据流重导向就是将某个指令执行后应该要出现在屏幕上的数据, 给他传输到其他的地方,</td><td></td></tr><tr><td>例如文件或者是装置 (例如打印机)。</td><td></td></tr><tr><td>##### 什么是数据流重定向</td><td></td></tr><tr><td><a href="https://imgchr.com/i/Eol81A" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/14/Eol81A.md.png" alt="Eol81A.md.png"></a></td><td></td></tr><tr><td>###### standard output 与 standard error output</td><td></td></tr></tbody></table><p><strong><em>标准输出指的是『指令执行所回传的正确的讯息』,而标准错误输出可理解为『 指令执行失败后,所回传的错误讯息』</em></strong></p><pre class=" language-bash"><code class="language-bash">$ ll / <span class="token comment" spellcheck="true">#此时屏幕会显示出文件名信息</span>$ ll / <span class="token operator">></span> ~/rootfile <span class="token comment" spellcheck="true">#屏幕并无任何信息</span>$ ll ~/rootfile-rw-r--r-- 1 jason jason 2058 5月  14 16:10 /home/jason/rootfile<span class="token comment" spellcheck="true"># 1. 该文件 (本例中是 ~/rootfile) 若不存在,系统会自动的将他建立起来,但是</span><span class="token comment" spellcheck="true"># 2. 当这个文件存在的时候,那么系统就会先将这个文件内容清空,然后再将数据写入!</span><span class="token comment" spellcheck="true"># 3. 也就是若以 > 输出到一个已存在的文件中,那个文件就会被覆盖掉啰!</span><span class="token comment" spellcheck="true">#那如果我想要将数据累加而不想要将旧的数据删除,那该如何是好?利用两个大于的符号 (>>) 就好</span><span class="token comment" spellcheck="true">#啦!以上面的范例来说,你应该要改成『 ll / >> ~/rootfile 』即可。 如此一来,当 (1) ~/#rootfile 不存在时系统会主动建立这个文件;(2)若该文件已存在, 则数据会在该文件的最下方累加进去!</span><span class="token comment" spellcheck="true"># 1> :以覆盖的方法将『正确的数据』输出到指定的文件或装置上;</span><span class="token comment" spellcheck="true"># 1>>:以累加的方法将『正确的数据』输出到指定的文件或装置上;</span><span class="token comment" spellcheck="true"># 2> :以覆盖的方法将『错误的数据』输出到指定的文件或装置上;</span><span class="token comment" spellcheck="true"># 2>>:以累加的方法将『错误的数据』输出到指定的文件或装置上;</span></code></pre><h6 id="dev-null-垃圾桶黑洞装置与特殊写法"><a href="#dev-null-垃圾桶黑洞装置与特殊写法" class="headerlink" title="/dev/null 垃圾桶黑洞装置与特殊写法"></a>/dev/null 垃圾桶黑洞装置与特殊写法</h6><p>dev/null 可以吃掉任何导向这个装置的信息</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">find</span> /home -name .bashrc 2<span class="token operator">></span> /dev/null/home/dmtsai/.bashrc <span class="token comment" spellcheck="true">#只有 stdout 会显示到屏幕上, stderr 被丢弃了</span>$ <span class="token function">find</span> /home -name .bashrc <span class="token operator">></span> list 2<span class="token operator">></span> list <span class="token operator">&lt;=</span><span class="token operator">=</span>错误<span class="token comment" spellcheck="true">#由于两股数据同时写入一个文件,又没有使用特殊的语法, 此时两</span><span class="token comment" spellcheck="true">#股数据可能会交叉写入该文件内,造成次序的错乱。</span>$ <span class="token function">find</span> /home -name .bashrc <span class="token operator">></span> list 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&lt;=</span><span class="token operator">=</span>正确$ <span class="token function">find</span> /home -name .bashrc <span class="token operator">&amp;</span><span class="token operator">></span> list <span class="token operator">&lt;=</span><span class="token operator">=</span>正确<span class="token comment" spellcheck="true"># 将指令的数据全部写入名为 list 的文件中</span></code></pre><h6 id="standard-input-lt-与-lt-lt"><a href="#standard-input-lt-与-lt-lt" class="headerlink" title="standard input : &lt; 与 &lt;&lt;"></a>standard input : &lt; 与 &lt;&lt;</h6><p>将原本需要由键盘输入的数据,改由文件内容来取代</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#利用 cat 指令来建立一个文件的简单流程</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfiletesting<span class="token function">cat</span> <span class="token function">file</span> <span class="token function">test</span><span class="token operator">&lt;=</span><span class="token operator">=</span>这里按下 <span class="token punctuation">[</span>ctrl<span class="token punctuation">]</span>+d 来离开<span class="token comment" spellcheck="true"># 由于加入 > 在 cat 后,所以那个 catfile 会被主动的建立,</span><span class="token comment" spellcheck="true"># 而内容就是刚刚键盘上面输入的那两行数据了</span><span class="token comment" spellcheck="true">#用 stdin 取代键盘的输入以建立新文件的简单流程</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfile <span class="token operator">&lt;</span> ~/.bashrc$ ll catfile ~/.bashrc-rw-r--r-- 1 jason jason 4958 5月  14 16:34 catfile-rw-r--r-- 1 jason jason 4958 5月  14 15:25 /home/jason/.bashrc<span class="token comment" spellcheck="true">#&lt;&lt;代表的是『结束的输入字符』的意思</span>$ <span class="token function">cat</span> <span class="token operator">></span> catfile <span class="token operator">&lt;&lt;</span> <span class="token string">"eof"</span><span class="token operator">></span> This is a test.<span class="token operator">></span> OK now stop<span class="token operator">></span> eof<span class="token operator">&lt;=</span><span class="token operator">=</span>输入这关键词,立刻就结束而不需要输入 <span class="token punctuation">[</span>ctrl<span class="token punctuation">]</span>+d<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token function">cat</span> catfileThis is a test.OK now stop<span class="token operator">&lt;=</span><span class="token operator">=</span>只有这两行,不会存在关键词那一行<span class="token operator">!</span></code></pre><h5 id="命令执行的判断依据-amp-amp"><a href="#命令执行的判断依据-amp-amp" class="headerlink" title="命令执行的判断依据: ;  &amp;&amp;  ||"></a>命令执行的判断依据: ;  &amp;&amp;  ||</h5><ul><li>cmd ; cmd (不考虑指令相关性的连续指令下达)<br>在指令与指令中间利用分号 (;) 来隔开,这样一来,分号前的指令执行完后就会立刻接着执行后面的指令了。</li><li>$? (指令回传值) 与 &amp;&amp; 或 ||</li></ul><p>两个指令之间有相依性,而这个相依性主要判断的地方就在于前一个指令执行的结果是否正确。<strong><em>若前一个指令执行的结果为正确,在 Linux 底下会回传一个 $? = 0 的值</em></strong></p><table><thead><tr><th>指令下达情况</th><th>说明</th></tr></thead><tbody><tr><td>cmd1 &amp;&amp; cmd2</td><td>1. 若 cmd1 执行完毕且正确执行($?=0),则开始执行 cmd2。2. 若 cmd1 执行完毕且为错误 ($?≠0),则 cmd2 不执行。</td></tr><tr><td>cmd1 || cmd2</td><td>1. 若 cmd1 执行完毕且正确执行($?=0),则 cmd2 不执行。2. 若 cmd1 执行完毕且为错误 ($?≠0),则开始执行 cmd2。</td></tr></tbody></table><p><strong><em>Linux 底下的指令都是由左往右执行的</em></strong> 由于指令是一个接着一个去执行的,因此,如果真要使用判断,那么这个 &amp;&amp; 与 || 的顺序就不能搞错。</p><h4 id="管线命令pipe"><a href="#管线命令pipe" class="headerlink" title="管线命令pipe"></a>管线命令pipe</h4><p>管线命令『 | 』仅能处理经由前面一个指令传来的正确信息,也就是 standard output 的信息,对于stdandard error 并没有直接处理的能力。<br><a href="https://imgchr.com/i/EollfH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/14/EollfH.md.png" alt="EollfH.md.png"></a></p><pre class=" language-bash"><code class="language-bash">1.管线命令仅会处理 standard output,对于 standard error output 会予以忽略2.管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行</code></pre><h5 id="选取命令cut，grep"><a href="#选取命令cut，grep" class="headerlink" title="选取命令cut，grep"></a>选取命令cut，grep</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cut</span> -d<span class="token string">'分隔字符'</span> -f fields <span class="token operator">&lt;=</span><span class="token operator">=</span>用于有特定分隔字符$ <span class="token function">cut</span> -c 字符区间 <span class="token operator">&lt;=</span><span class="token operator">=</span>用于排列整齐的讯息选项与参数:-d :后面接分隔字符。与 -f 一起使用<span class="token punctuation">;</span>-f :依据 -d 的分隔字符将一段讯息分区成为数段,用 -f 取出第几段的意思<span class="token punctuation">;</span>-c :以字符 <span class="token punctuation">(</span>characters<span class="token punctuation">)</span> 的单位取出固定字符区间<span class="token punctuation">;</span></code></pre><p>cut 主要的用途在于将『同一行里面的数据进行分解!』</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">grep</span> <span class="token punctuation">[</span>-acinv<span class="token punctuation">]</span> <span class="token punctuation">[</span>--color<span class="token operator">=</span>auto<span class="token punctuation">]</span> <span class="token string">'搜寻字符串'</span> filename选项与参数:-a :将 binary 文件以 text 文件的方式搜寻数据-c :计算找到 <span class="token string">'搜寻字符串'</span> 的次数-i :忽略大小写的不同,所以大小写视为相同-n :顺便输出行号-v :反向选择,亦即显示出没有 <span class="token string">'搜寻字符串'</span> 内容的那一行<span class="token operator">!</span>--color<span class="token operator">=</span>auto :可以将找到的关键词部分加上颜色的显示喔<span class="token operator">!</span></code></pre><h5 id="排序命令sort，wc，uniq"><a href="#排序命令sort，wc，uniq" class="headerlink" title="排序命令sort，wc，uniq"></a>排序命令sort，wc，uniq</h5><h6 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sort</span> <span class="token punctuation">[</span>-fbMnrtuk<span class="token punctuation">]</span> <span class="token punctuation">[</span>file or stdin<span class="token punctuation">]</span>选项与参数:-f :忽略大小写的差异,例如 A 与 a 视为编码相同<span class="token punctuation">;</span>-b :忽略最前面的空格符部分<span class="token punctuation">;</span>-M :以月份的名字来排序,例如 JAN, DEC 等等的排序方法<span class="token punctuation">;</span>-n :使用『纯数字』进行排序<span class="token punctuation">(</span>默认是以文字型态来排序的<span class="token punctuation">)</span><span class="token punctuation">;</span>-r :反向排序<span class="token punctuation">;</span>-u :就是 <span class="token function">uniq</span> ,相同的数据中,仅出现一行代表<span class="token punctuation">;</span>-t :分隔符,预设是用 <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 键来分隔<span class="token punctuation">;</span>-k :以那个区间 <span class="token punctuation">(</span>field<span class="token punctuation">)</span> 来进行排序的意思$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sort</span> -t <span class="token string">':'</span> -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash$ last <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">' '</span> -f1 <span class="token operator">|</span> <span class="token function">sort</span> <span class="token comment" spellcheck="true">#利用 last ,将输出的数据仅取账号,并加以排序</span></code></pre><h6 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">uniq</span> <span class="token punctuation">[</span>-ic<span class="token punctuation">]</span>选项与参数:-i :忽略大小写字符的不同<span class="token punctuation">;</span>-c :进行计数</code></pre><h6 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wc</span> <span class="token punctuation">[</span>-lwm<span class="token punctuation">]</span>选项与参数:-l :仅列出行<span class="token punctuation">;</span>-w :仅列出多少字<span class="token punctuation">(</span>英文单字<span class="token punctuation">)</span><span class="token punctuation">;</span>-m :多少字符<span class="token punctuation">;</span></code></pre><h5 id="双向重定向tee"><a href="#双向重定向tee" class="headerlink" title="双向重定向tee"></a>双向重定向tee</h5><p>tee 会同时将数据流分送到文件去与屏幕 (screen);而输出到屏幕的,其实就是 stdout ,那就可以让下个指令继续处理<br><a href="https://imgchr.com/i/EotDat" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/14/EotDat.md.png" alt="EotDat.md.png"></a></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tee</span> <span class="token punctuation">[</span>-a<span class="token punctuation">]</span> <span class="token function">file</span>选项与参数:-a:以累加 <span class="token punctuation">(</span>append<span class="token punctuation">)</span> 的方式,将数据加入 <span class="token function">file</span> 当中<span class="token operator">!</span><span class="token comment" spellcheck="true">##### 字符转换命令tr，col，join，paste，expand</span><span class="token comment" spellcheck="true">###### tr</span><span class="token function">tr</span> 可以用来删除一段讯息当中的文字,或者是进行文字讯息的替换​```bash$ <span class="token function">tr</span> <span class="token punctuation">[</span>-ds<span class="token punctuation">]</span> SET1 <span class="token punctuation">..</span>.选项与参数:-d :删除讯息当中的 SET1 这个字符串<span class="token punctuation">;</span>-s :取代掉重复的字符<span class="token operator">!</span></code></pre><h6 id="col"><a href="#col" class="headerlink" title="col"></a>col</h6><pre class=" language-bash"><code class="language-bash">$ col <span class="token punctuation">[</span>-xb<span class="token punctuation">]</span>选项与参数:-x:将 tab 键转换成对等的空格键</code></pre><h6 id="join"><a href="#join" class="headerlink" title="join"></a>join</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">join</span> <span class="token punctuation">[</span>-ti12<span class="token punctuation">]</span> file1 file2选项与参数:-t:join 默认以空格符分隔数据,并且比对『第一个字段』的数据,如果两个文件相同,则将两笔数据联成一行,且第一个字段放在第一个<span class="token operator">!</span>-i :忽略大小写的差异<span class="token punctuation">;</span>-1 :这个是数字的 1 ,代表『第一个文件要用那个字段来分析』的意思<span class="token punctuation">;</span>-2 :代表『第二个文件要用那个字段来分析』的意思。<span class="token comment" spellcheck="true"># 在使用 join 之前,你所需要处理的文件应该要事先经过排序 (sort) 处理</span></code></pre><h6 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h6><p>将两行贴在一起,且中间以 [tab] 键隔开</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">paste</span> <span class="token punctuation">[</span>-d<span class="token punctuation">]</span> file1 file2选项与参数:-d :后面可以接分隔字符。预设是以 <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 来分隔的<span class="token operator">!</span>- :如果 <span class="token function">file</span> 部分写成 - ,表示来自 standard input 的资料的意思。</code></pre><h6 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">expand</span> <span class="token punctuation">[</span>-t<span class="token punctuation">]</span> <span class="token function">file</span>选项与参数:-t:后面可以接数字。一般来说,一个 tab 按键可以用 8 个空格键取代。我们也可以自行定义一个 <span class="token punctuation">[</span>tab<span class="token punctuation">]</span> 按键代表多少个字符呢<span class="token operator">!</span><span class="token comment" spellcheck="true">##### 分区命令split</span>``bash$ <span class="token function">split</span> <span class="token punctuation">[</span>-bl<span class="token punctuation">]</span> <span class="token function">file</span> PREFIX选项与参数:-b :后面可接欲分区成的文件大小,可加单位,例如 b, k, m 等<span class="token punctuation">;</span>-l :以行数来进行分区。PREFIX :代表前导符的意思,可作为分区文件的前导文字。$ <span class="token function">cd</span> /tmp<span class="token punctuation">;</span> <span class="token function">split</span> -b 300k /etc/services services$ <span class="token function">cat</span> services* <span class="token operator">>></span> servicesback <span class="token comment" spellcheck="true">#将上面的三个小文件合成一个文件</span></code></pre><h5 id="参数代换xargs"><a href="#参数代换xargs" class="headerlink" title="参数代换xargs"></a>参数代换xargs</h5><p>在产生某个指令的参数</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">xargs</span> <span class="token punctuation">[</span>-0epn<span class="token punctuation">]</span> <span class="token function">command</span>选项与参数:-0:如果输入的 stdin 含有特殊字符,例如 `, \, 空格键等等字符时,这个 -0 参数可以将他还原成一般字符。这个参数可以用于特殊状态喔<span class="token operator">!</span>-e:这个是 EOF <span class="token punctuation">(</span>end of file<span class="token punctuation">)</span> 的意思。后面可以接一个字符串,当 <span class="token function">xargs</span> 分析到这个字符串时,就会停止继续工作<span class="token operator">!</span>-p :在执行每个指令的 argument 时,都会询问使用者的意思<span class="token punctuation">;</span>-n :后面接次数,每次 <span class="token function">command</span> 指令执行时,要使用几个参数的意思。当 <span class="token function">xargs</span> 后面没有接任何的指令时,默认是以 <span class="token keyword">echo</span> 来进行输出喔<span class="token operator">!</span>$ $ <span class="token function">cut</span> -d <span class="token string">':'</span> -f 1 /etc/passwd <span class="token operator">|</span> <span class="token function">head</span> -n 3 <span class="token operator">|</span> <span class="token function">xargs</span> -n 1 <span class="token function">id</span>uid<span class="token operator">=</span>0<span class="token punctuation">(</span>root<span class="token punctuation">)</span> gid<span class="token operator">=</span>0<span class="token punctuation">(</span>root<span class="token punctuation">)</span> groups<span class="token operator">=</span>0<span class="token punctuation">(</span>root<span class="token punctuation">)</span>uid<span class="token operator">=</span>1<span class="token punctuation">(</span>bin<span class="token punctuation">)</span> gid<span class="token operator">=</span>1<span class="token punctuation">(</span>bin<span class="token punctuation">)</span> groups<span class="token operator">=</span>1<span class="token punctuation">(</span>bin<span class="token punctuation">)</span>uid<span class="token operator">=</span>2<span class="token punctuation">(</span>daemon<span class="token punctuation">)</span> gid<span class="token operator">=</span>2<span class="token punctuation">(</span>daemon<span class="token punctuation">)</span> groups<span class="token operator">=</span>2<span class="token punctuation">(</span>daemon<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 透过 -n 来处理,一次给予一个参数</span><span class="token comment" spellcheck="true"># 很多指令其实并不支持管线命令,因此我们可以透过 xargs 来提供该指令引用 standard input 之用</span></code></pre><h5 id="关于减号-的用途"><a href="#关于减号-的用途" class="headerlink" title="关于减号-的用途"></a>关于减号-的用途</h5><p>在管线命令当中,常常会使用到前一个指令的 stdout 作为这次的stdin , 某些指令需要用到文件名 (例如 tar) 来进行处理时,该 stdin 与 stdout 可以利用减号 “-“来替代:</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> /tmp/homeback$ <span class="token function">tar</span> -cvf - /home <span class="token operator">|</span> <span class="token function">tar</span> -xvf - -C /tmp/homeback<span class="token comment" spellcheck="true">#将 /home 里面的文件给他打包,但打包的数据不是纪录到文件,而是传送</span><span class="token comment" spellcheck="true">#到 stdout; 经过管线后,将 tar -cvf - /home 传送给后面的 tar -xvf - 』。</span><span class="token comment" spellcheck="true">#后面的这个 - 则是取用前一个指令的 stdout, 因此,我们就不需要使用 filename 了!</span></code></pre><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li>由于核心在内存中是受保护的区块,因此我们必须要透过『 Shell 』将我们输入的指令与 Kernel 沟通,好<br>让 Kernel 可以控制硬件来正确无误的工作</li><li>学习 shell 的原因主要有:文字接口的 shell 在各大 distribution 都一样;远程管理时文字接口速度较快;<br>shell 是管理 Linux 系统非常重要的一环,因为 Linux 内很多控制都是以 shell 撰写的。</li><li>系统合法的 shell 均写在 /etc/shells 文件中;</li><li>用户默认登入取得的 shell 记录于 /etc/passwd 的最后一个字段;</li><li>bash 的功能主要有:命令编修能力;命令与文件补全功能;命令别名设定功能;工作控制、前景背景控制;程序化脚本;通配符</li><li>type 可以用来找到执行指令为何种类型,亦可用于与 which 相同的功能;</li><li>变量就是以一组文字或符号等,来取代一些设定或者是一串保留的数据</li><li>变量主要有环境变量与自定义变量,或称为全局变量与局部变量</li><li>使用 env 与 export 可观察环境变量,其中 export 可以将自定义变量转成环境变量;</li><li>set 可以观察目前 bash 环境下的所有变量;</li><li>$? 亦为变量,是前一个指令执行完毕后的回传值。在 Linux 回传值为 0 代表执行成功;</li><li>locale 可用于观察语系资料;</li><li>可用 read 让用户由键盘输入变量的值</li><li>ulimit 可用以限制用户使用系统的资源情况</li><li>bash 的配置文件主要分为 login shell 与 non-login shell。 login shell 主要读取 /etc/profile 与 ~/.bash_profile,non-login shell 则仅读取 ~/.bashrc</li><li>在使用 vim 时,若不小心按了 [crtl]+s 则画面会被冻结。你可以使用 [ctrl]+q 来解除冻结</li><li>通配符主要有: *, ?, [] 等等</li><li>数据流重导向透过 &gt;, 2&gt;, &lt; 之类的符号将输出的信息转到其他文件或装置去;</li><li>连续命令的下达可透过 ; &amp;&amp; || 等符号来处理</li><li>管线命令的重点是:『管线命令仅会处理 standard output,对于 standard error output 会予以忽略』 『管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。』</li><li>本章介绍的管线命令主要有:cut, grep, sort, wc, uniq, tee, tr, col, join, paste, expand, split, xargs 等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;认识-BASH-这个-Shell&quot;&gt;&lt;a href=&quot;#认识-BASH-这个-Shell&quot; class=&quot;headerlink&quot; title=&quot;认识 BASH 这个 Shell&quot;&gt;&lt;/a&gt;认识 BASH 这个 Shell&lt;/h4&gt;&lt;h5 id=&quot;硬件、核心与she
      
    
    </summary>
    
      <category term="软件工具" scheme="http://jinzhengxu.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://jinzhengxu.github.io/tags/Linux/"/>
    
      <category term="BASH" scheme="http://jinzhengxu.github.io/tags/BASH/"/>
    
  </entry>
  
  <entry>
    <title>Linux(6)-vim程序编辑器</title>
    <link href="http://jinzhengxu.github.io/2019/04/23/niao-ge-de-linux-si-fang-cai-6-vim-cheng-xu-bian-ji-qi/"/>
    <id>http://jinzhengxu.github.io/2019/04/23/niao-ge-de-linux-si-fang-cai-6-vim-cheng-xu-bian-ji-qi/</id>
    <published>2019-04-23T15:26:15.000Z</published>
    <updated>2020-04-24T16:00:54.100Z</updated>
    
    <content type="html"><![CDATA[<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#     # ### #     #    ###  #####     ######  #######  #####  #######</span><span class="token comment" spellcheck="true">#     #  #  ##   ##     #  #     #    #     # #       #     #    #</span><span class="token comment" spellcheck="true">#     #  #  # # # #     #  #          #     # #       #          #</span><span class="token comment" spellcheck="true">#     #  #  #  #  #     #   #####     ######  #####    #####     #</span> <span class="token comment" spellcheck="true">#   #   #  #     #     #        #    #     # #             #    #</span>  <span class="token comment" spellcheck="true"># #    #  #     #     #  #     #    #     # #       #     #    #</span>   <span class="token comment" spellcheck="true">#    ### #     #    ###  #####     ######  #######  #####     #</span></code></pre><p>上古神器–vim，功能简单却又强大。是Linux下文本编辑的不二之选(emacs教徒不要打我)逃。</p><h4 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h4><p>vim是vi的高级版本，在vi的基础上添加来许多功能。其实不同的Linux发行版都会附带有很多不同的文本编辑器如emacs，nano，pico，joe等，但是vi还是占有统治地位：</p><ul><li><strong><em>许多UNIX-like系统都会基础集成vi编辑器，但是别的就不一定存在了</em></strong> ，所以vi的学习成本是值得我们付出的</li><li><strong><em>许多软件的编辑接口都会选择vi</em></strong> 这一点的原因同上</li><li><strong><em>vi有语法高亮的功能</em></strong></li><li>程序简单，编辑速度相当快捷</li></ul><h4 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h4><p>vi 有三种模式：命令模式(conmmand mode)，编辑模式(insert mode)，命令行模式(command-line mode).</p><ul><li>命令模式(conmmand mode)<br>使用vi打开一个文件，就直接进入命令模式了,这里可以使用上下左右控制光标，也可以删除整行，删除字符，也可以复制粘贴</li><li>编辑模式(insert mode)<br>在一般命令模式下，按下<code>i，I，o，O，a，A，r，R</code>就可以进入insert mode了，[Esc]可以推出insert mode。</li><li>命令行模式(command-line mode).<br>在一般命令模式下输入[:/?]中任意一个按钮，就可以将光标移动到最下面一行。</li></ul><p>需要注意的是<br><strong><em>命令模式可以与命令行模式和编辑模式互换，但是命令行模式和编辑模式不能互换</em></strong></p><h5 id="简易执行范例"><a href="#简易执行范例" class="headerlink" title="简易执行范例"></a>简易执行范例</h5><ul><li>使用vi进入一般命令模式<pre class=" language-bash"><code class="language-bash">$ /usr/bin/vi .vimrc<span class="token comment" spellcheck="true"># 现在大部分发行版中都默认使用vim替换vi，所以要</span></code></pre></li></ul><h5 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h5><ul><li>第一部份:一般指令模式可用的按钮说明,光标移动、复制贴上、搜寻取代等</li></ul><table><thead><tr><th>移动光标的方法</th><th>效果</th></tr></thead><tbody><tr><td>h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td>使用 “30j” 或 “30↓”,即加上想要进行的次数(数字)后</td><td>向下移动30行g</td></tr><tr><td>[Ctrl] + [f]</td><td>屏幕『向下』移动一页,相当于 [Page Down]按键 (常用)</td></tr><tr><td>[Ctrl] + [b]</td><td>屏幕『向上』移动一页,相当于 [Page Up] 按键 (常用)</td></tr><tr><td>[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td>[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td>+</td><td>光标移动到非空格符的下一行g</td></tr><tr><td>-</td><td>光标移动到非空格符的上一行g</td></tr><tr><td>n&lt;space&gt;</td><td>n 表示『数字』,例如 20 。按下数字后再按空格键,光标会向右移动这一行g的 n个字符。</td></tr><tr><td>0 或功能键[Home]</td><td>这是数字『 0 』:移动到这一行g的最前面字符处 (常用)</td></tr><tr><td>$ 或功能键[End]</td><td>移动到这一行g的最后面字符处(常用)</td></tr><tr><td>H</td><td>光标移动到这个屏幕的最上方那一行g的第一个字符</td></tr><tr><td>M</td><td>光标移动到这个屏幕的中央那一行g的第一个字符</td></tr><tr><td>L</td><td>光标移动到这个屏幕的最下方那一行g的第一个字符</td></tr><tr><td>G</td><td>移动到这个文件的最后一行g(常用)</td></tr><tr><td>nG</td><td>n 为数字。移动到这个文件的第 n 行g。</td></tr><tr><td>gg</td><td>移动到这个文件的第一行g,相当于 1G 啊! (常用)</td></tr><tr><td>n&lt;Enter&gt;</td><td>n 为数字。光标向下移动 n 行g(常用)</td></tr></tbody></table><table><thead><tr><th>搜寻与取代</th><th>效果</th></tr></thead><tbody><tr><td>/word</td><td>向光标之下寻找一个名称为 word 的字符串。(常用)</td></tr><tr><td>?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td>n</td><td>这个 n 是英文按键。代表『重复前一个搜寻的动作』。</td></tr><tr><td>N</td><td>这个 N 是英文按键。与 n 刚好相反,为『反向』进行前一个搜寻动作。</td></tr><tr><td>:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行g之间寻找 word1 这个字符串,并将该字符串取代为 word2(常用)</td></tr><tr><td>:1,$s/word1/word2/g</td><td>从第一行g到最后一行g寻找 word1 字符串,并将该字符串取代为 word2(常用)</td></tr><tr><td>:1,$s/word1/word2/gc</td><td>从第一行g到最后一行g寻找 word1 字符串,并将该字符串取代为 word2 !且在取代前显示提示字符给用户确认 (confirm) 是否需要取代!(常用)</td></tr></tbody></table><table><thead><tr><th>删除、复制与贴上</th><th>效果</th></tr></thead><tbody><tr><td>x, X</td><td>在一行g字当中,x 为向后删除一个字符 (相当于 [del] 按键), X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td>nx n</td><td>为数字,连续向后删除 n 个字符。举例来说,我要连续删除 10 个字符, 『10x』 。</td></tr><tr><td>dd</td><td>删除游标所在的那一整行g(常用)</td></tr><tr><td>ndd</td><td>n 为数字。删除光标所在的向下 n 行g,例如 20dd 则是删除 20 行g (常用)</td></tr><tr><td>d1G</td><td>删除光标所在到第一行g的所有数据</td></tr><tr><td>dG</td><td>删除光标所在到最后一行g的所有数据</td></tr><tr><td>d$</td><td>删除游标所在处,到该行g的最后一个字符</td></tr><tr><td>d0</td><td>那个是数字的 0 ,删除游标所在处,到该行g的最前面一个字符</td></tr><tr><td>yy</td><td>复制游标所在的那一行g(常用)</td></tr><tr><td>nyy</td><td>n 为数字。复制光标所在的向下 n 行g,例如 20yy 则是复制 20 行g(常用)</td></tr><tr><td>y1G</td><td>复制光标所在行g到第一行g的所有数据</td></tr><tr><td>yG</td><td>复制光标所在行g到最后一行g的所有数据</td></tr><tr><td>y0</td><td>复制光标所在的那个字符到该行g行首的所有数据</td></tr><tr><td>y$</td><td>复制光标所在的那个字符到该行g行尾的所有数据</td></tr><tr><td>p, P</td><td>p 为将已复制的数据在光标下一行g贴上,P 则为贴在游标上一行g!</td></tr><tr><td>J</td><td>将光标所在列与下一列的数据结合成同一列</td></tr><tr><td>c</td><td>重复删除多个数据,例如向下删除 10 列,[ 10cj ]</td></tr><tr><td>u</td><td>复原前一个动作。(常用)</td></tr><tr><td>[Ctrl]+r</td><td>重做上一个动作</td></tr><tr><td>.</td><td>意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作,按下小数点『.』就好了! (常用)</td></tr></tbody></table><ul><li>第二部份:一般指令模式切换到编辑模式的可用的按钮说明</li></ul><table><thead><tr><th>进入插入或取代的编辑模式</th><th>效果</th></tr></thead><tbody><tr><td>i 进入插入模式(Insert mode)</td><td>i为『从目前光标所在处插入』(常用)</td></tr><tr><td>I 进入插入模式(Insert mode)</td><td>I为『在目前所在列的第一个非空格符处开始插入』(常用)</td></tr><tr><td>a 进入插入模式(Insert mode)</td><td>a为『从目前光标所在的下一个字符处开始插入』(常用)</td></tr><tr><td>A 进入插入模式(Insert mode)</td><td>A为『从光标所在列的最后一个 字符处开始插入』(常用)</td></tr><tr><td>o 进入插入模式(Insert mode)</td><td>o 为『在目前光标所在的下一列处插入新的一列』(常用)</td></tr><tr><td>O 进入插入模式(Insert mode)</td><td>O 为 在目前光标所在处的上一列插入新的一列(常用)</td></tr><tr><td>r 进入取代模式(Replace mode)</td><td>r 只会取代光标所在的那一个字符一次(常用)</td></tr><tr><td>R 进入取代模式(Replace mode)</td><td>R 会一直取代光标所在的文字,直到按下 ESC 为止;(常用)</td></tr><tr><td>[Esc]</td><td>退出编辑模式,回到一般指令模式中(常用)</td></tr></tbody></table><ul><li>第三部份:一般指令模式切换到指令列模式的可用按钮说明</li></ul><table><thead><tr><th>指令列模式的储存、离开等指令</th><th>效果</th></tr></thead><tbody><tr><td>:w</td><td>将编辑的数据写入硬盘文件中(常用)</td></tr><tr><td>:w!</td><td>若文件属性为『只读』时,强制写入该文件</td></tr><tr><td>:q</td><td>离开 vi (常用)</td></tr><tr><td>:q!</td><td>若曾修改过文件,又不想储存,使用 ! 为强制离开不储存文件。</td></tr><tr><td>:wq</td><td>储存后离开,若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td>ZZ 这是大写的 Z 喔!若文件没有更动,则不储存离开,若文件已经被更动过,则储存后离开</td><td></td></tr><tr><td>:w [filename]</td><td>将编辑的数据储存成另一个文件(类似另存新档)</td></tr><tr><td>:r [filename]</td><td>在编辑的数据中,读入另一个文件的数据。亦即将 『filename』 这个文件内容加到游标所在列后面</td></tr><tr><td>:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个文件</td></tr><tr><td>:! command</td><td>暂时离开 vi 到指令列模式下执行 command 的显示结果</td></tr></tbody></table><table><thead><tr><th>vim 环境的变更</th><th>效果</th></tr></thead><tbody><tr><td>:set nu</td><td>显示行号,设定之后,会在每一列的前缀显示该列的行号</td></tr><tr><td>:set nonu</td><td>与 set nu 相反,为取消行号!</td></tr></tbody></table><h5 id="vim的缓存，恢复与打开时的警告信息"><a href="#vim的缓存，恢复与打开时的警告信息" class="headerlink" title="vim的缓存，恢复与打开时的警告信息"></a>vim的缓存，恢复与打开时的警告信息</h5><p>当我们在使用 vim 编辑时, vim 会在与被编辑的文件的目录下,再建立一个名为 <code>.filename.swp</code> 的文件。</p><p>For example,我们使用vim打开一个已经存在的文件。</p><pre class=" language-bash"><code class="language-bash">$ vim config.json<span class="token comment" spellcheck="true"># 此时会进入到 vim 的画面,请在 vim 的命令模式下按下『 [ctrl]-z 』的组合键</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 vim config.json$ <span class="token function">ls</span> -alh <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"config"</span>-rw-r--r--  1 jason jason  767 4月  16 13:43 config.json-rw-r--r--  1 jason jason  12K 5月   6 08:39 .config.json.swp <span class="token operator">&lt;=</span><span class="token operator">=</span>暂存文件<span class="token comment" spellcheck="true"># 按下『 [ctrl]-z 』vim在后台中继续执行，我们可以模拟一种更极端的情况，断电</span>$ <span class="token function">kill</span> -9 %1<span class="token punctuation">[</span>1<span class="token punctuation">]</span>+  Stopped                 vim -u ~/.defaultvim config.json$ <span class="token function">ls</span> -alh <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"config"</span>-rw-r--r--  1 jason jason  767 4月  16 13:43 config.json-rw-r--r--  1 jason jason  12K 5月   6 08:39 .config.json.swp <span class="token operator">&lt;=</span><span class="token operator">=</span>暂存文件依然存在<span class="token comment" spellcheck="true"># 由于 vim 的工作被不正</span><span class="token comment" spellcheck="true"># 常的中断,导致暂存盘无法藉由正常流程来结束,</span><span class="token comment" spellcheck="true"># 所以暂存档就不会消失,而继续保留下来。</span>$ vim -u ~/.defaultvim config.jsonE325: ATTENTIONFound a swap <span class="token function">file</span> by the name <span class="token string">".config.json.swp"</span>          owned by: jason   dated: Mon May  6 08:39:13 2019         <span class="token function">file</span> name: ~jason/v2ray-linux-64/config.json <span class="token operator">&lt;=</span><span class="token operator">=</span>这个暂存文件属于哪个实际的文件          modified: no         user name: jason   host name: jason-ThinkPad-X1-Carbon-6th        process ID: 6350While opening <span class="token function">file</span> <span class="token string">"config.json"</span>             dated: Tue Apr 16 13:43:18 2019<span class="token punctuation">(</span>1<span class="token punctuation">)</span> Another program may be editing the same file.  If this is the case,    be careful not to end up with two different instances of the same    <span class="token function">file</span> when making changes.  Quit, or <span class="token keyword">continue</span> with caution.<span class="token punctuation">(</span>2<span class="token punctuation">)</span> An edit session <span class="token keyword">for</span> this <span class="token function">file</span> crashed.    If this is the case, use <span class="token string">":recover"</span> or <span class="token string">"vim -r config.json"</span>    to recover the changes <span class="token punctuation">(</span>see <span class="token string">":help recovery"</span><span class="token punctuation">)</span>.    If you did this already, delete the swap <span class="token function">file</span> <span class="token string">".config.json.swp"</span>    to avoid this message.<span class="token comment" spellcheck="true"># 问题一:可能有其他人或程序同时在编辑这个文件:</span><span class="token comment" spellcheck="true"># 由于 Linux 是多人多任务的环境,因此很可能有很多人同时在编辑同一个文件。</span><span class="token comment" spellcheck="true"># 如果在多人共同编辑的情况下, 万一大家同时储存,那么这个文件的内容将会变的乱七八糟!</span><span class="token comment" spellcheck="true"># 为了避免这个问题,因此 vim 会出现这个警告窗口解决的方法则是:</span><span class="token comment" spellcheck="true">#　１．找到另外那个程序或人员,请他将该 vim 的工作结束,然后你再继续处理。</span><span class="token comment" spellcheck="true">#　２．如果你只是要看该文件的内容并不会有任何修改编辑的行为,那么可以选择开启成为只读(O)文件,</span><span class="token comment" spellcheck="true">#　亦即上述画面反白部分输入英文『 o 』即可,其实就是 [O]pen Read-Only 的选项啦!</span><span class="token comment" spellcheck="true">#　问题二:在前一个 vim 的环境中,可能因为某些不知名原因导致 vim 中断 (crashed):</span><span class="token comment" spellcheck="true"># 如果你之前的 vim 处理动作尚未储存,此时你应该要按下『R』</span><span class="token comment" spellcheck="true"># ,亦即使用 (R)ecover 的项目，离开 vim 后</span><span class="token comment" spellcheck="true"># 还得要自行删除 .man_db.conf.swp 才能避免每次打开这个文件都会出现这样的警告!</span>Swap <span class="token function">file</span> <span class="token string">".config.json.swp"</span> already exists<span class="token operator">!</span><span class="token punctuation">[</span>O<span class="token punctuation">]</span>pen Read-Only, <span class="token punctuation">(</span>E<span class="token punctuation">)</span>dit anyway, <span class="token punctuation">(</span>R<span class="token punctuation">)</span>ecover, <span class="token punctuation">(</span>D<span class="token punctuation">)</span>elete it, <span class="token punctuation">(</span>Q<span class="token punctuation">)</span>uit, <span class="token punctuation">(</span>A<span class="token punctuation">)</span>bort:<span class="token comment" spellcheck="true"># [O]pen Read-Only:打开此文件成为只读档, 可以用在你只是想要查阅该文件内容并不想要进行编辑行为时。</span><span class="token comment" spellcheck="true"># (E)dit anyway:还是用正常的方式打开你要编辑的那个文件, 并不会载入暂存盘的内容。不过很容易出现两个使用者互相改变对方的文件等问题!</span><span class="token comment" spellcheck="true"># (R)ecover:就是加载暂存盘的内容,用在你要救回之前未储存的工作。不过当你救回来并且储存离开 vim后,还是要手动自行删除那个暂存档喔!</span><span class="token comment" spellcheck="true"># (D)elete it:你确定那个暂存档是无用的!那么开启文件前会先将这个暂存盘删除! 这个动作其实是比较常</span><span class="token comment" spellcheck="true"># (Q)uit:按下 q 就离开 vim ,不会进行任何动作回到命令提示字符。</span><span class="token comment" spellcheck="true"># (A)bort:忽略这个编辑行为,感觉上与 quit 非常类似! 也会送你回到命令提示字符!</span></code></pre><h4 id="vim的额外功能"><a href="#vim的额外功能" class="headerlink" title="vim的额外功能"></a>vim的额外功能</h4><h5 id="可视区块"><a href="#可视区块" class="headerlink" title="可视区块"></a>可视区块</h5><p>区块选择(Visual Block),当我们按下 v 或者 V 或者 [Ctrl]+v 时, 这个时候光标移动过的地方就会开始反白,这三个按键的意义分别是:</p><table><thead><tr><th>区块选择的按键</th><th>意义</th></tr></thead><tbody><tr><td>v</td><td>字符选择,会将光标经过的地方反白选择!</td></tr><tr><td>V</td><td>列选择,会将光标经过的列反白选择!</td></tr><tr><td>[Ctrl]+v</td><td>区块选择,可以用长方形的方式选择资料</td></tr><tr><td>y</td><td>将反白的地方复制起来</td></tr><tr><td>d</td><td>将反白的地方删除掉</td></tr><tr><td>p</td><td>将刚刚复制的区块,在游标所在处贴上!</td></tr></tbody></table><h5 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h5><table><thead><tr><th>多文件编辑的按键</th><th>意义</th></tr></thead><tbody><tr><td>:n</td><td>编辑下一个文件</td></tr><tr><td>:N</td><td>编辑上一个文件</td></tr><tr><td>:files</td><td>列出目前这个 vim 的开启的所有文件</td></tr><tr><td>##### 多窗口功能</td><td></td></tr></tbody></table><table><thead><tr><th>多窗口情况下的按键</th><th>功能</th></tr></thead><tbody><tr><td>:sp [filename]</td><td>开启一个新窗口,如果有加 filename, 表示在新窗口开启一个新文件,否则表示两个窗口为同一个文件内容(同步显示)。</td></tr><tr><td>[ctrl]+w+j,[ctrl]+w+↓</td><td>光标可移动到下方的窗口</td></tr><tr><td>[ctrl]+w+k,[ctrl]+w+↑</td><td>光标移动到上面的窗口</td></tr><tr><td>[ctrl]+w+q</td><td>其实就是 :q 结束离开啦!</td></tr></tbody></table><h5 id="vim的关键词补全功能"><a href="#vim的关键词补全功能" class="headerlink" title="vim的关键词补全功能"></a>vim的关键词补全功能</h5><table><thead><tr><th>组合按钮</th><th>补齐的内容</th></tr></thead><tbody><tr><td>[ctrl]+x -&gt; [ctrl]+n</td><td>透过目前正在编辑的这个『文件的内容文字』作为关键词,予以补齐</td></tr><tr><td>[ctrl]+x -&gt; [ctrl]+f</td><td>以当前目录内的『文件名』作为关键词,予以补齐</td></tr><tr><td>[ctrl]+x -&gt; [ctrl]+o</td><td>以扩展名作为语法补充,以 vim 内建的关键词,予以补齐</td></tr></tbody></table><h5 id="vim环境设置与记录：-vimrc和-viminfo"><a href="#vim环境设置与记录：-vimrc和-viminfo" class="headerlink" title="vim环境设置与记录：/.vimrc和/.viminfo"></a>vim环境设置与记录：<del>/.vimrc和</del>/.viminfo</h5><p>vim 会主动的将你曾经做过的行为登录下来,那个记录动作的文件就是: <code>~/.viminfo</code></p><table><thead><tr><th>vim 的环境设定参数</th><th>效果</th></tr></thead><tbody><tr><td>:set nu :set nonu</td><td>就是设定与取消行号</td></tr><tr><td>:set hlsearch :set nohlsearch</td><td>hlsearch 就是 high light search(高亮度搜寻)</td></tr><tr><td>:set autoindent :set noautoindent</td><td>是否自动缩排?autoindent 就是自动缩排。</td></tr><tr><td>:set backup</td><td>是否自动储存备份档?</td></tr><tr><td>:set ruler</td><td>显示或不显示右下角的一些状态栏说明</td></tr><tr><td>:set showmode</td><td>这个则是,是否要显示 –INSERT– 之类的字眼在左下角的状态栏。</td></tr><tr><td>:set backspace=(012)</td><td>当 backspace 为 2 时,就是可以删除任意值;0 或 1 时,仅可删除刚刚输入的字符, 而无法删除原本就已经存在的文字</td></tr><tr><td>:set all</td><td>显示目前所有的环境参数设定值</td></tr><tr><td>:set</td><td>显示与系统默认值不同的设定参数, 一般来说就是你有自行变动过的设定参数啦!</td></tr><tr><td>:syntax on :syntax off</td><td>是否依据程序相关语法显示不同颜色?</td></tr><tr><td>:set bg=dark :set bg=light</td><td>可用以显示不同的颜色色调,预设是『 light 』。</td></tr></tbody></table><h5 id="vim常用命令示意图"><a href="#vim常用命令示意图" class="headerlink" title="vim常用命令示意图"></a>vim常用命令示意图</h5><p><img src="https://s2.ax1x.com/2019/05/06/EB5Dbt.jpg" alt="EB5Dbt.jpg"></p><h4 id="其他vim使用注意事项"><a href="#其他vim使用注意事项" class="headerlink" title="其他vim使用注意事项"></a>其他vim使用注意事项</h4><h5 id="中文编码的问题-q"><a href="#中文编码的问题-q" class="headerlink" title="中文编码的问题:q"></a>中文编码的问题:q</h5><pre class=" language-bash"><code class="language-bash">1. 你的 Linux 系统默认支持的语系数据:这与 /etc/locale.conf 有关<span class="token punctuation">;</span>2. 你的终端界面 <span class="token punctuation">(</span>bash<span class="token punctuation">)</span> 的语系: 这与 LANG, LC_ALL 这几个变数有关<span class="token punctuation">;</span>3. 你的文件原本的编码<span class="token punctuation">;</span>4. 开启终端机的软件,例如在 GNOME 底下的窗口接口。</code></pre><p>解决</p><pre class=" language-bash"><code class="language-bash">$ LANG<span class="token operator">=</span>zh_CN.gb18030$ <span class="token function">export</span> LC_ALL<span class="token operator">=</span>zh_CN.gb18030</code></pre><h5 id="DOS与Linux的换行符"><a href="#DOS与Linux的换行符" class="headerlink" title="DOS与Linux的换行符"></a>DOS与Linux的换行符</h5><p>DOS 与 Linux 断行字符的不同。<code>DOS</code> 使用的断行字符为 <code>^M$</code> ,我们称为 <code>CR</code> 与 <code>LF</code> 两个符号。 而在 Linux 底下,则是仅有 <code>LF ($)</code> 这个断行符号。</p><p>Linux 底下的指令在开始执行时,他的判断依据是 『Enter』,而 Linux 的 Enter 为<code>LF</code> 符号, 不过,由于 <code>DOS</code> 的断行符号是 <code>CRLF</code> ,也就是多了一个 <code>^M</code> 的符号出来, 在这样的<br>情况下,如果是一个 <code>shell script</code> 的程序文件,将可能造成『程序无法执行』的状态。</p><pre class=" language-bash"><code class="language-bash">$ dos2unix <span class="token punctuation">[</span>-kn<span class="token punctuation">]</span> <span class="token function">file</span> <span class="token punctuation">[</span>newfile<span class="token punctuation">]</span>$ unix2dos <span class="token punctuation">[</span>-kn<span class="token punctuation">]</span> <span class="token function">file</span> <span class="token punctuation">[</span>newfile<span class="token punctuation">]</span>选项与参数:-k :保留该文件原本的 mtime 时间格式 <span class="token punctuation">(</span>不更新文件上次内容经过修订的时间<span class="token punctuation">)</span>-n :保留原本的旧档,将转换后的内容输出到新文件,如: dos2unix -n old new范例一:将 /etc/man_db.conf 重新复制到 /tmp/vitest/ 底下,并将其修改成为 dos 断行$ <span class="token function">cd</span> /tmp/vitest$ <span class="token function">cp</span> -a /etc/man_db.conf <span class="token keyword">.</span>$ ll man_db.conf-rw-r--r--. 1 root root 5171 Jun 102014 man_db.conf$ unix2dos -k man_db.confunix2dos: converting <span class="token function">file</span> man_db.conf to DOS <span class="token function">format</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 屏幕会显示上述的讯息,说明断行转为 DOS 格式了!</span>$ ll man_db.conf-rw-r--r--. 1 dmtsai dmtsai 5302 Jun 102014 man_db.conf<span class="token comment" spellcheck="true"># 断行字符多了 ^M ,所以容量增加了!</span>范例二:将上述的 man_db.conf 转成 Linux 断行字符,并保留旧文件,新档放于 man_db.conf.linux$ dos2unix -k -n man_db.conf man_db.conf.linuxdos2unix: converting <span class="token function">file</span> man_db.conf to <span class="token function">file</span> man_db.conf.linux <span class="token keyword">in</span> Unix <span class="token function">format</span> <span class="token punctuation">..</span>.$ ll man_db.conf*-rw-r--r--. 1 dmtsai dmtsai 5302 Jun 10 2014 man_db.conf-rw-r--r--. 1 dmtsai dmtsai 5171 Jun 10 2014 man_db.conf.linux$ <span class="token function">file</span> man_db.conf*man_db.conf:<span class="token punctuation">[</span>dmtsai@study vitest<span class="token punctuation">]</span>ASCII text, with CRLF line terminators<span class="token comment" spellcheck="true"># 很清楚说明是 CRLF 断行!</span>man_db.conf.linux: ASCII text</code></pre><h5 id="语系编码转换"><a href="#语系编码转换" class="headerlink" title="语系编码转换"></a>语系编码转换</h5><p>使用<code>iconv</code>命令可以快捷的完成文件编码的转换</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">iconv</span> --listThe following list contains all the coded character sets known.  This doesnot necessarily mean that all combinations of these names can be used <span class="token keyword">for</span>the FROM and TO <span class="token function">command</span> line parameters.  One coded character <span class="token keyword">set</span> can belisted with several different names <span class="token punctuation">(</span>aliases<span class="token punctuation">)</span>.  437, 500, 500V1, 850, 851, 852, 855, 856, 857, 858, 860, 861, 862, 863, 864,  865, 866, 866NAV, 869, 874, 904, 1026, 1046, 1047, 8859_1, 8859_2, 8859_3,  8859_4, 8859_5, 8859_6, 8859_7, 8859_8, 8859_9, 10646-1:1993,  10646-1:1993/UCS4, ANSI_X3.4-1968, ANSI_X3.4-1986, ANSI_X3.4,<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.$ <span class="token function">iconv</span> -f 原本编码 -t 新编码 filename <span class="token punctuation">[</span>-o newfile<span class="token punctuation">]</span>选项与参数:--list :列出 <span class="token function">iconv</span> 支持的语系数据-f :from ,亦即来源之意,后接原本的编码格式<span class="token punctuation">;</span>-t :to ,亦即后来的新编码要是什么格式<span class="token punctuation">;</span> -o file:如果要保留原本的文件,那么使用 -o 新档名,可以建立新编码文件。</code></pre><p>不过如果是要将正体中文的 utf8 转成简体中文的 utf8 编码时,那就得费些功夫了! 举例来说,如<br>果要将刚刚那个 vi.utf8 转成简体的 utf8 时,可以这样做:</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">iconv</span> -f utf8 -t big5 vi.utf8 <span class="token operator">|</span> \<span class="token operator">></span> <span class="token function">iconv</span> -f big5 -t gb2312 <span class="token operator">|</span> <span class="token function">iconv</span> -f gb2312 -t utf8 -o vi.gb.utf8</code></pre><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li>Linux 底下的配置文件多为文本文件,故使用 vim 即可进行设定编辑;</li><li>vim 可视为程序编辑器,可用以编辑 shell script, 配置文件等,避免打错字;</li><li>vi 为所有 unix like 的操作系统都会存在的编辑器,且执行速度快速;</li><li>vi 有三种模式,一般指令模式可变换到编辑与指令列模式,但编辑模式与指令列模式不能互换;</li><li>常用的按键有 i, [Esc], :wq 等;</li><li>vi 的画面大略可分为两部份,(1)上半部的本文与(2)最后一行的状态+指令列模式;</li><li>数字是有意义的,用来说明重复进行几次动作的意思,如 5yy 为复制 5 列之意;</li><li>光标的移动中,大写的 G 经常使用,尤其是 1G, G 移动到文章的头/尾功能!</li><li>vi 的取代功能也很棒! :n1,n2s/old/new/g 要特别注意学习起来;</li><li>小数点『 . 』为重复进行前一次动作,也是经常使用的按键功能!</li><li>进入编辑模式几乎只要记住: i, o, R 三个按钮即可!尤其是新增一列的 o 与取代的 R</li><li>vim 会主动的建立 swap 暂存档,所以不要随意断线!</li><li>如果在文章内有对齐的区块,可以使用 [ctrl]-v 进行复制/贴上/删除的行为</li><li>使用 :sp 功能可以分区窗口</li><li>若使用 vim 来撰写网页,若需要 CSS 元素数据,可透过 [crtl]+x, [crtl]+o 这两个连续组合按键来取得关键词</li><li>vim 的环境设定可以写入在 ~/.vimrc 文件中;</li><li>可以使用 iconv 进行文件语系编码的转换</li><li>使用 dos2unix 及 unix2dos 可以变更文件每一列的行尾断行字符。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre class=&quot; language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;#     # ### #     #    ###  #####     
      
    
    </summary>
    
      <category term="软件工具" scheme="http://jinzhengxu.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://jinzhengxu.github.io/tags/Linux/"/>
    
      <category term="vim" scheme="http://jinzhengxu.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>从零开始打造你自己的编译器</title>
    <link href="http://jinzhengxu.github.io/2019/04/22/cong-ling-kai-shi-da-zao-ni-zi-ji-de-bian-yi-qi/"/>
    <id>http://jinzhengxu.github.io/2019/04/22/cong-ling-kai-shi-da-zao-ni-zi-ji-de-bian-yi-qi/</id>
    <published>2019-04-22T01:15:38.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<p>构造一个自己的编译器，看似是一个需要非常多的programming的事情，但是实际上借助现代的工具，构造一个编译器并不是我们想象中的那么困难。<br>当然你也可以追求手撕编译器的极致体验，这当然很好，但是重复造轮子对于初学者从宏观和大局上理解编译器的架构的作用并不大，现代的分析器生成工具，可以让我们把精力集中在重要的部分，而且bug的调试也较为简单。</p><p>先简单介绍一下我们将要使用的工具集：</p><pre class=" language-c"><code class="language-c">flex：基于lex 的词法分析器的生成器bison：基于yacc语法分析器的生成器LLVM<span class="token punctuation">:</span></code></pre><p>再来简单介绍一下编译器的各个流程：<br><img src="https://s2.ax1x.com/2019/04/22/EkYv9g.png" alt="EkYv9g.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;构造一个自己的编译器，看似是一个需要非常多的programming的事情，但是实际上借助现代的工具，构造一个编译器并不是我们想象中的那么困难。&lt;br&gt;当然你也可以追求手撕编译器的极致体验，这当然很好，但是重复造轮子对于初学者从宏观和大局上理解编译器的架构的作用并不大，现代的
      
    
    </summary>
    
      <category term="底层" scheme="http://jinzhengxu.github.io/categories/%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="编译原理" scheme="http://jinzhengxu.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="编译器" scheme="http://jinzhengxu.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="yacc" scheme="http://jinzhengxu.github.io/tags/yacc/"/>
    
      <category term="bison" scheme="http://jinzhengxu.github.io/tags/bison/"/>
    
      <category term="Lex" scheme="http://jinzhengxu.github.io/tags/Lex/"/>
    
      <category term="flex" scheme="http://jinzhengxu.github.io/tags/flex/"/>
    
      <category term="LLVM" scheme="http://jinzhengxu.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux(5)-文件与文件系统的压缩</title>
    <link href="http://jinzhengxu.github.io/2019/04/18/niao-ge-de-linux-si-fang-cai-5-wen-jian-yu-wen-jian-xi-tong-de-ya-suo/"/>
    <id>http://jinzhengxu.github.io/2019/04/18/niao-ge-de-linux-si-fang-cai-5-wen-jian-yu-wen-jian-xi-tong-de-ya-suo/</id>
    <published>2019-04-18T06:43:28.000Z</published>
    <updated>2020-04-24T16:00:54.100Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下一切都是文件，所以其实不同压缩文件的的文件扩展名对于Linux来说并没有什么区别，但是可以方便系统的操作这也就是方便人类阅读和管理。</p><h4 id="压缩文件的用途与技术"><a href="#压缩文件的用途与技术" class="headerlink" title="压缩文件的用途与技术"></a>压缩文件的用途与技术</h4><p>我们知道一个字节有8个bit，假设一个数字只有最右侧的bit为1，剩下的位都为0，这样就有可以压缩的地方，我们可以将剩下的7个0丢出去。这样就完成了压缩的目的，减小了文件的容量。还有一种可能是文件中有连续的100个1，我们可以将其压缩尾『100个1』而不是真的记录100个1。</p><p><strong><em>压缩后文件与压缩前文件的比值就称为压缩比</em></strong></p><h4 id="Linux系统常见的压缩命令"><a href="#Linux系统常见的压缩命令" class="headerlink" title="Linux系统常见的压缩命令"></a>Linux系统常见的压缩命令</h4><p>通过不同压缩文件的扩展名，我们可以知道文件的压缩方式，并选择合适的文件解压缩方式。</p><p>Linux下的压缩文件扩展名一般有：</p><pre class=" language-bash"><code class="language-bash">*.Z        compress压缩文件，现在基本没有了*.zip      zip程序压缩的文件*.gz       gzip程序压缩的文件*.bz2      bzip2程序压缩的文件*.xz       xz程序压缩的文件*.tar      tar程序打包的文件*.tar.gz   tar程序打包的文件，并经过gzip的压缩*.tar.bz2  tar程序打包的文件，并经过bzip2的压缩*.tar.xz   tar程序打包的文件，并经过xz的压缩</code></pre><h5 id="gzip，zcat-zmore-zless-zgrep"><a href="#gzip，zcat-zmore-zless-zgrep" class="headerlink" title="gzip，zcat/zmore/zless/zgrep"></a>gzip，zcat/zmore/zless/zgrep</h5><p>下面用内核文件演示一下过程</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">gzip</span> <span class="token punctuation">[</span>-cdtv<span class="token comment" spellcheck="true">#] 文件名</span>$ zcat 文件名.gz选项与参数: -c <span class="token keyword">:</span> 将压缩的数据输出到屏幕上，可以通过数据流重定向来处理 -d <span class="token keyword">:</span> 解压缩 -t <span class="token keyword">:</span> 检验一个压缩文件的一致性，尾呢见有无错误 -v <span class="token keyword">:</span> 显示出压缩比 -<span class="token comment" spellcheck="true"># : # 为数字的意思1-9，-1最快但是压缩比最差，默认是-6</span>$ <span class="token function">gzip</span> -v vmlinuz-4.15.0-46-genericvmlinuz-4.15.0-46-generic:      4.4% -- replaced with vmlinuz-4.15.0-46-generic.gz$ zat/zmore/zless 文本文件<span class="token comment" spellcheck="true"># 如果原来的文件是文本文件，这三个命令可以将压缩文件中的内容读出来</span>$ <span class="token function">gzip</span> -d services.gz<span class="token comment" spellcheck="true"># 与windows不同的是，Linux解压和压缩都会将源文件删除，只保留操作后的文件</span>$ <span class="token function">gzip</span> -9 -c services <span class="token operator">></span> services.gz<span class="token comment" spellcheck="true"># 这样就可以保留原有的文件</span><span class="token comment" spellcheck="true"># -c负责将压缩的文件内容输出大屏幕上，但是通过>我们可以将内容输入到文件里</span>$ zgrep -n <span class="token string">"http"</span> services.gz <span class="token comment" spellcheck="true">#这样可以查询压缩文件中的关键词</span>7:<span class="token comment" spellcheck="true"># Updated from http://www.iana.org/assignments/port-numbers and other</span>8:<span class="token comment" spellcheck="true"># sources like http://www.freebsd.org/cgi/cvsweb.cgi/src/etc/services .</span>53:http        80/tcp        www        <span class="token comment" spellcheck="true"># WorldWideWeb HTTP</span>138:https        443/tcp                <span class="token comment" spellcheck="true"># http protocol over TLS/SSL</span>419:http-alt    8080/tcp    webcache    <span class="token comment" spellcheck="true"># WWW caching service</span>420:http-alt    8080/udp$ znew 文件<span class="token comment" spellcheck="true"># 将老的*.Z文件转换为gzip文件</span></code></pre><h5 id="bzip2，bzcat-bzmore-bzless-bzgrep"><a href="#bzip2，bzcat-bzmore-bzless-bzgrep" class="headerlink" title="bzip2，bzcat/bzmore/bzless/bzgrep"></a>bzip2，bzcat/bzmore/bzless/bzgrep</h5><p>bzip2可以获得比gzip更好的压缩比</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">bzip2</span> <span class="token punctuation">[</span>-cdkzv<span class="token comment" spellcheck="true">#] 文件名</span>$ bcat 文件名.bz2选项与参数:-c <span class="token keyword">:</span> 将压缩的数据输出到屏幕上，可以通过数据流重定向来处理-d <span class="token keyword">:</span> 解压缩-k <span class="token keyword">:</span> 保留原始文件不删除-t <span class="token keyword">:</span> 检验一个压缩文件的一致性，尾呢见有无错误-v <span class="token keyword">:</span> 显示出压缩比-<span class="token comment" spellcheck="true"># : # 为数字的意思1-9，-1最快但是压缩比最差，默认是-6</span></code></pre><p>但是对于大容量文件来说，bzip2会耗费更多的时间。</p><h5 id="xz-xzcat-xzmore-xzless-xzgrep"><a href="#xz-xzcat-xzmore-xzless-xzgrep" class="headerlink" title="xz,xzcat/xzmore/xzless/xzgrep"></a>xz,xzcat/xzmore/xzless/xzgrep</h5><p>xz的压缩比会更高</p><pre class=" language-bash"><code class="language-bash">$ xz <span class="token punctuation">[</span>-dtlkc<span class="token comment" spellcheck="true">#] 文件名</span>$ xcat 文件名.xz选项与参数：-c <span class="token keyword">:</span> 将压缩的数据输出到屏幕上，可以通过数据流重定向来处理-d <span class="token keyword">:</span> 解压缩-k <span class="token keyword">:</span> 保留原始文件不删除-l <span class="token keyword">:</span> 列出压缩文件的相关信息-t <span class="token keyword">:</span> 检验一个压缩文件的一致性，尾呢见有无错误-<span class="token comment" spellcheck="true"># : # 为数字的意思1-9，-1最快但是压缩比最差，默认是-6</span>$ xz -l services.xzStrms  Blocks   Compressed Uncompressed  Ratio  Check   Filename    1       1      7,052 B     18.7 KiB  0.368  CRC64   services.xz</code></pre><p>我们可以比较一下三个命令的时间：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">time</span> <span class="token function">gzip</span> -c services <span class="token operator">></span> services.gzreal    0m0.003suser    0m0.002ssys    0m0.001s$ <span class="token function">time</span> <span class="token function">bzip2</span> -c services <span class="token operator">></span> services.bz2real    0m0.003suser    0m0.003ssys    0m0.000s$ <span class="token function">time</span> xz -c services <span class="token operator">></span> services.xzreal    0m0.004suser    0m0.001ssys    0m0.004s</code></pre><p>可以看到三个命令的不同用时。</p><h4 id="打包命令：tar"><a href="#打包命令：tar" class="headerlink" title="打包命令：tar"></a>打包命令：tar</h4><p>上面的介绍的压缩命令都只能针对单个文件操作，如果有多个文件或者一整个目录都需要压缩的话，我们就需要tar打包命令。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 这里只有一部分的tar参数和选项，剩下的可以通过man 来查询</span>$ <span class="token function">tar</span> <span class="token punctuation">[</span>-z<span class="token operator">|</span>-j<span class="token operator">|</span>-J<span class="token punctuation">]</span> <span class="token punctuation">[</span>cv<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f 待建立的新文件名<span class="token punctuation">]</span> filename<span class="token punctuation">..</span>. <span class="token comment" spellcheck="true"># 打包与压缩</span>$ <span class="token function">tar</span> <span class="token punctuation">[</span>-z<span class="token operator">|</span>-j<span class="token operator">|</span>-J<span class="token punctuation">]</span> <span class="token punctuation">[</span>tv<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f 已有的tar文件名<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 查看文件名</span>$ <span class="token function">tar</span> <span class="token punctuation">[</span>-z<span class="token operator">|</span>-j<span class="token operator">|</span>-J<span class="token punctuation">]</span> <span class="token punctuation">[</span>xv<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f 已有的新文件名<span class="token punctuation">]</span> <span class="token punctuation">[</span>-C directory<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 解压</span>选项与参数：-c <span class="token keyword">:</span> 建立打包文件-t <span class="token keyword">:</span> 查看打包文件含有哪些文件名-x <span class="token keyword">:</span> 解包或解压缩的功能，通过-C指定文件解压缩的目录-z <span class="token keyword">:</span> 通过gzip对文件进行解压缩-j <span class="token keyword">:</span> 通过bzip2对文件进行解压缩-J <span class="token keyword">:</span> 通过x对文件进行解压缩-v <span class="token keyword">:</span> 在压缩解压缩的过程中将正在处理的文件名显示出来-f <span class="token keyword">:</span> -f后面接立刻要被处理的文件名-C <span class="token keyword">:</span> 指定解压目录-p <span class="token keyword">:</span> 保留备份文件的原本权限和数据-P <span class="token keyword">:</span> 保留绝对路径--exclude<span class="token operator">=</span>FILE <span class="token keyword">:</span> 不对FILE打包</code></pre><ul><li>使用tar备份/etc目录</li></ul><pre class=" language-bash"><code class="language-bash">$ <span class="token function">time</span> <span class="token function">tar</span> -zpcv -f /root/etc.tar.gz /etctar: Removing leading / from member names<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.real    0m1.130suser    0m0.895ssys    0m0.133s$ <span class="token function">time</span> <span class="token function">tar</span> -jpcv -f /root/etc.tar.bz2 /etctar: Removing leading / from member names<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.real    0m5.890suser    0m5.830ssys    0m0.104s$ <span class="token function">time</span> <span class="token function">tar</span> -jpcv -f /root/etc.tar.bz2 /etctar: Removing leading / from member names<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.real    0m8.008suser    0m7.957ssys    0m0.232s$ ll -h /root/etc*-rw-r--r-- 1 root root 2.3M 4月  23 15:33 /root/etc.tar.bz2-rw-r--r-- 1 root root 2.9M 4月  23 15:31 /root/etc.tar.gz-rw-r--r-- 1 root root 1.8M 4月  23 15:36 /root/etc.tar.xz$  <span class="token function">du</span> -sm /etc34    /etc <span class="token comment" spellcheck="true">#原本的文件占有34m</span></code></pre><ul><li>查看tar文件内部的数据内容</li></ul><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tar</span> -jtv -f /root/etc.tar.bz2-rw-r--r-- root/root        77 2018-01-18 06:35 etc/sysctl.d/10-console-messages.conf-rw-r--r-- root/root       506 2018-01-18 06:35 etc/sysctl.d/10-zeropage.conf-rw-r--r-- root/root       257 2018-01-18 06:35 etc/sysctl.d/10-link-restrictions.conf-rw-r--r-- root/root      1184 2018-01-18 06:35 etc/sysctl.d/10-magic-sysrq.conf</code></pre><p>这里我们可以发现警告信息<code>tar: Removing leading / from member names</code>的情况，每个文件都木得根目录，因为如果带有根目录你解压这个文件的时候，解压出来的文件就会覆盖根目录下的文件。-P选项代表你确实要保留压缩文件的根目录。</p><ul><li><p>将备份的内容解压缩，并指定特殊的目录</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tar</span> -jxv -f /root/etc.tar.bz2 -C /tmp</code></pre></li><li><p>仅解开单一文件的方法<br>```bash<br>$ tar -jtv -f /root/etc.tar.bz2 | grep ‘shadow’</p></li></ul><p>-rw-r—– root/shadow     834 2019-03-27 21:47 etc/gshadow-<br>-rw-r—– root/shadow     848 2019-03-27 21:47 etc/gshadow<br>-rw-r—– root/shadow    1356 2019-03-27 21:47 etc/shadow-<br>-rw-r—– root/shadow    1382 2019-03-27 21:47 etc/shadow<br>$ tar -jxv -f /root/etc.tar.bz2 etc/shadow<br>etc/shadow</p><pre><code>+ 打包目录，但是不包含目录下某些文件不要以`/root/etc*`开头的文件，而且文件也不能自己打包自己（因为在一个目录下）```bash$  tar -jcv -f /root/system.tar.bz2 --exclude=/root/etc* --exclude=/root/system.tar.bz2 /etc /root</code></pre><ul><li>仅备份比某个时刻还要新的文件<br><code>--newer</code>后面的日期包含mtime和ctime，<code>--newer-mtime</code>值包含mtime<br>```bash<br>$ find /etc -newer /etc/passwd<br>$ ll /etc/passwd</li></ul><p>-rw-r–r– 1 root root 2580 3月  27 21:47 /etc/passwd<br>$ tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 –newer-mtime=”2019/03/27” /etc/*<br>$ tar -jtv -f /root/etc.newer.then.passwd.tar.bz2 | grep -v ‘/$’</p><h1 id="这个命令可以吸纳是出tar包中所有不以-结尾的文件"><a href="#这个命令可以吸纳是出tar包中所有不以-结尾的文件" class="headerlink" title="这个命令可以吸纳是出tar包中所有不以/结尾的文件"></a>这个命令可以吸纳是出tar包中所有不以/结尾的文件</h1><pre><code>+ tarfile  + 只是使用tar来打包的文件为 ***tarfile*** `tar -cv -f file.tar`  + 打包并压缩的为 ***tarball***将文件备份到磁带中无法使用cp命令，因为磁带是一次性读写设备，这时可以`tar -cv -f /dev/st0 /home /root /etc`+ 将文件一边打包一边解压```bash$ tar -cvf - /etc | tar -xvf -</code></pre><h4 id="XFS文件系统的备份与还原"><a href="#XFS文件系统的备份与还原" class="headerlink" title="XFS文件系统的备份与还原"></a>XFS文件系统的备份与还原</h4><h5 id="XFS文件系统备份xfsdump"><a href="#XFS文件系统备份xfsdump" class="headerlink" title="XFS文件系统备份xfsdump"></a>XFS文件系统备份xfsdump</h5><p>xfdump的一个特性是可以进行增量备份，这样可以节省很多时间，也就在第一次进行系统备份之后，之后在备份时我们都可以选择增量备份。</p><ul><li>第一次备份一定是完整备份，第一次备份在xfsdump中被认定为level0</li><li>xfsdump不支持没有挂载的文件系统的备份，只能备份已经被挂载的文件系统</li><li>必须使用root权限</li><li>只能备份xfs文件系统</li><li>xfsdump备份的数据只能有xfsrestore解析</li><li>不能备份两个有相同UUID的文件</li></ul><pre class=" language-bash"><code class="language-bash">$ xfsdump <span class="token punctuation">[</span>-L S_label<span class="token punctuation">]</span> <span class="token punctuation">[</span>-M M_label<span class="token punctuation">]</span> <span class="token punctuation">[</span>-l <span class="token comment" spellcheck="true">#] [-f 备份文件] 待备份数据</span>$ xfsdump -I选项与参数： -L <span class="token keyword">:</span> 对文件系统的说明 -M <span class="token keyword">:</span> 对储存媒介的说明 -l <span class="token keyword">:</span> 指定等级，0-9，0为完整备份 -f <span class="token keyword">:</span> 接产生的文件 -I <span class="token keyword">:</span> 从/var/lib/xfsdump/inventory列出目前备份的信息状态</code></pre><ul><li>xfsdump备份完整的文件系统<br>```bash<h1 id="1-先确定-boot-是独立的文件系统喔"><a href="#1-先确定-boot-是独立的文件系统喔" class="headerlink" title="1. 先确定 /boot 是独立的文件系统喔!"></a>1. 先确定 /boot 是独立的文件系统喔!</h1><h1 id="df-h-boot"><a href="#df-h-boot" class="headerlink" title="df -h /boot"></a>df -h /boot</h1>Filesystem Size<br>/dev/vda2 1014M<br>Used Avail Use% Mounted on<br>131M<br>884M<br>13% /boot<h1 id="挂载-boot-的是-dev-vda-装置"><a href="#挂载-boot-的是-dev-vda-装置" class="headerlink" title="挂载 /boot 的是 /dev/vda 装置!"></a>挂载 /boot 的是 /dev/vda 装置!</h1><h1 id="看-确实是独立的文件系统喔-boot-是挂载点"><a href="#看-确实是独立的文件系统喔-boot-是挂载点" class="headerlink" title="看!确实是独立的文件系统喔! /boot 是挂载点!"></a>看!确实是独立的文件系统喔! /boot 是挂载点!</h1><h1 id="2-将完整备份的文件名记录成为-srv-boot-dump"><a href="#2-将完整备份的文件名记录成为-srv-boot-dump" class="headerlink" title="2. 将完整备份的文件名记录成为 /srv/boot.dump :"></a>2. 将完整备份的文件名记录成为 /srv/boot.dump :</h1><h1 id="xfsdump-l-0-L-boot-all-M-boot-all-f-srv-boot-dump-boot"><a href="#xfsdump-l-0-L-boot-all-M-boot-all-f-srv-boot-dump-boot" class="headerlink" title="xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot"></a>xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot</h1>xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot<br>xfsdump: using file dump (drive_simple) strategy<br>xfsdump: version 3.1.4 (dump format 3.0) - type ^C for status and control<br>xfsdump: level 0 dump of study.centos.vbird:/boot # 开始备份本机/boot 系统<br>xfsdump: dump date: Wed Jul # 备份的时间<br>1 18:43:04 2015<br>xfsdump: session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1 # 这次 dump 的 ID<br>xfsdump: session label: “boot_all” # 简单给予一个名字记忆<br>xfsdump: ino map phase 1: constructing initial dump list # 开始备份程序<br>xfsdump: ino map phase 2: skipping (no pruning necessary)<br>xfsdump: ino map phase 3: skipping (only one dump stream)<br>xfsdump: ino map construction complete<br>xfsdump: estimated dump size: 103188992 bytes<br>xfsdump: creating dump session media file 0 (media 0, file 0)<br>xfsdump: dumping ino map<br>xfsdump: dumping directories<br>xfsdump: dumping non-directory files<br>xfsdump: ending media file<br>xfsdump: media file size 102872168 bytes<br>xfsdump: dump size (non-dir files) : 102637296 bytes<br>xfsdump: dump complete: 1 seconds elapsed<br>xfsdump: Dump Summary:xfsdump:<br>stream 0 /srv/boot.dump OK (success)<br>xfsdump: Dump Status: SUCCESS<h1 id="在指令的下达方面-你也可以不加-L-及-M-的-只是那就会进入互动模式-要求你-enter"><a href="#在指令的下达方面-你也可以不加-L-及-M-的-只是那就会进入互动模式-要求你-enter" class="headerlink" title="在指令的下达方面,你也可以不加 -L 及 -M 的,只是那就会进入互动模式,要求你 enter!"></a>在指令的下达方面,你也可以不加 -L 及 -M 的,只是那就会进入互动模式,要求你 enter!</h1><h1 id="而执行-xfsdump-的过程中会出现如上的一些讯息-您可以自行仔细的观察"><a href="#而执行-xfsdump-的过程中会出现如上的一些讯息-您可以自行仔细的观察" class="headerlink" title="而执行 xfsdump 的过程中会出现如上的一些讯息,您可以自行仔细的观察!"></a>而执行 xfsdump 的过程中会出现如上的一些讯息,您可以自行仔细的观察!</h1><h1 id="ll-srv-boot-dump"><a href="#ll-srv-boot-dump" class="headerlink" title="ll /srv/boot.dump"></a>ll /srv/boot.dump</h1></li></ul><p>-rw-r–r–. 1 root root 102872168 Jul<br>1 18:43 /srv/boot.dump</p><h1 id="ll-var-lib-xfsdump-inventory"><a href="#ll-var-lib-xfsdump-inventory" class="headerlink" title="ll /var/lib/xfsdump/inventory"></a>ll /var/lib/xfsdump/inventory</h1><p>-rw-r–r–. 1 root root 5080 Jul 1 18:43 506425d2-396a-433d-9968-9b200db0c17c.StObj<br>-rw-r–r–. 1 root root 312 Jul 1 18:43 94ac5f77-cb8a-495e-a65b-2ef7442b837c.InvIndex<br>-rw-r–r–. 1 root root 576 Jul 1 18:43 fstab</p><h1 id="使用了-xfsdump-之后才会有上述-var-lib-xfsdump-inventory-内的文件产生喔"><a href="#使用了-xfsdump-之后才会有上述-var-lib-xfsdump-inventory-内的文件产生喔" class="headerlink" title="使用了 xfsdump 之后才会有上述 /var/lib/xfsdump/inventory 内的文件产生喔!"></a>使用了 xfsdump 之后才会有上述 /var/lib/xfsdump/inventory 内的文件产生喔!</h1><pre><code>+ 用xfsdump进行增量备份```bash# 0. 看一下有没有任何文件系统被 xfsdump 过的资料?# xfsdump -Ifile system 0:fs id:94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:     mount point: study.centos.vbird:/boot     device: study.centos.vbird:/dev/vda2     time: Wed Jul     1 18:43:04 2015     session label: &quot;boot_all&quot;     session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1     level: 0     resumed: NO     subtree: NO     streams: 1     stream 0:             pathname: /srv/boot.dump             start: ino 132 offset 0             end: ino 2138243 offset 0             interrupted: NO             media files: 1             media file 0:                     mfile index: 0                     mfile type: data                     mfile size: 102872168                     mfile start: ino 132 offset                     mfile end: ino 2138243 offset 0                     media label: &quot;boot_all&quot;                     media id: a6168ea6-1ca8-44c1-8d88-95c863202eabxfsdump: Dump Status: SUCCESS# 我们可以看到目前仅有一个 session 0 的备份资料而已!而且是 level 0 喔!# 1. 先恶搞一下,建立一个大约 10 MB 的文件在 /boot 内:# dd if=/dev/zero of=/boot/testing.img bs=1M count=1010+0 records in10+0 records out10485760 bytes (10 MB) copied, 0.166128 seconds, 63.1 MB/s# 2. 开始建立差异备份档,此时我们使用 level 1 吧:# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot....(中间省略)....# ll /srv/boot*-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump-rw-r--r--. 1 root root 1 18:46 /srv/boot.dump110510952 Jul# 看看文件大小,岂不是就是刚刚我们所建立的那个大文件的容量吗? ^_^# 3. 最后再看一下是否有记录 level 1 备份的时间点呢?# xfsdump -Ifile system 0:fs id:94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2....(中间省略)....session 1:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul1 18:46:21 2015session label: &quot;boot_2&quot;session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8level: 1resumed: NOsubtree: NOstreams:1stream 0:pathname: /srv/boot.dump1start: ino 455518 offset 0</code></pre><h5 id="XFS文件系统还原xfsrestore"><a href="#XFS文件系统还原xfsrestore" class="headerlink" title="XFS文件系统还原xfsrestore"></a>XFS文件系统还原xfsrestore</h5><pre class=" language-bash"><code class="language-bash">$ xfsrestore -I <span class="token operator">&lt;=</span><span class="token operator">=</span>用来察看备份文件资料$ xfsrestore <span class="token punctuation">[</span>-f 备份档<span class="token punctuation">]</span> <span class="token punctuation">[</span>-L S_label<span class="token punctuation">]</span> <span class="token punctuation">[</span>-s<span class="token punctuation">]</span> 待复原目录 <span class="token operator">&lt;=</span><span class="token operator">=</span>单一文件全系统复原$ xfsrestore <span class="token punctuation">[</span>-f 备份文件<span class="token punctuation">]</span> -r 待复原目录<span class="token operator">&lt;=</span><span class="token operator">=</span>透过累积备份文件来复原系统$ xfsrestore <span class="token punctuation">[</span>-f 备份文件<span class="token punctuation">]</span> -i 待复原目录<span class="token operator">&lt;=</span><span class="token operator">=</span>进入互动模式选项与参数:-I :跟 xfsdump 相同的输出<span class="token operator">!</span>可查询备份数据,包括 Label 名称与备份时间等-f :后面接的就是备份档<span class="token operator">!</span>企业界很有可能会接 /dev/st0 等磁带机<span class="token operator">!</span>我们这里接档名<span class="token operator">!</span>-L :就是 Session 的 Label name 喔<span class="token operator">!</span>可用 -I 查询到的数据,在这个选项后输入<span class="token operator">!</span>-s :需要接某特定目录,亦即仅复原某一个文件或目录之意<span class="token operator">!</span>-r :如果是用文件来储存备份数据,那这个就不需要使用。如果是一个磁带内有多个文件,需要这东西来达成累积复原-i:进入互动模式,进阶管理员使用的<span class="token operator">!</span>一般我们不太需要操作它<span class="token operator">!</span></code></pre><ul><li>用 xfsrestore 观察 xfsdump 后的备份数据内容<pre class=" language-bash"><code class="language-bash">$ xfsrestore -I</code></pre></li><li>简单复原 level 0 的文件系统<pre class=" language-bash"><code class="language-bash">$ xfsrestore -f /srv/boot.dump -L boot_all /boot<span class="token comment" spellcheck="true"># 直接复原的结果就是:『同名的文件会被覆盖,其他系统内新的文件会被保留』</span><span class="token comment" spellcheck="true"># 仅复原备份档内的 grub2 到 /tmp/boot2/ 里头去!</span>$ <span class="token function">mkdir</span> /tmp/boot2$ xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2</code></pre></li><li>复原累积备份资料<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 继续复原 level 1 到 /tmp/boot 当中!</span>$ xfsrestore -f /srv/boot.dump1 /tmp/boot</code></pre></li><li>仅还原部分文件的 xfsrestore 互动模式<br>```bash<h1 id="1-先进入备份文件内-准备找出需要备份的文件名数据-同时预计还原到-tmp-boot3-当中"><a href="#1-先进入备份文件内-准备找出需要备份的文件名数据-同时预计还原到-tmp-boot3-当中" class="headerlink" title="1. 先进入备份文件内,准备找出需要备份的文件名数据,同时预计还原到 /tmp/boot3 当中!"></a>1. 先进入备份文件内,准备找出需要备份的文件名数据,同时预计还原到 /tmp/boot3 当中!</h1>$ mkdir /tmp/boot3<br>$ xfsrestore -f /srv/boot.dump -i /tmp/boot3<br>========================== subtree selection dialog ==========================the following commands are available:<br>pwd<br>ls [ <path> ]<br>cd [ <path> ]<br>add [ <path> ] # 可以加入复原文件列表中<br>delete [ <path> ] # 从复原列表拿掉档名!并非删除喔!<br>extract # 开始复原动作!<br>quit<br>help</path></path></path></path></li></ul><p>-&gt; ls<br>455517 initramfs-3.10.0-229.el7.x86_64kdump.img<br>138 initramfs-3.10.0-229.el7.x86_64.img<br>141 initrd-plymouth.img<br>140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a<br>139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img<br>137 vmlinuz-3.10.0-229.el7.x86_64<br>136 symvers-3.10.0-229.el7.x86_64.gz<br>133 .vmlinuz-3.10.0-229.el7.x86_64.hmac<br>1048704 grub2/<br>131 grub/<br>-&gt; add grub<br>-&gt; add grub2<br>-&gt; add config-3.10.0-229.el7.x86_64<br>-&gt; extract<br>$ ls -l /tmp/boot3<br>-rw-r–r–. 1 root root 123838 Mar 6 19:45 config-3.10.0-229.el7.x86_64<br>drwxr-xr-x. 2 root root 4 17:52 grub<br>drwxr-xr-x. 6 root root<br>26 May<br>104 Jun 25 00:02 grub2</p><h1 id="就只会有-3-个档名被复原-当然-如果文件名是目录-那底下的子文件当然也会被还原回来的"><a href="#就只会有-3-个档名被复原-当然-如果文件名是目录-那底下的子文件当然也会被还原回来的" class="headerlink" title="就只会有 3 个档名被复原,当然,如果文件名是目录,那底下的子文件当然也会被还原回来的!"></a>就只会有 3 个档名被复原,当然,如果文件名是目录,那底下的子文件当然也会被还原回来的!</h1><pre><code>事实上,这个 -i 是很有帮助的一个项目!可以从备份档里面找出你所需要的数据来复原!相当有趣!当然啦, 如果你已经知道档名,使用 -s 不需要进入备份档就能够处理掉这部份了!#### 光盘写入工具+ 现将数据创建为一个镜像文件（iso），利用mkisofs命令处理+ 将该镜像文件刻录至CD或DVD当中，利用cdrecord命令来处理##### mkisofs：建立镜像文件+ 制作一般数据光盘镜像文件```bashmkisofs [-o 镜像文件] [-Jrv] [-V vol] [-m file] 待备份文件... -graft-point isodir=systemdir ...选项与参数:-o :后面接你想要产生的那个镜像文件。-J :产生较兼容于 windows 机器的文件名结构,可增加文件名长度到 64 个 unicode 字符-r :透过 Rock Ridge 产生支持 Unix/Linux 的文件数据,可记录较多的信息(如 UID/GID 等) ;-v :显示创建 ISO 文件的过程-V vol :建立 Volume,有点像 Windows 在文件资源管理器中看到的CD卷标-m file：-m 为排除文件的意思后面的文件不备份到镜像文件中,也能使用 * 通配符喔-graft-point:graft 有转嫁或移植的意思,相关资料在底下文章内说明。</code></pre><p><strong><em>光盘的格式一般称为 iso9660 ,这种格式一般仅支持旧版的 DOS 文件名,亦即文件<br>名只能以 8.3 (文件名 8 个字符,扩展名 3 个字符) 的方式存在。</em></strong> 可以-r来记录更多。<br><strong><em>所有要被加到镜像文件中的文件都会被放置到镜像文件中的根目录</em></strong></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkisofs</span> -r -v -o /tmp/system.img /root /home /etcI: -input-charset not specified, using utf-8 <span class="token punctuation">(</span>detected <span class="token keyword">in</span> locale settings<span class="token punctuation">)</span>genisoimage 1.1.11 <span class="token punctuation">(</span>Linux<span class="token punctuation">)</span>Scanning /root<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">(</span>中间省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.Scanning /etc/scl/prefixes<span class="token comment" spellcheck="true"># 被改名子了!</span>Using SYSTE000.<span class="token punctuation">;</span>1 <span class="token keyword">for</span> /system-release-cpe <span class="token punctuation">(</span>system-release<span class="token punctuation">)</span>Using CENTO000.<span class="token punctuation">;</span>1 <span class="token keyword">for</span> /centos-release-upstream <span class="token punctuation">(</span>centos-release<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 被改名子了!</span>Using CRONT000.<span class="token punctuation">;</span>1 <span class="token keyword">for</span> /crontab <span class="token punctuation">(</span>crontab<span class="token punctuation">)</span>genisoimage: Error: <span class="token string">'/etc/crontab'</span> and <span class="token string">'/root/crontab'</span> have the same Rock Ridge name <span class="token string">'crontab'</span><span class="token keyword">.</span><span class="token comment" spellcheck="true"># 文件名不可一样啊!</span>Unable to <span class="token function">sort</span> directoryNOTE: multiple <span class="token function">source</span> directories have been specified and merged into the rootof the filesystem. Check your program arguments. genisoimage is not tar.<span class="token comment" spellcheck="true"># 看到没?因为档名一模一样,所以就不给你建立 ISO 檔了啦!</span><span class="token comment" spellcheck="true"># 请先删除 /root/crontab 这个文件,然后再重复执行一次 mkisofs 吧!</span>$ <span class="token function">rm</span> /root/crontab$ <span class="token function">mkisofs</span> -r -v -o /tmp/system.img /root /home /etc<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">(</span>前面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.83.91% done, estimate finish Thu Jul 2 18:48:04 201592.29% done, estimate finish Thu Jul 2 18:48:04 2015Total translation table size: 0Total rockridge attributes bytes: 600251Total directory bytes: 2150400Path table size<span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>: 12598Done with: The File<span class="token punctuation">(</span>s<span class="token punctuation">)</span> Block<span class="token punctuation">(</span>s<span class="token punctuation">)</span>Writing: Start Block 59449Ending PadblockDone with: Ending PadblockBlock<span class="token punctuation">(</span>s<span class="token punctuation">)</span>58329150Max brk space used 54800059599 extents written <span class="token punctuation">(</span>116 MB<span class="token punctuation">)</span>$ ll -h /tmp/system.img-rw-r--r--. 1 root root 117M Jul2 18:48 /tmp/system.img$ <span class="token function">mount</span> -o loop /tmp/system.img /mnt$ <span class="token function">df</span> -h /mntFilesystemSizeUsed Avail Use% Mounted on/dev/loop0117M117M0 100% /mnt$ <span class="token function">ls</span> /mntabrt festival mail.rc rsyncd.confadjtime filesystems makedumpfile.conf.sample rsyslog.confalex firewalld man_db.conf rsyslog.d<span class="token comment" spellcheck="true"># 看吧!一堆数据都放置在一起!包括有的没有的目录与文件等等!</span>$ <span class="token function">umount</span> /mnt<span class="token comment" spellcheck="true"># 测试完毕要记得卸除!</span>这样可以使用-graft-point来处理​```bash$ <span class="token function">mkisofs</span> -r -V <span class="token string">'linux_file'</span> -o /tmp/system.img \<span class="token operator">></span>-m /root/etc -graft-point /root<span class="token operator">=</span>/root /home<span class="token operator">=</span>/home /etc<span class="token operator">=</span>/etc$ ll -h /tmp/system.img-rw-r--r--. 1 root root 92M Jul2 19:00 /tmp/system.img<span class="token comment" spellcheck="true"># 上面的指令会建立一个大文件,其中 -graft-point 后面接的就是我们要备份的数据。</span><span class="token comment" spellcheck="true"># 必须要注意的是那个等号的两边,等号左边是在映像文件内的目录,右侧则是实际的数据。</span>$ <span class="token function">mount</span> -o loop /tmp/system.img /mnt$ ll /mntdr-xr-xr-x. 131 root root 34816 Jun 26 22:14 etcdr-xr-xr-x. 5 root root 2048 Jun 17 00:20 homedr-xr-xr-x. 8 root root 4096 Jul2 18:48 root<span class="token comment" spellcheck="true"># 瞧!数据是分门别类的在各个目录中喔这样了解乎?最后将数据卸除一下:</span>$ <span class="token function">umount</span> /mnt</code></pre><ul><li>制作/修改课启动光盘镜像文件<br>```bash<h1 id="1-先观察一下这片光盘里面有啥东西-是否是我们需要的光盘系统"><a href="#1-先观察一下这片光盘里面有啥东西-是否是我们需要的光盘系统" class="headerlink" title="1. 先观察一下这片光盘里面有啥东西?是否是我们需要的光盘系统!"></a>1. 先观察一下这片光盘里面有啥东西?是否是我们需要的光盘系统!</h1>$ isoinfo -d -i /home/CentOS-7-x86_64-Minimal-1503-01.iso<br>CD-ROM is in ISO 9660 format<br>System id: LINUX<br>Volume id: CentOS 7 x86_64<br>Volume set id:<br>Publisher id:<br>Data preparer id:<br>Application id: GENISOIMAGE ISO 9660/HFS FILESYSTEM CREATOR (C) 1993 E.YOUNGDALE (C) …<br>Copyright File id:<br>…..(中间省略)…..<br>Eltorito defaultboot header:<br>Bootid 88 (bootable)<br>Boot media 0 (No Emulation Boot)<br>Load segment 0<br>Sys type 0<br>Nsect 4<h1 id="2-开始挂载这片光盘到-mnt-并且将所有数据完整复制到-srv-newcd-目录去喔"><a href="#2-开始挂载这片光盘到-mnt-并且将所有数据完整复制到-srv-newcd-目录去喔" class="headerlink" title="2. 开始挂载这片光盘到 /mnt ,并且将所有数据完整复制到 /srv/newcd 目录去喔"></a>2. 开始挂载这片光盘到 /mnt ,并且将所有数据完整复制到 /srv/newcd 目录去喔</h1>$ mount /home/CentOS-7-x86_64-Minimal-1503-01.iso /mnt<br>$ mkdir /srv/newcd<br>$ rsync -a /mnt/ /srv/newcd<br>$ ll /srv/newcd/</li></ul><p>-rw-r–r–. 1 root root 16 Apr<br>1 07:11 CentOS_BuildTag<br>drwxr-xr-x. 3 root root 33 Mar 28 06:34 EFI<br>-rw-r–r–. 1 root root 215 Mar 28 06:36 EULA<br>-rw-r–r–. 1 root root 18009 Mar 28 06:36 GPL<br>drwxr-xr-x. 3 root root 54 Mar 28 06:34 images<br>drwxr-xr-x. 2 root root 4096 Mar 28 06:34 isolinux<br>drwxr-xr-x. 2 root root 41 Mar 28 06:34 LiveOS<br>drwxr-xr-x. 2 root root 20480 Apr<br>1 07:11 Packages<br>drwxr-xr-x. 2 root root 4096 Apr<br>1 07:11 repodata<br>-rw-r–r–. 1 root root 1690 Mar 28 06:36 RPM-GPG-KEY-CentOS-7<br>-rw-r–r–. 1 root root 1690 Mar 28 06:36 RPM-GPG-KEY-CentOS-Testing-7<br>-r–r–r–. 1 root root 2883 Apr<br>1 07:15 TRANS.TBL</p><h1 id="rsync-可以完整的复制所有的权限属性等数据-也能够进行镜像处理-相当好用的指令喔"><a href="#rsync-可以完整的复制所有的权限属性等数据-也能够进行镜像处理-相当好用的指令喔" class="headerlink" title="rsync 可以完整的复制所有的权限属性等数据,也能够进行镜像处理!相当好用的指令喔!"></a>rsync 可以完整的复制所有的权限属性等数据,也能够进行镜像处理!相当好用的指令喔!</h1><h1 id="这里先了解一下即可。现在-newcd-目录内已经是完整的映像档内容-3-假设已经处理完毕你在-srv-newcd-里面所要进行的各项修改行为-准备建立-ISO-檔"><a href="#这里先了解一下即可。现在-newcd-目录内已经是完整的映像档内容-3-假设已经处理完毕你在-srv-newcd-里面所要进行的各项修改行为-准备建立-ISO-檔" class="headerlink" title="这里先了解一下即可。现在 newcd/ 目录内已经是完整的映像档内容!# 3. 假设已经处理完毕你在 /srv/newcd 里面所要进行的各项修改行为,准备建立 ISO 檔!"></a>这里先了解一下即可。现在 newcd/ 目录内已经是完整的映像档内容!# 3. 假设已经处理完毕你在 /srv/newcd 里面所要进行的各项修改行为,准备建立 ISO 檔!</h1><p>$ ll /srv/newcd/isolinux/<br>-r–r–r–. 1 root root<br>2048 Apr<br>1 07:15 boot.cat<br>-rw-r–r–. 1 root root 84 Mar 28 06:34 boot.msg<br>-rw-r–r–. 1 root root 281 Mar 28 06:34 grub.conf</p><h1 id="开机的型号数据等等"><a href="#开机的型号数据等等" class="headerlink" title="开机的型号数据等等"></a>开机的型号数据等等</h1><p>-rw-r–r–. 1 root root 35745476 Mar 28 06:31 initrd.img<br>-rw-r–r–. 1 root root 24576 Mar 28 06:38 isolinux.bin<br>-rw-r–r–. 1 root root 3032 Mar 28 06:34 isolinux.cfg<br>-rw-r–r–. 1 root root 176500 Sep 11<br>-rw-r–r–. 1 root root 186 Jul<br>-r–r–r–. 1 root root 2438 Apr<br>2</p><h1 id="相当于开机管理程序"><a href="#相当于开机管理程序" class="headerlink" title="相当于开机管理程序"></a>相当于开机管理程序</h1><p>2014 memtest<br>2014 splash.png<br>1 07:15 TRANS.TBL<br>-rw-r–r–. 1 root root 33997348 Mar 28 06:33 upgrade.img<br>-rw-r–r–. 1 root root 153104 Mar<br>-rwxr-xr-x. 1 root root 5029136 Mar<br>6 13:46 vesamenu.c32<br>6 19:45 vmlinuz</p><h1 id="Linux-核心文件"><a href="#Linux-核心文件" class="headerlink" title="Linux 核心文件"></a>Linux 核心文件</h1><p>$ cd /srv/newcd<br>[root@study newcd]# mkisofs -o /custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat \</p><blockquote><p>-no-emul-boot -V ‘CentOS 7 x86_64’ -boot-load-size 4 -boot-info-table -R -J -v -T .</p></blockquote><pre><code>##### cdrecord：光盘刻录工具现在一般使用wodim来刻录```bash$ wodim --devices dev=/dev/sr0... &lt;==查询刻录机的 BUS 位置$ wodim -v dev=/dev/sr0 blank=[fast|all] &lt;==抹除重复读写片$ wodim -v dev=/dev/sr0 -format &lt;==格式化 DVD+RW$ wodim -v dev=/dev/sr0 [可用选项功能] file.iso选项与参数:--devices :用在扫瞄磁盘总线并找出可用的刻录机,后续的装置为 ATA 接口-v :在 cdrecord 运作的过程中,显示过程而已。dev=/dev/sr0 :可以找出此光驱的 bus 地址,非常重要!blank=[fast|all]:blank 为抹除可重复写入的 CD/DVD-RW,使用 fast 较快,all 较完整-format:对光盘片进行格式化,但是仅针对 DVD+RW 这种格式的 DVD 而已;[可用选项功能] 主要是写入 CD/DVD 时可使用的选项,常见的选项包括有:-data:指定后面的文件以数据格式写入,不是以 CD 音轨(-audio)方式写入!speed=X :指定刻录速度,例如 CD 可用 speed=40 为 40 倍数,DVD 则可用 speed=4 之类-eject :指定刻录完毕后自动退出光盘fs=Ym :指定多少缓冲存储器,可用在将映像档先暂存至缓冲存储器。预设为 4m,一般建议可增加到 8m ,不过,还是得视你的刻录机而定。针对 DVD 的选项功能:driveropts=burnfree :打开 Buffer Underrun Free 模式的写入功能-sa:支持 DVD-RW 的格式</code></pre><ul><li><p>侦测你的刻录机所在位置:</p><pre class=" language-bash"><code class="language-bash">$ ll /dev/sr0brw-rw----+ 1 root cdrom 11, 0 Jun 26 22:14 /dev/sr0 <span class="token comment" spellcheck="true">#一般 Linux 光驱文件名!</span>$ wodim --devices dev<span class="token operator">=</span>/dev/sr0-------------------------------------------------------------------------0dev<span class="token operator">=</span><span class="token string">'/dev/sr0'</span>rwrw-- <span class="token keyword">:</span> <span class="token string">'QEMU'</span> <span class="token string">'QEMU DVD-ROM'</span>-------------------------------------------------------------------------$ wodim --devices dev<span class="token operator">=</span>/dev/sr0wodim: Overview of accessible drives <span class="token punctuation">(</span>1 found<span class="token punctuation">)</span> <span class="token keyword">:</span>-------------------------------------------------------------------------0dev<span class="token operator">=</span><span class="token string">'/dev/sr0'</span>rwrw-- <span class="token keyword">:</span> <span class="token string">'ASUS'</span> <span class="token string">'DRW-24D1ST'</span>-------------------------------------------------------------------------</code></pre></li></ul><ul><li>进行cd/dvd的刻录<br>```bash<h1 id="0-先抹除光盘的原始内容-非可重复读写则可略过此步骤"><a href="#0-先抹除光盘的原始内容-非可重复读写则可略过此步骤" class="headerlink" title="0. 先抹除光盘的原始内容:(非可重复读写则可略过此步骤)"></a>0. 先抹除光盘的原始内容:(非可重复读写则可略过此步骤)</h1>$ wodim -v dev=/dev/sr0 blank=fast<h1 id="中间会跑出一堆讯息告诉你抹除的进度-而且会有-10-秒钟的时间等待你的取消"><a href="#中间会跑出一堆讯息告诉你抹除的进度-而且会有-10-秒钟的时间等待你的取消" class="headerlink" title="中间会跑出一堆讯息告诉你抹除的进度,而且会有 10 秒钟的时间等待你的取消!"></a>中间会跑出一堆讯息告诉你抹除的进度,而且会有 10 秒钟的时间等待你的取消!</h1><h1 id="1-开始刻录"><a href="#1-开始刻录" class="headerlink" title="1. 开始刻录:"></a>1. 开始刻录:</h1>$ wodim -v dev=/dev/sr0 speed=4 -dummy -eject /tmp/system.img<br>….(前面省略)….<br>Waiting for reader process to fill input buffer … input buffer ready.<br>Starting new track at sector: 0<br>Track 01:<br>86 of<br>86 MB written (fifo 100%) [buf<br>97%]</li></ul><p>4.0x.</p><h1 id="这里有流程时间"><a href="#这里有流程时间" class="headerlink" title="这里有流程时间!"></a>这里有流程时间!</h1><p>Track 01: Total bytes read/written: 90937344/90937344 (44403 sectors).<br>Writing<br>time:</p><h1 id="写入的总时间"><a href="#写入的总时间" class="headerlink" title="写入的总时间"></a>写入的总时间</h1><p>38.337s<br>Average write speed</p><h1 id="换算下来的写入时间"><a href="#换算下来的写入时间" class="headerlink" title="换算下来的写入时间"></a>换算下来的写入时间</h1><p>1.7x.<br>Min drive buffer fill was 97%<br>Fixating…<br>Fixating time:<br>120.943s<br>wodim: fifo had 1433 puts and 1433 gets.<br>wodim: fifo was 0 times empty and 777 times full, min fill was 89%.</p><h1 id="因为有加上-eject-这个选项的缘故-因此刻录完成后-DVD-会被退出光驱喔-记得推回去"><a href="#因为有加上-eject-这个选项的缘故-因此刻录完成后-DVD-会被退出光驱喔-记得推回去" class="headerlink" title="因为有加上 -eject 这个选项的缘故,因此刻录完成后,DVD 会被退出光驱喔!记得推回去!"></a>因为有加上 -eject 这个选项的缘故,因此刻录完成后,DVD 会被退出光驱喔!记得推回去!</h1><h1 id="2-刻录完毕后-测试挂载一下-检验内容"><a href="#2-刻录完毕后-测试挂载一下-检验内容" class="headerlink" title="2. 刻录完毕后,测试挂载一下,检验内容:"></a>2. 刻录完毕后,测试挂载一下,检验内容:</h1><p>$ mount /dev/sr0/mnt<br>$ df -h /mnt<br>Filesystem<br>Filesystem<br>/dev/sr0<br>Size<br>Size<br>Used Avail Use% Mounted on<br>Used Avail Use% Mounted on<br>87M<br>87M<br>0 100% /mnt<br>$ ll /mnt<br>dr-xr-xr-x. 135 root root 36864 Jun 30 04:00 etc<br>dr-xr-xr-x.<br>19 root root<br>$ umount /mnt<br>8192 Jul<br>2 13:16 root<br>&lt;==不要忘了卸除</p><pre><code>#### 其他常见的压缩与备份工具停下你的dd行为##### dd```bash$ dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;block_size&quot; count=&quot;number&quot;选项与参数：if ： 就是input file，也可以是设备of ： 就是output file，也可以是设备bs ： 设置一个block的大小，默认512bytes（一个扇区）count ： 多少个bs的意思$ dd if=/etc/passwd of=/tmp/passwd.back #将镜像文件写入u盘5+1 records in5+1 records out2580 bytes (2.6 kB, 2.5 KiB) copied, 0.000205157 s, 12.6 MB/s$ ll /etc/passwd /tmp/passwd.back-rw-r--r-- 1 root  root  2580 3月  27 21:47 /etc/passwd-rw-r--r-- 1 jason jason 2580 4月  23 22:28 /tmp/passwd.back$ dd if=/dev/sr0 of=/tmp/system.iso #备份数据为镜像文件$ lsblk /dev/sda$ dd if=/tmp/system.iso of=/dev/sda$ mount /dev/sda /mnt$ ll /mnt$ df -h /boot$ dd if=/dev/vd2 of /tmp/vda2.img #将/boot整个文件系统备份下来$ ll -h /tmp/vda2.img</code></pre><p>dd是很笨拙的一个一个扇区去读写的，那这个其实非常nice啊，复制文件系统就可以使用</p><h5 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h5><p>cpio可以备份一切东西，但是需要配合find等命令进行重定向。</p><pre class=" language-bash"><code class="language-bash">$ cpio -ovcB  <span class="token operator">></span> <span class="token punctuation">[</span>file<span class="token operator">|</span>device<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#备份</span>$ cpio -ivcdu <span class="token operator">&lt;</span> <span class="token punctuation">[</span>file<span class="token operator">|</span>device<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#还原</span>$ cpio -ivct  <span class="token operator">&lt;</span> <span class="token punctuation">[</span>file<span class="token operator">|</span>device<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#查看</span>备份会使用到的选项与参数:-o :将数据 copy 输出到文件或装置上-B :让预设的 Blocks 可以增加至 5120 bytes ,预设是 512 bytes <span class="token operator">!</span>这样的好处是可以让大文件的储存速度加快<span class="token punctuation">(</span>请参考 i-nodes 的观念<span class="token punctuation">)</span>还原会使用到的选项与参数:-i :将数据自文件或装置 copy 出来系统当中-d :自动建立目录<span class="token operator">!</span>使用 cpio 所备份的数据内容不见得会在同一层目录中,因此我们必须要让 cpio 在还原时可以建立新目录,此时就得要 -d 选项的帮助<span class="token operator">!</span>-u :自动的将较新的文件覆盖较旧的文件<span class="token operator">!</span>-t :需配合 -i 选项,可用在<span class="token string">"察看"</span>以 cpio 建立的文件或装置的内容一些可共享的选项与参数:-v :让储存的过程中文件名可以在屏幕上显示-c :一种较新的 portable <span class="token function">format</span> 方式储存</code></pre><p>将/boot的文件备份到/tmp/boot.cpio中</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> /$ <span class="token function">find</span> boot -print$ <span class="token function">find</span> boot <span class="token operator">|</span> cpio -ovcB <span class="token operator">></span> /tmp/boot.cpio$ ll -h /tmp/boot.cpio-rw-r--r-- 1 jason jason 119M 4月  23 23:13 /tmp/boot.cpio$ <span class="token function">file</span> /tmp/boot/cpio /tmp/boot.cpio: ASCII cpio archive <span class="token punctuation">(</span>pre-SVR4 or odc<span class="token punctuation">)</span></code></pre><p>这里我们一开始是先转入根目录然后操作 <strong><em>因为cpio命令如果加上绝对路径的开头，那解开的时候，就会覆盖掉原本的/boot</em></strong></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~$ cpio -idvc <span class="token operator">&lt;</span> /tmp/boot.cpio$ ll /root/boot</code></pre><p>cpio命令也可用于磁带</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">find</span> / <span class="token operator">|</span> cpio -ovcB <span class="token operator">></span> /dev/st0$ cpio -idvc <span class="token operator">&lt;</span> /dev/st0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux下一切都是文件，所以其实不同压缩文件的的文件扩展名对于Linux来说并没有什么区别，但是可以方便系统的操作这也就是方便人类阅读和管理。&lt;/p&gt;
&lt;h4 id=&quot;压缩文件的用途与技术&quot;&gt;&lt;a href=&quot;#压缩文件的用途与技术&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="软件工具" scheme="http://jinzhengxu.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://jinzhengxu.github.io/tags/Linux/"/>
    
      <category term="文件压缩" scheme="http://jinzhengxu.github.io/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下fcitx增添词库</title>
    <link href="http://jinzhengxu.github.io/2019/04/17/ubuntu-xia-fcitx-zeng-tian-ci-ku/"/>
    <id>http://jinzhengxu.github.io/2019/04/17/ubuntu-xia-fcitx-zeng-tian-ci-ku/</id>
    <published>2019-04-17T13:46:51.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<p>为了使用atom真的是大费周章，因为atom貌似不是KDE的环境，所以在屏幕下方使用sougoupinyin时，会出现候选框跑到屏幕外面的情况，这就很难受。(这是因为qimpanel不支持这种桌面环境？）</p><p>不管怎样，atom的片段功能实在是好用，所以权衡一下，hello google，goodbye sougou。但是google拼音的词库是依托于fcitx的，词库源很少而且并不好用，所以这里我们就来为fcitx添加词库。</p><h4 id="下载词库"><a href="#下载词库" class="headerlink" title="下载词库"></a>下载词库</h4><p>首先新建一个文件夹来保存我们想要的词库，然后在<a href="https://pinyin.sogou.com/dict/" target="_blank" rel="noopener">搜狗拼音官网</a>下载细胞词库，将下载的词库放入该文件夹中。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ./Doucments$ <span class="token function">mkdir</span> ./dict/$ <span class="token function">cp</span> *.scel ~/Documents/dict/ <span class="token comment" spellcheck="true">#这步操作在下载文件夹下执行</span>$ <span class="token function">rm</span> *.scel <span class="token comment" spellcheck="true">#这步操作在下载文件夹下执行</span></code></pre><p>意外的发现了很多优秀词库啊<br><img src="https://s2.ax1x.com/2019/04/18/ESUjqU.png" alt="ESUjqU.png"></p><h4 id="转为-org-格式"><a href="#转为-org-格式" class="headerlink" title="转为 org 格式"></a>转为 org 格式</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ./Doucments/dict/$ <span class="token function">mkdir</span> org$ <span class="token function">find</span> <span class="token keyword">.</span> -name <span class="token string">'*.scel'</span> -exec scel2org -o org/<span class="token punctuation">{</span><span class="token punctuation">}</span>.org <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span></code></pre><h4 id="合并所有org文件"><a href="#合并所有org文件" class="headerlink" title="合并所有org文件"></a>合并所有org文件</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> dict$ <span class="token function">cd</span> dict$ <span class="token function">cat</span> <span class="token punctuation">..</span>/org/*.scel.org <span class="token operator">></span> 1.org</code></pre><h4 id="复制fcitx的基础词库"><a href="#复制fcitx的基础词库" class="headerlink" title="复制fcitx的基础词库"></a>复制fcitx的基础词库</h4><p>这里说明一下，我之复制了搜狗标准词库，因为fcitx的词库感觉里面的候选词都很鬼畜，但是我也会列出如何复制fcitx的词库。</p><h5 id="准备必要的两个文件"><a href="#准备必要的两个文件" class="headerlink" title="准备必要的两个文件"></a>准备必要的两个文件</h5><p>从这里下载<a href="http://code.google.com/p/fcitx/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/fcitx/downloads/list</a>fcitx-4.xx_dict.rat.gz词库文件</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">tar</span> xf fcitx-4.2.7_dict.tar.xz fcitx-4.2.7/data/<span class="token punctuation">{</span>pinyin.tar.gz,gbkpy.org<span class="token punctuation">}</span>$ <span class="token function">tar</span> xf fcitx-4.2.7/data/pinyin.tar.gz$ <span class="token function">mv</span> fcitx-4.2.7/data/gbkpy.org ./</code></pre><h5 id="合并-fcitx-基础词库"><a href="#合并-fcitx-基础词库" class="headerlink" title="合并 fcitx 基础词库"></a>合并 fcitx 基础词库</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> pyPhrase.org <span class="token operator">>></span>1.org</code></pre><p>排序、去重、生成词库</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sort</span> 1.org <span class="token operator">></span>2.org$ <span class="token function">uniq</span> 2.org <span class="token operator">></span>3.org$ createPYMB gbkpy.org 3.orgGroups: 412Start Loading Phrase<span class="token punctuation">..</span>.225832 Phrases, 225831 Converted<span class="token operator">!</span>Writing Phrase <span class="token function">file</span> <span class="token punctuation">..</span>.OK<span class="token operator">!</span></code></pre><h5 id="结果文件"><a href="#结果文件" class="headerlink" title="结果文件:"></a>结果文件:</h5><pre><code>pyERROR 词库中重复或有其它问题条目，有兴趣可参考，没事直接忽略pyPhrase.ok 除错后的无错的 org 格式词库，可取代 3.org 而保留供下次使用pyphrase.mb 最终词库，必须，用于覆盖原文件pybase.mb 配套的字码库，必须，用于覆盖原文件</code></pre><h4 id="覆盖本地的词库文件"><a href="#覆盖本地的词库文件" class="headerlink" title="覆盖本地的词库文件"></a>覆盖本地的词库文件</h4><p>解压后，复制两 .mb 文件至 /usr/share/fcitx/data/ 或 /usr/share/fcitx/pinyin/ 覆盖原文件，或置于 ~/.config/fcitx/ 或 ~/.config/fcitx/pinyin/ 之中。这里要注意的是本地词库中也有同名的两个文件所以，一定要记得加上-f选项，否则不会生效。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">su</span>$ <span class="token function">cp</span> -f pybase.mb /usr/share/fcitx/pinyin/$ <span class="token function">cp</span> -f pyphrase.mb /usr/share/fcitx/pinyin/</code></pre><p>然后就可以reboot重启，或者kill掉fcitx进程并重启。</p><p>重启之后，对照<code>3.org</code>文件的内容，打几个词自看看是否一致，如果候选词出现就是配置完成了！</p><h4 id="开启云拼音"><a href="#开启云拼音" class="headerlink" title="开启云拼音"></a>开启云拼音</h4><p>本地词库再丰富，也不如网络上实时更新的云词库内容的更新速度。</p><p>终端安装插件</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> fcitx-module-cloudpinyin$ fcitx-configtool</code></pre><p>打开以后将源换到百度就可以正常使用了。<br><img src="https://s2.ax1x.com/2019/04/18/ES0Dyt.png" alt="ES0Dyt.png"></p><h4 id="rime"><a href="#rime" class="headerlink" title="rime"></a>rime</h4><p>发现了一个十分好用的输入法</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> fcitx-rime</code></pre><p>就可以使用了，中州韵真香。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了使用atom真的是大费周章，因为atom貌似不是KDE的环境，所以在屏幕下方使用sougoupinyin时，会出现候选框跑到屏幕外面的情况，这就很难受。(这是因为qimpanel不支持这种桌面环境？）&lt;/p&gt;
&lt;p&gt;不管怎样，atom的片段功能实在是好用，所以权衡一下，
      
    
    </summary>
    
      <category term="软件工具" scheme="http://jinzhengxu.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://jinzhengxu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《现代编译原理-C语言描述》（5）- 语义分析</title>
    <link href="http://jinzhengxu.github.io/2019/04/16/xian-dai-bian-yi-yuan-li-c-yu-yan-miao-shu-5/"/>
    <id>http://jinzhengxu.github.io/2019/04/16/xian-dai-bian-yi-yuan-li-c-yu-yan-miao-shu-5/</id>
    <published>2019-04-16T03:30:25.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>语义的（se-man-tic）:与语言表达的含义相关的。<br>—-韦氏词典</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;语义的（se-man-tic）:与语言表达的含义相关的。&lt;br&gt;—-韦氏词典&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="底层" scheme="http://jinzhengxu.github.io/categories/%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="虎书" scheme="http://jinzhengxu.github.io/tags/%E8%99%8E%E4%B9%A6/"/>
    
      <category term="编译原理" scheme="http://jinzhengxu.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="现代编译原理" scheme="http://jinzhengxu.github.io/tags/%E7%8E%B0%E4%BB%A3%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>睡眠排序</title>
    <link href="http://jinzhengxu.github.io/2019/04/14/shui-mian-pai-xu/"/>
    <id>http://jinzhengxu.github.io/2019/04/14/shui-mian-pai-xu/</id>
    <published>2019-04-14T12:46:44.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<p>在SS算法中，我们为输入数组中的每个元素创建不同的线程，然后每个线程休眠一段时间，该时间量与相应的数组元素的值成比例。</p><p>因此，最少睡眠时间的线程将首先被唤醒并且打印出来，然后是第二最小元素，依此类推。最长的元素在最后醒来，然后元素在最后被打印出来。因此输出是有序的。</p><p>所有这些多线程过程都发生在后台和操作系统的核心。我们对背景中发生的事情一无所知，因此这是一种“神秘”的排序算法。</p><p><strong>示例</strong>：假设(为方便起见)我们的计算机速度需要3秒才能完成对所有元素的排序：</p><pre><code>INPUT: 8 2 93s: sleep 86s: sleep 28s: &quot;2&quot; (2 wakes up so print it)9s: sleep 911s: &quot;8&quot; (8 wakes up so print it)18s: &quot;9&quot; (9 wakes up so print it)OUTPUT: 2 8 9</code></pre><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>为了实现sleep排序，我们需要调用多线程函数，例如<code>_beginthread()</code>和<code>WaitForMultipleObjects()</code>。因此我们需要包含<code>windows.h</code>来使用这些函数。我们必须在PC上运行它(注意这段代码是针对WINDOWS而不是针对LINUX)。</p><p>要执行睡眠排序，我们需要为输入数组中的每个值创建线程。我们使用<code>_beginthread()</code>函数执行此操作 。</p><p>在每个线程中，我们分配两个指令：</p><ul><li><p>睡眠：将此线程休眠直到<code>arr[i]</code>毫秒(其中<code>arr[i]</code>是与该线程关联的数组元素)。我们使用<code>Sleep()</code>函数执行此操作。<code>Sleep(n)</code>函数暂停与此线程关联的活动，直到’n’毫秒。因此，如果我们写<code>Sleep(1000)</code>，那么这意味着线程将休眠1秒(1000毫秒= 1秒)</p></li><li><p>打印：当线程在睡眠后’唤醒’然后打印数组元素与此线程关联的<code>arr[i]</code>。</p></li></ul><p>创建线程后，我们处理这些线程。我们使用<code>WaitForMultipleObjects()</code>来做到这一点。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// C implementation of Sleep Sort</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;windows.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;process.h></span></span><span class="token comment" spellcheck="true">// This is the instruction set of a thread</span><span class="token comment" spellcheck="true">// So in these threads, we "sleep" for a particular</span><span class="token comment" spellcheck="true">// amount of time and then when it wakes up</span><span class="token comment" spellcheck="true">// the number is printed out</span><span class="token keyword">void</span> <span class="token function">routine</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// typecasting from void to int</span>    <span class="token comment" spellcheck="true">// Sleeping time is proportional to the number</span>    <span class="token comment" spellcheck="true">// More precisely this thread sleep for 'n' milliseconds</span>    <span class="token function">Sleep</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// After the sleep, print the number</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* A function that performs sleep sort_beginthread() is a C run-time library call that creates a new'thread' for all the integers in the array and returns thatthread.Each of the 'thread' sleeps for a time proportional to thatinteger and print it after waking.We pass three parameters to _beginthread :-1) start_address --> start address of the routine/function                    which creates a new thread2) stack_size --> Stack Size of the new thread (which is 0)3) arglist --> Address of the argument to be passedThe return value of _beginthread() function is a handle to thethread which is created. So we must accept is using the datatype-'HANDLE' which is included in windows.h header'HANDLE' datatype is used to represent an event/thread/process etcSo 'HANDLE' datatype is used to define a threadWe store the threads in an array - threads[] which is declaredusing 'HANDLE' datatype.WaitForMultipleObjects() is a function that processes the threadsand has four arguments-1) no_of_threads --> Number of threads to be processed2) array_of_threads --> This is the array of threads which should be                        processed. This array must be of the type                        'HANDLE'3) TRUE or FALSE --> We pass TRUE if we want all the threads in the                    array to be processed4) time_limit --> The threads will be processed until this time limit                is crossed. So if we pass a 0 then no threads will                be processed, otherwise if we pass an INFINITE, then                the program will stop only when all the threads                are processed. We can put a cap on the execution                time of the program by passing the desired time                limit */</span><span class="token keyword">void</span> <span class="token function">sleepSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// An array of threads, one for each of the elements</span>    <span class="token comment" spellcheck="true">// in the input array</span>    HANDLE threads<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Create the threads for each of the input array elements</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span><span class="token function">_beginthread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>routine<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Process these threads</span>    <span class="token function">WaitForMultipleObjects</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> threads<span class="token punctuation">,</span> TRUE<span class="token punctuation">,</span> INFINITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Driver program to test above functions</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Doesn't work for negative numbers</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">122</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleepSort</span> <span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h6><p>1)此算法不适用于负数，因为线程无法在负时间内休眠。</p><p>2)由于该算法依赖于输入元素，因此输入数组中的大量数字导致该算法急剧减速(因为与该数字相关联的线程必须长时间休眠)。因此，即使输入数组元素仅包含2个元素，例如 -{1,100000000}，我们也必须等待更长的持续时间才能进行排序。</p><p>3)该算法每次都不产生正确的排序输出。这通常发生在输入数组中非常大的数字左边有一个非常小的数字时。<br>例如 - {34,23,1,12253,9}。<br>睡眠排序后的输出为{9,1,23,34,1223}</p><p>当输入数组最初反向排序时，也会出现错误的输出，例如 - {10,9,8,7,6,5}。</p><p>这种意外输出的原因是因为扫描每个元素以及一些其他OS操作(例如将每个线程插入优先级队列中进行调度)之间需要花费一些时间。我们不能简单地忽略这些事情所花费的时间。</p><p>我们使用下面的例子来描述这种情况，假设(为方便起见)我们的计算机速度需要3秒才能完成对所有元素的排序：</p><pre><code>INPUT: 10 9 8 7 6 53s: sleep 106s: sleep 99s: sleep 812s: sleep 713s: &quot;10&quot; (10 wakes up so print it)15s: sleep 615s: &quot;9&quot; (9 wakes up so print it)17s: &quot;8&quot; (8 wakes up so print it)18s: sleep 519s: &quot;7&quot; (7 wakes up so print it)21s: &quot;6&quot; (6 wakes up so print it)23s: &quot;5&quot; (5 wakes up so print it)OUTPUT: 10 9 8 7 6 5</code></pre><p>以上输出只是一个例子。<br>显然，现代计算机计算机并不是那么慢(需要3秒才能扫描每个元素)。<br>实际上，上面的输入在现代计算机上运行睡眠排序会产生输出 - {9,5,7,10,8,6}</p><h5 id="如何解决这个问题？"><a href="#如何解决这个问题？" class="headerlink" title="如何解决这个问题？"></a>如何解决这个问题？</h5><p>1)我们可以通过对新输出重复进行睡眠排序来解决此问题，直到输出变为排序。每次它都会更准确地对元素进行排序。</p><p>2)由于其他操作系统工作所花费的时间和扫描每个元素所发生的错误输出。</p><p>在我们的程序中，我们使用了函数<code>Sleep(arr[i])</code>，这意味着与数组元素相关联的每个线程都会休眠<code>arr[i]</code>毫秒。由于毫秒是一个非常小的数量，其他OS任务可能比<code>arr[i]</code>毫秒花费更多的时间，这最终可能导致睡眠排序错误。将睡眠时间增加10倍就可以提供排序输出，因为OS任务将在这么多睡眠之间完成所有任务，因此不会产生任何错误。</p><p>如果我们使用<code>Sleep(10 * arr[i])</code>而不是<code>Sleep(arr[i])</code>那么我们肯定会获得比后者更精确的输出。例如，输入数组 - {10,9,8,7,6,5}将给出正确的排序输出 - {5,6,7,8,9,10}如果我们使用<code>Sleep(10 * arr[i])</code>而不仅仅是睡眠<code>(arr[i])</code>秒。</p><p>但是，对于某些测试用例，<code>Sleep(10 * arr[i])</code>仍然可能会给出错误的结果。为了使它更精确，增加睡眠时间，比如<code>Slepp(20 * arr[i])</code>。</p><p>因此，结论就是睡眠时间越长，结果越准确。(听起来很有趣，嗯？)。但同样会增加此算法的运行时间。</p><h5 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h5><p>尽管关于睡眠排序的时间复杂性存在许多不同的观点，但我们可以使用以下推理来估计时间复杂度</p><p>由于<code>Sleep()</code>函数和创建多个线程是由OS在内部使用优先级队列(用于调度目的)完成的。因此，在优先级队列中插入所有数组元素需要 $O(Nlog N)$ 的时间。此外，只有在处理完所有线程时才获得输出，即当所有元素都被唤醒时。因为它需要 $O(arr[i])$ 时间来唤醒第i个数组元素的线程。因此，唤醒阵列的最大元素需要最多 $O(max(输入))$ 。因此，总时间复杂度可以假设为 $O(NlogN + max(输入))$ ，<br>其中，N =输入数组中元素的数量，输入=输入数组元素</p><h5 id="辅助空间"><a href="#辅助空间" class="headerlink" title="辅助空间"></a>辅助空间</h5><p>所有操作都由OS的内部优先级队列完成。因此可以忽略辅助空间。</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>睡眠排序与操作系统的关系比任何其他排序算法都要多。这种排序算法是OS完成的多线程和调度的完美演示。</p><h5 id="java-implementation"><a href="#java-implementation" class="headerlink" title="java implementation"></a>java implementation</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SleepSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        SleepSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span>nums<span class="token punctuation">)</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d   "</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        Sleeper<span class="token punctuation">.</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        Sleeper<span class="token punctuation">.</span>output<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//[1]</span>            <span class="token keyword">new</span> <span class="token class-name">Sleeper</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//[2]</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>Sleeper<span class="token punctuation">.</span>output<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Sleeper</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> output<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> idx<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> sleep_time<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Sleeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sleep_time<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Sleeper</span><span class="token punctuation">(</span><span class="token keyword">int</span> sleep_time<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sleep_time<span class="token operator">=</span>sleep_time<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sleep_time<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        output<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>sleep_time<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在SS算法中，我们为输入数组中的每个元素创建不同的线程，然后每个线程休眠一段时间，该时间量与相应的数组元素的值成比例。&lt;/p&gt;
&lt;p&gt;因此，最少睡眠时间的线程将首先被唤醒并且打印出来，然后是第二最小元素，依此类推。最长的元素在最后醒来，然后元素在最后被打印出来。因此输出是有
      
    
    </summary>
    
      <category term="程序设计" scheme="http://jinzhengxu.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="算法" scheme="http://jinzhengxu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://jinzhengxu.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>The Plan &amp; Diet</title>
    <link href="http://jinzhengxu.github.io/2019/04/09/the-plan-diet/"/>
    <id>http://jinzhengxu.github.io/2019/04/09/the-plan-diet/</id>
    <published>2019-04-09T11:24:12.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<p>数据：</p><table><thead><tr><th>体重</th><th>身高</th><th>体脂</th><th><a href="https://www.calculator.net/carbohydrate-calculator.html" target="_blank" rel="noopener">建议碳水</a></th></tr></thead><tbody><tr><td>67kg</td><td>175cm</td><td></td><td>276g-335g-379g</td></tr></tbody></table><p>训练表：</p><table><thead><tr><th>日期</th><th align="center">训练内容</th><th>饮食</th></tr></thead><tbody><tr><td>Day1</td><td align="center">顺风旗 60 + 举腿 120</td><td>Normal</td></tr><tr><td>Day2</td><td align="center">倒立20+倒立撑120</td><td>Normal</td></tr><tr><td>Day3</td><td align="center">击掌双力臂 20 + 负重双力臂 20 +  引体向上 65</td><td>Energy</td></tr><tr><td>Day4</td><td align="center">单杠臂屈伸 12*10 +爆发俯卧撑 30</td><td>Energy</td></tr><tr><td>Day5</td><td align="center">Burpee 200 + 慢跑</td><td>Normal</td></tr><tr><td>Day6</td><td align="center">引体向上 12*10 + 反手12*1 + 挺身引体12*1</td><td>Energy</td></tr><tr><td>Day7</td><td align="center">单杠臂屈伸 12 *10 + 窄距 12*2</td><td>Energy</td></tr></tbody></table><p>饮食表：</p><table><thead><tr><th>类别</th><th>早餐</th><th>午餐</th><th>晚餐</th><th>碳水统计</th><th>蛋白统计</th></tr></thead><tbody><tr><td>Normal</td><td>鸡胸肉100g + 黑麦面包100g（一把面条）</td><td>鸡胸肉100g + 164g面条</td><td>鸡胸肉100g + 164g面条</td><td>50g + 115g + 115g = 280g</td><td>30.7g×3+20g=112.1</td></tr><tr><td>Energy</td><td>鸡胸肉100g + 黑麦面包100g</td><td>鸡胸肉100g + 200g面条</td><td>鸡胸肉100g + 200g面条</td><td>50g + 140g + 140g + 15g = 350g</td><td>30.7g×3+24g=116.1</td></tr><tr><td>Normal</td><td>鸡胸肉100g + 燕麦90g（一把面条）</td><td>鸡胸肉100g + 205燕麦</td><td>鸡胸肉100g + 205g燕麦</td><td>50g + 115g + 115g = 280g</td><td>30.7g×3+20g=112.1</td></tr><tr><td>Energy</td><td>鸡胸肉100g + 燕麦90g</td><td>鸡胸肉100g + 250g面条</td><td>鸡胸肉100g + 250g面条</td><td>50g + 140g + 140g + 15g = 350g</td><td>30.7g×3+24g=116.1</td></tr><tr><td>Whatever</td><td>whatever</td><td>whatever</td><td>whatever</td><td></td><td></td></tr></tbody></table><p>食物碳水表：</p><table><thead><tr><th>名称</th><th>碳水/100g</th></tr></thead><tbody><tr><td>面条</td><td>70g</td></tr><tr><td>黑麦面包</td><td>50g</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;体重&lt;/th&gt;
&lt;th&gt;身高&lt;/th&gt;
&lt;th&gt;体脂&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;https://www.calculator.net/carbohydrate-calculator.html&quot; ta
      
    
    </summary>
    
      <category term="Workout" scheme="http://jinzhengxu.github.io/categories/Workout/"/>
    
    
      <category term="Calisthenics" scheme="http://jinzhengxu.github.io/tags/Calisthenics/"/>
    
      <category term="Diet" scheme="http://jinzhengxu.github.io/tags/Diet/"/>
    
  </entry>
  
  <entry>
    <title>《现代编译原理-C语言描述》（4）- 抽象语法</title>
    <link href="http://jinzhengxu.github.io/2019/04/09/xian-dai-bian-yi-yuan-li-c-yu-yan-miao-shu-4/"/>
    <id>http://jinzhengxu.github.io/2019/04/09/xian-dai-bian-yi-yuan-li-c-yu-yan-miao-shu-4/</id>
    <published>2019-04-09T02:46:51.000Z</published>
    <updated>2020-04-24T16:00:54.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第四章-抽象语法"><a href="#第四章-抽象语法" class="headerlink" title="第四章 抽象语法"></a>第四章 抽象语法</h3><blockquote><p>抽象的(ab-stract):从所有具体实例中提取出来的。<br>—-韦氏词典</p></blockquote><h4 id="语义动作"><a href="#语义动作" class="headerlink" title="语义动作"></a>语义动作</h4><p>语法分析器中的语义动作（semantic action），可以作用于正在分析的短语。</p><ul><li>对于递归下降分析器来说，语义动作是分散在实现语法分析的控制流中</li><li>对于遵循Yacc说明的语法分析器，语义动作是附带在文法产生式之后的c程序代码</li></ul><h5 id="递归下降"><a href="#递归下降" class="headerlink" title="递归下降"></a>递归下降</h5><p>对于递归下降语法分析器，语义动作是语法分析函数的返回值，或是语法分析函数的副作用，抑或是兼而有之。</p><p>每个非终结符和终结符（type）都关联一种语义值，语义值代表了由这个符号导出的短语。</p><p>对于消除左递归的情况，我们通过将左操作数作为参数传递给下一个语法分析函数的方法来解决。</p><p>也就是说我们为了消除左递归，必须要引入新的符号，但是新引入的符号的产生式不一定符合运算符的操作规范，于是我们必须要将上一层分析中的左操作数传递到下一层并返回。</p><h5 id="Yacc生成的分析器"><a href="#Yacc生成的分析器" class="headerlink" title="Yacc生成的分析器"></a>Yacc生成的分析器</h5><p>对于遵循Yacc说明的语法分析器,语法动作是附加在产生式之后的一段c代码。当Yacc利用，某一条规则进行归约时，就会执行其后的语义动作。例如文法3-13Yacc语法分析器：</p><pre class=" language-c"><code class="language-c"><span class="token operator">%</span><span class="token punctuation">{</span> declarations of yylex and yyerror <span class="token operator">%</span><span class="token punctuation">}</span><span class="token operator">%</span><span class="token keyword">union</span> <span class="token punctuation">{</span><span class="token keyword">int</span> num<span class="token punctuation">;</span> string id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">%</span>token <span class="token operator">&lt;</span>num<span class="token operator">></span> INT<span class="token operator">%</span>token <span class="token operator">&lt;</span>id<span class="token operator">></span> ID<span class="token operator">%</span>type <span class="token operator">&lt;</span>num<span class="token operator">></span> exp<span class="token operator">%</span>start exp<span class="token operator">%</span>left PLUS MINUS<span class="token operator">%</span>left TIMES<span class="token operator">%</span>left UMINUS<span class="token operator">%</span><span class="token operator">%</span>exp <span class="token punctuation">:</span> INT             <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> exp PLUS exp    <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span> <span class="token operator">+</span> $<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> exp MINUS exp   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span> <span class="token operator">-</span> $<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> exp TIMES exp   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span> <span class="token operator">*</span> $<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> MINUS exp   <span class="token operator">%</span>prec UMINUS <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token operator">-</span> $<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Yacc中语义动作的使用是用<code>$i</code>来引用第i个右部符号的语义值，它为左部非终结符产生的值可以赋给<code>$$</code>。<code>%union</code>说明了各种可能携带的语义值类型，每个非终结符通过<code>&lt;variant&gt;</code>，注释指明该非终结符应该使用哪一个<code>%union</code>声明中的形式。</p><p>遵循Yacc说明的语法分析器会维护一个 <strong><em>状态栈</em></strong> 和一个 <strong><em>语义值栈</em></strong> 来实现对语义值的操作，在原来简单分析栈的基础上增添了一个与分析栈符号一一对应的语义值栈。在语法分析器执行一个归约动作时，它会从一个简单栈中弹出k个字符，并将归约得到的非终结符压栈，对于语义值栈的操作也是如此，从语义值栈弹出k个语义值，并将执行语义动作c代码返回的语义值重新压栈。</p><p>如下图：</p><p>终结符携带的语义值是无意义的占位符。</p><h5 id="语义动作的解释器"><a href="#语义动作的解释器" class="headerlink" title="语义动作的解释器"></a>语义动作的解释器</h5><p>上面的程序设计语言的例子中，并没有语义动作能够影响全局的副作用，所以右部符号的求值顺序并不能影响最终的结果。</p><p>但是我们可以知道，LR分析是自底向上，从左至右的遍历语法分析树，即后序遍历的方式来执行归约和语义动作。利用这一特性，我们可以编写出带有全局副作用的语义动作，并且可以明确了解副作用的发生顺序。</p><p>下面的例子是绪论中直线式程序设计的解释器。通过使用一个符号表的全局变量：</p><pre class=" language-c"><code class="language-c"><span class="token operator">%</span><span class="token punctuation">{</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> table <span class="token operator">*</span>Table_<span class="token punctuation">;</span>Table_ <span class="token punctuation">{</span>string id<span class="token punctuation">;</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span> Table_ tail<span class="token punctuation">}</span><span class="token punctuation">;</span>Table_ <span class="token function">Table</span><span class="token punctuation">(</span>string id<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">struct</span> table <span class="token operator">*</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>Table_ table<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">lookup</span><span class="token punctuation">(</span>Table_ table<span class="token punctuation">,</span> string id<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">assert</span><span class="token punctuation">(</span>table<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">==</span>table<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token keyword">return</span> table<span class="token punctuation">.</span>value<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">.</span>tail<span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Table_ <span class="token operator">*</span>tabptr<span class="token punctuation">,</span>string id<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token operator">*</span>tabptr <span class="token operator">=</span> <span class="token function">Table</span><span class="token punctuation">(</span>id <span class="token punctuation">,</span>value<span class="token punctuation">,</span> <span class="token operator">*</span>tabptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">%</span><span class="token punctuation">}</span><span class="token operator">%</span><span class="token keyword">union</span> <span class="token punctuation">{</span><span class="token keyword">int</span> num<span class="token punctuation">;</span>string id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">%</span>token <span class="token operator">&lt;</span>num<span class="token operator">></span> INT<span class="token punctuation">;</span><span class="token operator">%</span>token <span class="token operator">&lt;</span>id<span class="token operator">></span> Id<span class="token operator">%</span>token ASSIGN PRINT LPAREN RPAREN<span class="token operator">%</span>type <span class="token operator">&lt;</span>num<span class="token operator">></span> exp<span class="token operator">%</span>right SEMICOLON<span class="token operator">%</span>left PLUS MINUS<span class="token operator">%</span>left TIMES DIV<span class="token operator">%</span>start prog<span class="token operator">%</span><span class="token operator">%</span>prog<span class="token punctuation">:</span> stmstm<span class="token punctuation">:</span> stm SEMICOLON stmstm<span class="token punctuation">:</span> ID ASSIGN exp            <span class="token punctuation">{</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">,</span>ID<span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>stm<span class="token punctuation">:</span> PRINT LPAREN exps RPAREN <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exps<span class="token punctuation">:</span> exp                     <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exps<span class="token punctuation">:</span> exps COMMA exp          <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> $<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> INT                      <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> ID                       <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">lookup</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> exp PLUS exp             <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">1</span><span class="token operator">+</span>$<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> exp MINUS exp            <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">1</span><span class="token operator">-</span>$<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> exp TIMES exp            <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">1</span><span class="token operator">*</span>$<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> exp DIV exp              <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">1</span><span class="token operator">/</span>$<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> stm COMMA exp            <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp<span class="token punctuation">:</span> LPAREN exp RPAREN        <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="抽象语法分析树"><a href="#抽象语法分析树" class="headerlink" title="抽象语法分析树"></a>抽象语法分析树</h4><p>使用上述的方法实现一个编译器的语法分析器完全可行，但是为了方便维护，建议将语法分析和语义动作（类型检查和翻译成机器代码）分开处理。所以我们使用语法分析器生成语法分析树，编译器在较后的阶段对其进行遍历。这样的一颗语法分析树称为具体分析树（concrete parse tree），表示源语言的具体语法（concrete syntax）。</p><p>语法树的结构对文法的依赖程度很高，在消除二义性等过程中引入的新产生式，都因该限制在语法分析阶段。</p><p><strong><em>抽象语法abstract syntax</em></strong> 建立了一个接口，这样语义分析阶段就不受文法二义性的困扰，因为我们提经有了一个语法树</p><p>直线式程序设计语言的抽象语法构造器</p><pre class=" language-c"><code class="language-c"><span class="token operator">%</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"absyn.h"</span></span><span class="token operator">%</span><span class="token punctuation">}</span><span class="token operator">%</span><span class="token keyword">union</span> <span class="token punctuation">{</span><span class="token keyword">int</span> num<span class="token punctuation">;</span> string id<span class="token punctuation">;</span> A_stm stm<span class="token punctuation">;</span> A_exp exp<span class="token punctuation">;</span>A_expList expList<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">%</span>token <span class="token operator">&lt;</span>num<span class="token operator">></span> INT<span class="token operator">%</span>token <span class="token operator">&lt;</span>id<span class="token operator">></span> ID<span class="token operator">%</span>token ASSIGN PRINT LPAREN RPAREN<span class="token operator">%</span>type <span class="token operator">&lt;</span>stm<span class="token operator">></span> stm prog<span class="token operator">%</span>type <span class="token operator">&lt;</span>exp<span class="token operator">></span> exp<span class="token operator">%</span>type <span class="token operator">&lt;</span>expList<span class="token operator">></span> exps<span class="token operator">%</span>left SEMICOLON<span class="token operator">%</span>left PLUS MINUS<span class="token operator">%</span>left TIMES DIV<span class="token operator">%</span>start prog<span class="token operator">%</span><span class="token operator">%</span>prog<span class="token punctuation">:</span> stm <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>stm <span class="token punctuation">:</span> stm SEMICOLON stm <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_CompoundStm</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>stm <span class="token punctuation">:</span> ID ASSIGN exp <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_AssignStm</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>stm <span class="token punctuation">:</span> PRINT LPAREN exps RPAREN  <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_PrintStm</span><span class="token punctuation">(</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exps<span class="token punctuation">:</span> exp <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_ExpList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exps<span class="token punctuation">:</span> exp COMMA exps <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_ExpList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> INT <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_NumExp</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> ID <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_IdExp</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> exp PLUS exp <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_OpExp</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>A_plus<span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> exp MINUS exp <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_OpExp</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>A_minus<span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> exp TIMES exp <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_OpExp</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>A_times<span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> exp DIV exp <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_OpExp</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>A_div<span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> stm COMMA exp <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_EsepExp</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exp <span class="token punctuation">:</span> LPAREN exp RPAREN <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h5><p>在一个只有一次pass的编译器中，词法分析，语法分析和语义分析，都是同时进行的。词法分析器会保存有一个表示当前位置的全局变量。</p><p>但是在使用抽象语法树的编译器中，在语义分析开始的时候，词法分析就已经到达文件尾，所以应当记住抽象语法树的每个节点在源文件中的位置，以防这个节点发生语义错误。</p><p>所以抽象语法结构上都带有pos域，pos域指明了导出抽象语法树的字符在源程序中对应的位置。Bison语法分析器可以做到这一点</p><h5 id="Tiger的抽象语法"><a href="#Tiger的抽象语法" class="headerlink" title="Tiger的抽象语法"></a>Tiger的抽象语法</h5><p>Tiger的抽象语法:</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * absyn.h - Abstract Syntax Header (Chapter 4) * * All types and functions declared in this header file begin with "A_" * Linked list types end with "..list" */</span><span class="token comment" spellcheck="true">/* Type Definitions */</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> A_pos<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_var_ <span class="token operator">*</span>A_var<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_exp_ <span class="token operator">*</span>A_exp<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_dec_ <span class="token operator">*</span>A_dec<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_ty_ <span class="token operator">*</span>A_ty<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_decList_ <span class="token operator">*</span>A_decList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_expList_ <span class="token operator">*</span>A_expList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_field_ <span class="token operator">*</span>A_field<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_fieldList_ <span class="token operator">*</span>A_fieldList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_fundec_ <span class="token operator">*</span>A_fundec<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_fundecList_ <span class="token operator">*</span>A_fundecList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_namety_ <span class="token operator">*</span>A_namety<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_nametyList_ <span class="token operator">*</span>A_nametyList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_efield_ <span class="token operator">*</span>A_efield<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> A_efieldList_ <span class="token operator">*</span>A_efieldList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>A_plusOp<span class="token punctuation">,</span> A_minusOp<span class="token punctuation">,</span> A_timesOp<span class="token punctuation">,</span> A_divideOp<span class="token punctuation">,</span>         A_eqOp<span class="token punctuation">,</span> A_neqOp<span class="token punctuation">,</span> A_ltOp<span class="token punctuation">,</span> A_leOp<span class="token punctuation">,</span> A_gtOp<span class="token punctuation">,</span> A_geOp<span class="token punctuation">}</span> A_oper<span class="token punctuation">;</span><span class="token keyword">struct</span> A_var_       <span class="token punctuation">{</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>A_simpleVar<span class="token punctuation">,</span> A_fieldVar<span class="token punctuation">,</span> A_subscriptVar<span class="token punctuation">}</span> kind<span class="token punctuation">;</span>        A_pos pos<span class="token punctuation">;</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>S_symbol simple<span class="token punctuation">;</span>           <span class="token keyword">struct</span> <span class="token punctuation">{</span>A_var var<span class="token punctuation">;</span>               S_symbol sym<span class="token punctuation">;</span><span class="token punctuation">}</span> field<span class="token punctuation">;</span>           <span class="token keyword">struct</span> <span class="token punctuation">{</span>A_var var<span class="token punctuation">;</span>               A_exp exp<span class="token punctuation">;</span><span class="token punctuation">}</span> subscript<span class="token punctuation">;</span>         <span class="token punctuation">}</span> u<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_exp_      <span class="token punctuation">{</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>A_varExp<span class="token punctuation">,</span> A_nilExp<span class="token punctuation">,</span> A_intExp<span class="token punctuation">,</span> A_stringExp<span class="token punctuation">,</span> A_callExp<span class="token punctuation">,</span>           A_opExp<span class="token punctuation">,</span> A_recordExp<span class="token punctuation">,</span> A_seqExp<span class="token punctuation">,</span> A_assignExp<span class="token punctuation">,</span> A_ifExp<span class="token punctuation">,</span>           A_whileExp<span class="token punctuation">,</span> A_forExp<span class="token punctuation">,</span> A_breakExp<span class="token punctuation">,</span> A_letExp<span class="token punctuation">,</span> A_arrayExp<span class="token punctuation">}</span> kind<span class="token punctuation">;</span>       A_pos pos<span class="token punctuation">;</span>       <span class="token keyword">union</span> <span class="token punctuation">{</span>A_var var<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* nil; - needs only the pos */</span>          <span class="token keyword">int</span> intt<span class="token punctuation">;</span>          string stringg<span class="token punctuation">;</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>S_symbol func<span class="token punctuation">;</span> A_expList args<span class="token punctuation">;</span><span class="token punctuation">}</span> call<span class="token punctuation">;</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>A_oper oper<span class="token punctuation">;</span> A_exp left<span class="token punctuation">;</span> A_exp right<span class="token punctuation">;</span><span class="token punctuation">}</span> op<span class="token punctuation">;</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>S_symbol typ<span class="token punctuation">;</span> A_efieldList fields<span class="token punctuation">;</span><span class="token punctuation">}</span> record<span class="token punctuation">;</span>          A_expList seq<span class="token punctuation">;</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>A_var var<span class="token punctuation">;</span> A_exp exp<span class="token punctuation">;</span><span class="token punctuation">}</span> assign<span class="token punctuation">;</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>A_exp test<span class="token punctuation">,</span> then<span class="token punctuation">,</span> elsee<span class="token punctuation">;</span><span class="token punctuation">}</span> iff<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* elsee is optional */</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>A_exp test<span class="token punctuation">,</span> body<span class="token punctuation">;</span><span class="token punctuation">}</span> whilee<span class="token punctuation">;</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>S_symbol var<span class="token punctuation">;</span> A_exp lo<span class="token punctuation">,</span>hi<span class="token punctuation">,</span>body<span class="token punctuation">;</span> bool escape<span class="token punctuation">;</span><span class="token punctuation">}</span> forr<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* breakk; - need only the pos */</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>A_decList decs<span class="token punctuation">;</span> A_exp body<span class="token punctuation">;</span><span class="token punctuation">}</span> let<span class="token punctuation">;</span>          <span class="token keyword">struct</span> <span class="token punctuation">{</span>S_symbol typ<span class="token punctuation">;</span> A_exp size<span class="token punctuation">,</span> init<span class="token punctuation">;</span><span class="token punctuation">}</span> array<span class="token punctuation">;</span>        <span class="token punctuation">}</span> u<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_dec_    <span class="token punctuation">{</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>A_functionDec<span class="token punctuation">,</span> A_varDec<span class="token punctuation">,</span> A_typeDec<span class="token punctuation">}</span> kind<span class="token punctuation">;</span>     A_pos pos<span class="token punctuation">;</span>     <span class="token keyword">union</span> <span class="token punctuation">{</span>A_fundecList function<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* escape may change after the initial declaration */</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>S_symbol var<span class="token punctuation">;</span> S_symbol typ<span class="token punctuation">;</span> A_exp init<span class="token punctuation">;</span> bool escape<span class="token punctuation">;</span><span class="token punctuation">}</span> var<span class="token punctuation">;</span>        A_nametyList type<span class="token punctuation">;</span>      <span class="token punctuation">}</span> u<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_ty_ <span class="token punctuation">{</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>A_nameTy<span class="token punctuation">,</span> A_recordTy<span class="token punctuation">,</span> A_arrayTy<span class="token punctuation">}</span> kind<span class="token punctuation">;</span>          A_pos pos<span class="token punctuation">;</span>          <span class="token keyword">union</span> <span class="token punctuation">{</span>S_symbol name<span class="token punctuation">;</span>             A_fieldList record<span class="token punctuation">;</span>             S_symbol array<span class="token punctuation">;</span>           <span class="token punctuation">}</span> u<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* Linked lists and nodes of lists */</span><span class="token keyword">struct</span> A_field_ <span class="token punctuation">{</span>S_symbol name<span class="token punctuation">,</span> typ<span class="token punctuation">;</span> A_pos pos<span class="token punctuation">;</span> bool escape<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_fieldList_ <span class="token punctuation">{</span>A_field head<span class="token punctuation">;</span> A_fieldList tail<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_expList_ <span class="token punctuation">{</span>A_exp head<span class="token punctuation">;</span> A_expList tail<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_fundec_ <span class="token punctuation">{</span>A_pos pos<span class="token punctuation">;</span>                 S_symbol name<span class="token punctuation">;</span> A_fieldList params<span class="token punctuation">;</span>         S_symbol result<span class="token punctuation">;</span> A_exp body<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_fundecList_ <span class="token punctuation">{</span>A_fundec head<span class="token punctuation">;</span> A_fundecList tail<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_decList_ <span class="token punctuation">{</span>A_dec head<span class="token punctuation">;</span> A_decList tail<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_namety_ <span class="token punctuation">{</span>S_symbol name<span class="token punctuation">;</span> A_ty ty<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_nametyList_ <span class="token punctuation">{</span>A_namety head<span class="token punctuation">;</span> A_nametyList tail<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_efield_ <span class="token punctuation">{</span>S_symbol name<span class="token punctuation">;</span> A_exp exp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> A_efieldList_ <span class="token punctuation">{</span>A_efield head<span class="token punctuation">;</span> A_efieldList tail<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* Function Prototypes */</span>A_var <span class="token function">A_SimpleVar</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol sym<span class="token punctuation">)</span><span class="token punctuation">;</span>A_var <span class="token function">A_FieldVar</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_var var<span class="token punctuation">,</span> S_symbol sym<span class="token punctuation">)</span><span class="token punctuation">;</span>A_var <span class="token function">A_SubscriptVar</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_var var<span class="token punctuation">,</span> A_exp exp<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_VarExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_var var<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_NilExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_IntExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_StringExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> string s<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_CallExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol func<span class="token punctuation">,</span> A_expList args<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_OpExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_oper oper<span class="token punctuation">,</span> A_exp left<span class="token punctuation">,</span> A_exp right<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_RecordExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol typ<span class="token punctuation">,</span> A_efieldList fields<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_SeqExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_expList seq<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_AssignExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_var var<span class="token punctuation">,</span> A_exp exp<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_IfExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_exp test<span class="token punctuation">,</span> A_exp then<span class="token punctuation">,</span> A_exp elsee<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_WhileExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_exp test<span class="token punctuation">,</span> A_exp body<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_ForExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol var<span class="token punctuation">,</span> A_exp lo<span class="token punctuation">,</span> A_exp hi<span class="token punctuation">,</span> A_exp body<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_BreakExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_LetExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_decList decs<span class="token punctuation">,</span> A_exp body<span class="token punctuation">)</span><span class="token punctuation">;</span>A_exp <span class="token function">A_ArrayExp</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol typ<span class="token punctuation">,</span> A_exp size<span class="token punctuation">,</span> A_exp init<span class="token punctuation">)</span><span class="token punctuation">;</span>A_dec <span class="token function">A_FunctionDec</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_fundecList function<span class="token punctuation">)</span><span class="token punctuation">;</span>A_dec <span class="token function">A_VarDec</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol var<span class="token punctuation">,</span> S_symbol typ<span class="token punctuation">,</span> A_exp init<span class="token punctuation">)</span><span class="token punctuation">;</span>A_dec <span class="token function">A_TypeDec</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_nametyList type<span class="token punctuation">)</span><span class="token punctuation">;</span>A_ty <span class="token function">A_NameTy</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol name<span class="token punctuation">)</span><span class="token punctuation">;</span>A_ty <span class="token function">A_RecordTy</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> A_fieldList record<span class="token punctuation">)</span><span class="token punctuation">;</span>A_ty <span class="token function">A_ArrayTy</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol array<span class="token punctuation">)</span><span class="token punctuation">;</span>A_field <span class="token function">A_Field</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol name<span class="token punctuation">,</span> S_symbol typ<span class="token punctuation">)</span><span class="token punctuation">;</span>A_fieldList <span class="token function">A_FieldList</span><span class="token punctuation">(</span>A_field head<span class="token punctuation">,</span> A_fieldList tail<span class="token punctuation">)</span><span class="token punctuation">;</span>A_expList <span class="token function">A_ExpList</span><span class="token punctuation">(</span>A_exp head<span class="token punctuation">,</span> A_expList tail<span class="token punctuation">)</span><span class="token punctuation">;</span>A_fundec <span class="token function">A_Fundec</span><span class="token punctuation">(</span>A_pos pos<span class="token punctuation">,</span> S_symbol name<span class="token punctuation">,</span> A_fieldList params<span class="token punctuation">,</span> S_symbol result<span class="token punctuation">,</span>          A_exp body<span class="token punctuation">)</span><span class="token punctuation">;</span>A_fundecList <span class="token function">A_FundecList</span><span class="token punctuation">(</span>A_fundec head<span class="token punctuation">,</span> A_fundecList tail<span class="token punctuation">)</span><span class="token punctuation">;</span>A_decList <span class="token function">A_DecList</span><span class="token punctuation">(</span>A_dec head<span class="token punctuation">,</span> A_decList tail<span class="token punctuation">)</span><span class="token punctuation">;</span>A_namety <span class="token function">A_Namety</span><span class="token punctuation">(</span>S_symbol name<span class="token punctuation">,</span> A_ty ty<span class="token punctuation">)</span><span class="token punctuation">;</span>A_nametyList <span class="token function">A_NametyList</span><span class="token punctuation">(</span>A_namety head<span class="token punctuation">,</span> A_nametyList tail<span class="token punctuation">)</span><span class="token punctuation">;</span>A_efield <span class="token function">A_Efield</span><span class="token punctuation">(</span>S_symbol name<span class="token punctuation">,</span> A_exp exp<span class="token punctuation">)</span><span class="token punctuation">;</span>A_efieldList <span class="token function">A_EfieldList</span><span class="token punctuation">(</span>A_efield head<span class="token punctuation">,</span> A_efieldList tail<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里需要注意的几点是：</p><ul><li>夹杂在其中的关于位置的表示是用源代码的字符计数来表示的。</li><li>Tiger语言将相邻的函数生命看成是（可能会）相互递归的。</li><li>没有关于表达式&amp;和|的抽象语法，用if else来表示</li><li>词法分析器返回的ID单词携带string类型的值，而抽象语法要求标识符具有symbol值。<h4 id="程序设计：抽象语法"><a href="#程序设计：抽象语法" class="headerlink" title="程序设计：抽象语法"></a>程序设计：抽象语法</h4>这次的程序设计，是在上一章作业的基础上添加语义动作。</li></ul><p>文件：</p><pre class=" language-c"><code class="language-c">absyn<span class="token punctuation">.</span>c <span class="token comment" spellcheck="true">//Tiger的抽象语法声明</span>lex<span class="token punctuation">.</span>yy<span class="token punctuation">.</span>c <span class="token comment" spellcheck="true">//替代的词法分析器，可以使用自己的</span>parse<span class="token punctuation">.</span>c <span class="token comment" spellcheck="true">//驱动程序，分析Tiger程序</span>prabsyn<span class="token punctuation">.</span>c <span class="token comment" spellcheck="true">//抽象语法树输出程序</span>symbol<span class="token punctuation">.</span>c <span class="token comment" spellcheck="true">//字符串转化尾字符</span>table<span class="token punctuation">.</span>c <span class="token comment" spellcheck="true">//函数声明表支持</span>tiger<span class="token punctuation">.</span>grm <span class="token comment" spellcheck="true">//需要编写的grm文件</span>absyn<span class="token punctuation">.</span>hmakefileparse<span class="token punctuation">.</span>hprabsyn<span class="token punctuation">.</span>hsymbol<span class="token punctuation">.</span>htable<span class="token punctuation">.</span>h</code></pre><p>通过前面我们知道添加语义动作有两种方式。一种是直接添加语义动作，另一种是通过抽象语法的方式来添加，这里vim一下<code>tiger.grm</code>文件我们可以发现作者的意思应该是通过抽象语法来完成这次的设计。这里就在第三章设计的基础上来完成语法抽象。</p><p>首先将第四章内缺省的一些文件补全,并将第三章内的<code>tiger.grm</code>复制来</p><pre class=" language-bash"><code class="language-bash">~/chap3$ <span class="token function">cp</span> -f parsetest.c util.h util.c tiger.grm ~/chap4</code></pre><p>然后为其增加语义动作</p><pre class=" language-c"><code class="language-c"><span class="token operator">%</span><span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"util.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"errormsg.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"symbol.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"absyn.h"</span></span><span class="token keyword">int</span> <span class="token function">yylex</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* function prototype */</span>A_exp absyn_root<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">EM_error</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">%</span><span class="token punctuation">}</span><span class="token operator">%</span><span class="token keyword">union</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pos<span class="token punctuation">;</span>    <span class="token keyword">int</span> ival<span class="token punctuation">;</span>    string sval<span class="token punctuation">;</span>        A_exp exp<span class="token punctuation">;</span>        A_expList explist<span class="token punctuation">;</span>        A_var var<span class="token punctuation">;</span>        A_decList declist<span class="token punctuation">;</span>        A_dec  dec<span class="token punctuation">;</span>        A_efieldList efieldlist<span class="token punctuation">;</span>        A_efield  efield<span class="token punctuation">;</span>        A_namety namety<span class="token punctuation">;</span>        A_nametyList nametylist<span class="token punctuation">;</span>        A_fieldList fieldlist<span class="token punctuation">;</span>        A_field field<span class="token punctuation">;</span>        A_fundecList fundeclist<span class="token punctuation">;</span>        A_fundec fundec<span class="token punctuation">;</span>        A_ty ty<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">%</span>token <span class="token operator">&lt;</span>sval<span class="token operator">></span> ID STRING<span class="token operator">%</span>token <span class="token operator">&lt;</span>ival<span class="token operator">></span> INT<span class="token operator">%</span>token  COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK  LBRACE RBRACE DOT  PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE  AND OR ASSIGN  ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF  BREAK NIL  FUNCTION VAR TYPE<span class="token operator">%</span>type <span class="token operator">&lt;</span>exp<span class="token operator">></span> exp_em exp expseq<span class="token operator">%</span>type <span class="token operator">&lt;</span>explist<span class="token operator">></span> actuals  nonemptyactuals sequencing  sequencing_exps<span class="token operator">%</span>type <span class="token operator">&lt;</span>var<span class="token operator">></span>  lvalue one oneormore<span class="token operator">%</span>type <span class="token operator">&lt;</span>declist<span class="token operator">></span> decs decs_nonempty<span class="token operator">%</span>type <span class="token operator">&lt;</span>dec<span class="token operator">></span>  decs_nonempty_s vardec<span class="token operator">%</span>type <span class="token operator">&lt;</span>efieldlist<span class="token operator">></span> rec rec_nonempty<span class="token operator">%</span>type <span class="token operator">&lt;</span>efield<span class="token operator">></span> rec_one<span class="token operator">%</span>type <span class="token operator">&lt;</span>nametylist<span class="token operator">></span> tydec<span class="token operator">%</span>type <span class="token operator">&lt;</span>namety<span class="token operator">></span>  tydec_one<span class="token operator">%</span>type <span class="token operator">&lt;</span>fieldlist<span class="token operator">></span> tyfields tyfields_nonempty<span class="token operator">%</span>type <span class="token operator">&lt;</span>ty<span class="token operator">></span> ty<span class="token operator">%</span>type <span class="token operator">&lt;</span>fundeclist<span class="token operator">></span> fundec<span class="token operator">%</span>type <span class="token operator">&lt;</span>fundec<span class="token operator">></span> fundec_one<span class="token operator">%</span>left SEMICOLON<span class="token operator">%</span>nonassoc DO<span class="token operator">%</span>nonassoc LOWER<span class="token operator">%</span>nonassoc TYPE<span class="token operator">%</span>nonassoc FUNCTION<span class="token operator">%</span>nonassoc OF<span class="token operator">%</span>nonassoc LOW<span class="token operator">%</span>nonassoc  ELSE<span class="token operator">%</span>right ASSIGN<span class="token operator">%</span>left OR<span class="token operator">%</span>left AND<span class="token operator">%</span>nonassoc EQ NEQ LT LE GT GE<span class="token operator">%</span>left PLUS MINUS<span class="token operator">%</span>left TIMES DIVIDE<span class="token operator">%</span>nonassoc UMINUS<span class="token operator">%</span>left DOT LBRACK<span class="token operator">%</span>start program<span class="token operator">%</span><span class="token operator">%</span>program    <span class="token punctuation">:</span>    exp_em  <span class="token punctuation">{</span>absyn_root <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>exp_em    <span class="token punctuation">:</span> exp  <span class="token punctuation">{</span>$$<span class="token operator">=</span>$<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>exp    <span class="token punctuation">:</span> INT      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_IntExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> STRING   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_StringExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> lvalue   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_VarExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> NIL      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_NilExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> LPAREN sequencing RPAREN  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_SeqExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> exp PLUS exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_plusOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp MINUS exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_minusOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp TIMES exp   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_timesOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp DIVIDE exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_divideOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp EQ exp      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_eqOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp NEQ exp     <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_neqOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp LT exp      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_ltOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp LE exp      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_leOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp GT exp      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_gtOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp GE exp      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_geOp<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp AND exp     <span class="token punctuation">{</span>$$ <span class="token operator">=</span><span class="token function">A_IfExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">,</span><span class="token function">A_IntExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>exp OR exp      <span class="token punctuation">{</span>$$ <span class="token operator">=</span><span class="token function">A_IfExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token function">A_IntExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>MINUS exp <span class="token operator">%</span>prec UMINUS <span class="token punctuation">{</span>$$<span class="token operator">=</span><span class="token function">A_OpExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>A_minusOp<span class="token punctuation">,</span><span class="token function">A_IntExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>LPAREN exp_em RPAREN    <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>ID LPAREN actuals RPAREN  <span class="token punctuation">{</span>$$ <span class="token operator">=</span><span class="token function">A_CallExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>lvalue ASSIGN exp         <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_AssignExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>IF exp THEN exp  <span class="token operator">%</span>prec LOW  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_IfExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>IF exp THEN exp ELSE exp   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_IfExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">,</span>$<span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>WHILE exp DO exp            <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_WhileExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>FOR ID ASSIGN exp TO exp DO exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ForExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">,</span>$<span class="token number">6</span><span class="token punctuation">,</span>$<span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>BREAK                            <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_BreakExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>LET decs IN expseq END           <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_LetExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>ID LBRACE rec  RBRACE            <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_RecordExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>ID LBRACK exp RBRACK OF exp      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ArrayExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">,</span>$<span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>lvalue    <span class="token punctuation">:</span> ID    <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_SimpleVar</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> oneormore  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>oneormore    <span class="token punctuation">:</span> one       <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>oneormore DOT ID   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_FieldVar</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>oneormore LBRACK exp RBRACK   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_SubscriptVar</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>one <span class="token punctuation">:</span> ID DOT ID  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_FieldVar</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">A_SimpleVar</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> ID LBRACK exp RBRACK  <span class="token operator">%</span>prec LOWER  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_SubscriptVar</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">A_SimpleVar</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>rec <span class="token punctuation">:</span>  rec_nonempty  <span class="token punctuation">{</span>$$ <span class="token operator">=</span>$<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>rec_nonempty    <span class="token punctuation">:</span> rec_one <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_EfieldList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> rec_one COMMA rec_nonempty  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_EfieldList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>rec_one    <span class="token punctuation">:</span>  ID EQ exp   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_Efield</span><span class="token punctuation">(</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>sequencing    <span class="token punctuation">:</span> exp SEMICOLON sequencing_exps  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ExpList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>sequencing_exps    <span class="token punctuation">:</span>  exp          <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ExpList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> exp SEMICOLON sequencing_exps  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ExpList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>actuals    <span class="token punctuation">:</span> nonemptyactuals   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>nonemptyactuals    <span class="token punctuation">:</span> exp     <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ExpList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> exp COMMA nonemptyactuals <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ExpList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>expseq    <span class="token punctuation">:</span> sequencing_exps  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_SeqExp</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>decs    <span class="token punctuation">:</span>  decs_nonempty  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>decs_nonempty    <span class="token punctuation">:</span> decs_nonempty_s  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_DecList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> decs_nonempty_s decs_nonempty   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_DecList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>decs_nonempty_s    <span class="token punctuation">:</span> tydec  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_TypeDec</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>vardec  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>fundec  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_FunctionDec</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>tydec    <span class="token punctuation">:</span> tydec_one  <span class="token operator">%</span>prec LOWER  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_NametyList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> tydec_one tydec      <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_NametyList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>tydec_one    <span class="token punctuation">:</span> TYPE ID EQ ty    <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_Namety</span><span class="token punctuation">(</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>ty  <span class="token punctuation">:</span>   ID    <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_NameTy</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> LBRACE tyfields RBRACE  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_RecordTy</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> ARRAY OF ID <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_ArrayTy</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>tyfields    <span class="token punctuation">:</span> tyfields_nonempty  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> $<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>   <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>tyfields_nonempty    <span class="token punctuation">:</span> ID COLON ID  <span class="token punctuation">{</span>$$ <span class="token operator">=</span><span class="token function">A_FieldList</span><span class="token punctuation">(</span><span class="token function">A_Field</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> ID COLON ID COMMA tyfields_nonempty  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_FieldList</span><span class="token punctuation">(</span><span class="token function">A_Field</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>vardec    <span class="token punctuation">:</span> VAR ID ASSIGN exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_VarDec</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> VAR ID COLON ID ASSIGN exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_VarDec</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>fundec    <span class="token punctuation">:</span>   fundec_one  <span class="token operator">%</span>prec LOWER <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_FundecList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span>   fundec_one fundec    <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_FundecList</span><span class="token punctuation">(</span>$<span class="token number">1</span><span class="token punctuation">,</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span>fundec_one    <span class="token punctuation">:</span> FUNCTION ID LPAREN tyfields RPAREN EQ exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_Fundec</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token operator">|</span> FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp  <span class="token punctuation">{</span>$$ <span class="token operator">=</span> <span class="token function">A_Fundec</span><span class="token punctuation">(</span>EM_tokPos<span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">4</span><span class="token punctuation">,</span><span class="token function">S_Symbol</span><span class="token punctuation">(</span>$<span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">;</span></code></pre><h4 id="几种yacc错误情况的分析"><a href="#几种yacc错误情况的分析" class="headerlink" title="几种yacc错误情况的分析"></a>几种yacc错误情况的分析</h4><ul><li><p>no delacre type</p><p>首先检查是否在yacc文件的第二部分中声明了该类型，如果没有声明，补充；<br>而是检查yacc文件第三部分的$后的数字是否对应了正确的字段</p></li></ul><blockquote><p>Perhaps you are thinking that only symbols with values are counted. That’s not the case; $n refers to the value of the symbol n in the right-hand side, and is therefore an errorbif that symbol doesn’t have a value.</p></blockquote><blockquote><p>Note that yacc/bison can’t really tell whether or not a particular terminal has a value or not; all it knows is whether you have told it what the type of that value is.</p></blockquote><ul><li>error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘explist’; did you mean ‘expList’</li></ul><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p>1.<a href="https://www.ibm.com/developerworks/cn/linux/l-flexbison.html" target="_blank" rel="noopener">使用 Flex 和 Bison 更好地进行错误处理</a></p><p>2.<a href="https://segmentfault.com/a/1190000000396608" target="_blank" rel="noopener">如何使用Lex/YACC</a></p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第四章-抽象语法&quot;&gt;&lt;a href=&quot;#第四章-抽象语法&quot; class=&quot;headerlink&quot; title=&quot;第四章 抽象语法&quot;&gt;&lt;/a&gt;第四章 抽象语法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;抽象的(ab-stract):从所有具体实例中提取出来的。&lt;br&gt;
      
    
    </summary>
    
    
      <category term="虎书" scheme="http://jinzhengxu.github.io/tags/%E8%99%8E%E4%B9%A6/"/>
    
      <category term="编译原理" scheme="http://jinzhengxu.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux(4)-Linux磁盘与文件系统管理</title>
    <link href="http://jinzhengxu.github.io/2019/04/04/niao-ge-de-linux-si-fang-cai-4-linux-ci-pan-yu-wen-jian-xi-tong-guan-li/"/>
    <id>http://jinzhengxu.github.io/2019/04/04/niao-ge-de-linux-si-fang-cai-4-linux-ci-pan-yu-wen-jian-xi-tong-guan-li/</id>
    <published>2019-04-04T00:39:42.000Z</published>
    <updated>2020-04-24T16:00:54.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识Linux文件系统"><a href="#认识Linux文件系统" class="headerlink" title="认识Linux文件系统"></a>认识Linux文件系统</h3><p>Linux 文件系统最“正统”的是 <strong><em>ext2</em></strong> ,文件系统的建立和磁盘的物理结构是紧密相关的，现在我们有TB级的磁盘阵列，也有读写速度极快的ssd，如何根据自己的要求和期望的性能，文件系统的选择至关重要。</p><h4 id="磁盘组成与分区的复习"><a href="#磁盘组成与分区的复习" class="headerlink" title="磁盘组成与分区的复习"></a>磁盘组成与分区的复习</h4><p> 虽然ssd的出现在一般的计算机上已经普及，但是对于文件的安全性来说，相比于ssd几年的寿命和有限的读写次数，传统机械硬盘是我们保存数据的一个不可替代的选择，所以我们先从机械硬盘的结构说起：</p><ul><li><p>碟片（记录数据）</p></li><li><p>机械手臂，磁头（擦写碟片上的数据）</p></li><li><p>主轴马达：转动磁盘使磁头可以读写碟片上的数据</p><p>也就是说，<strong>数据的储存和擦写主要集中在碟片上</strong> ，而碟片的物理组成为：</p></li><li><p>扇区（Sector）为最小的物理储存单位，根据磁盘设计的不同有 <strong>512B</strong> 和 <strong>4KB</strong>两种</p></li><li><p>将扇区组成一个圆，即为 *<em>柱面（Cylinder） *</em></p></li><li><p>每个扇区都有自己的编号</p></li><li><p>磁盘分区表主要有 <strong>MBR</strong>和 <strong>GPT</strong>两种</p><ul><li>MBR分区表中第一扇区中储存 <strong>主引导记录（Master boot record，MBR）446B</strong> 及 <strong>分区表（partition table）64B</strong>，</li><li>GPT分区表除了分区数量扩充较多，支持的磁盘容量有超过2TB</li></ul><p>物理磁盘的文件名已经模拟成<code>/dev/sd[a-p]</code>的格式，第一块磁盘分区的文件名为<code>/dev/sda[1-128]</code>,虚拟机的磁盘通常是<code>/dev/vd[a-p]</code>,如果使用软件磁盘阵列使用的文件名是<code>/dev/md[a-p]</code>。</p></li></ul><h4 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h4><p> 操作系统拥有不同的的文件属性/权限，为了存放数据，就要对磁盘进行格式化，成为操作系统所能利用的文件系统。</p><p> LVM与软件磁盘阵列（software raid）技术可以使一个分区拥有不同的文件系统，也可以将多个分区合成一个文件系统。所以我们称呼 <strong>一个可以被挂载的数据为一个文件系统而不是一个分区</strong>。</p><p> 之前对于文件权限的学习中，我们了解到Linux文件系统中的文件有权限和属性的记录， <strong>文件系统会将文件的权限与属性放在inode中，而实际数据在放在数据区块中</strong>，此外还会有一个超级区块来存放文件系统的整体信息，也就是inode与数据区块的总量使用量和剩余量。</p><pre class=" language-c"><code class="language-c"> 每个文件文件占有一个inode<span class="token operator">--</span><span class="token operator">-></span><span class="token operator">|</span>                           <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>inode内有文件实际数据所在的区块号码 每个inode和数据区块都有编号<span class="token operator">-></span><span class="token operator">|</span></code></pre><p> 也就是我们只要找到inode就能知道文件的存放位置，这样大大提高了读写效率。这种方式称为 <strong>索引式文件系统</strong>，这样我们可以一口气读出文件所有区块的位置编号，而FAT文件系统需要先读取一个区块才能知道下一个区块的位置编号。考虑这种情况<code>1-&gt;7-&gt;4-&gt;20-&gt;13</code>,索引式文件系统可以在一圈内读出所有数据，而FAT则需要几圈。这也就是<strong>碎片整理</strong>的由来，弱国文件写入的区块太过于离散，文件的读取性能就会很差。</p><h4 id="Linux的ext2文件系统（inode）"><a href="#Linux的ext2文件系统（inode）" class="headerlink" title="Linux的ext2文件系统（inode）"></a>Linux的ext2文件系统（inode）</h4><p> 文件系统一开就将inode和数据区块规划好了，除非重新格式化，或使用<code>resize2fs</code>命令修改。否则inode和数据区块就是固定的。</p><p> ext2文件系统的格式化时是分为多个区块群组（block group）</p><pre class=" language-c"><code class="language-c"> <span class="token operator">|</span>Boot Sector<span class="token operator">|</span>Block Group1<span class="token operator">|</span>Block Group2<span class="token operator">|</span>Block Group3<span class="token operator">|</span>Block Group4<span class="token operator">|</span>                <span class="token operator">|</span>    <span class="token operator">|</span> <span class="token operator">|</span><span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span>    <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-></span><span class="token operator">|</span> <span class="token operator">|</span>Superblock<span class="token operator">|</span>文件系统描述<span class="token operator">|</span>区块对应表<span class="token operator">|</span>inode对应表<span class="token operator">|</span>inode Table<span class="token operator">|</span>Date Block<span class="token operator">|</span></code></pre><p>文件系统最前方拥有一个启动扇区Boot Sector来存放不同文件系统的引导程序，这样就能实现多重引导，而不用覆盖每个MBR表。</p><p>每个区块群组有6个部分：</p><ul><li><p>Superblock</p><ul><li>数据区块与inode的总量;</li><li>未使用与已使用的inode与数据区块 数量;</li><li>数据区块与inode的大小（block为1,2,4k，inode为128B或256B）;</li><li>文件系统的挂载时间，最近一次写入数据的时间，最近一次检验（fsck）的时间</li><li>一个有效位值，已被挂载为0,否则为1;</li></ul><p>一般 <strong>除了第一个区块群组含有超级区块，剩下的不会有，有也是为了备份</strong>。</p></li><li><p>文件系统描述Filesystem Description</p></li></ul><p>描述区块群组开始与结束的区块，以及每个区块的6个部分分别介于哪个区块之间，可以使用命令<code>dumpe2fs</code>来查看</p><ul><li>区块对应表（block bitmap）</li></ul><p>记录区块是否使用</p><ul><li>inode对应表（inode bitmap）</li></ul><p>记录inode是否使用</p><ul><li><p>inode Table</p><ul><li>文件的读写属性rwx</li><li>文件的拥有者与用户组</li><li>文件的大小</li><li>文件的建立或状态改变的时间ctime</li><li>文件的最后一次读取的时间atime</li><li>文件的最后一次修改时间mtime</li><li>文件特性的标识，SUID，SGID，SBIT等</li><li>文件真正内容的指向pointer</li><li>inode的大小为128B，ext4和xfs可以设为256B</li><li>每个文件只会占用一个inode</li><li>所以文件系统能够建立的文件数量和inode的数量有关</li><li>系统读取文件时会先经过inode</li></ul><p>inode记录区块号码的区域定义为12个直接，一个间接，一个双间接和一个三间接<br>，假设一个区块为1K，。每个记录使用4B，也就是一个区块可以有256条记录</p><pre class=" language-c"><code class="language-c"><span class="token operator">|</span>文件权限<span class="token operator">/</span>属性记录区域<span class="token operator">|</span><span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       直接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>block号码（<span class="token number">1</span>条记录）<span class="token operator">|</span>       间接       <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>256block区块<span class="token operator">--</span><span class="token operator">-></span><span class="token number">256</span>×1K<span class="token operator">=</span>256K<span class="token operator">|</span>       双间接     <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>256block区块<span class="token operator">--</span><span class="token operator">-></span><span class="token number">256</span>×<span class="token number">256</span>个区块<span class="token operator">--</span><span class="token operator">-></span><span class="token number">256</span><span class="token operator">^</span>2K<span class="token operator">|</span>       三间接     <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">-></span>256block区块<span class="token operator">--</span><span class="token operator">-></span><span class="token number">256</span>×<span class="token number">256</span>个区块<span class="token operator">--</span><span class="token operator">-></span><span class="token number">256</span>×<span class="token number">256</span>×<span class="token number">256</span>个区块<span class="token operator">--</span><span class="token operator">-></span><span class="token number">256</span><span class="token operator">^</span>3K<span class="token operator">=</span>16GB</code></pre></li><li><p>Data Block</p><ul><li><p>原则上，区块划分完成以后就不能再次修改</p></li><li><p>每个区块内只能放置一个文件</p></li><li><p>如果文件大于区块的大小，则会占用多个区块</p></li><li><p>文件小于区块大小，则区块剩下的容量就会浪费</p></li></ul></li></ul><table><thead><tr><th>Block大小</th><th>1KB</th><th>2KB</th><th>4KB</th></tr></thead><tbody><tr><td>最大单一文件限制</td><td>16GB</td><td>256GB</td><td>2TB</td></tr><tr><td>最大文件系统的容量</td><td>2TB</td><td>8TB</td><td>16TB</td></tr></tbody></table><h5 id="dumpe2fs命令"><a href="#dumpe2fs命令" class="headerlink" title="dumpe2fs命令"></a>dumpe2fs命令</h5><pre class=" language-bash"><code class="language-bash">$ dumpe2fs <span class="token punctuation">[</span>-bh<span class="token punctuation">]</span> 设备文件名选项与参数：-b：列出保留为坏道的部分-h：仅列出superblock的内容$ blkid <span class="token comment" spellcheck="true">#显示出目前系统被格式化的设备</span>/dev/loop0: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/loop1: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/loop2: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/loop3: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/loop4: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/loop5: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/loop6: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/loop7: TYPE<span class="token operator">=</span><span class="token string">"squashfs"</span>/dev/nvme0n1p1: LABEL<span class="token operator">=</span><span class="token string">"SYSTEM"</span> UUID<span class="token operator">=</span><span class="token string">"C6A3-B7DE"</span> TYPE<span class="token operator">=</span><span class="token string">"vfat"</span> PARTLABEL<span class="token operator">=</span><span class="token string">"EFI system partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"3e25bbec-3e10-4901-8c33-ceeadbc12d69"</span>/dev/nvme0n1p3: LABEL<span class="token operator">=</span><span class="token string">"Windows"</span> UUID<span class="token operator">=</span><span class="token string">"B438A7FA38A7BA2E"</span> TYPE<span class="token operator">=</span><span class="token string">"ntfs"</span> PARTLABEL<span class="token operator">=</span><span class="token string">"Basic data partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"f6d4beeb-a0dc-48ed-827b-b63cf7cd1084"</span>/dev/nvme0n1p4: LABEL<span class="token operator">=</span><span class="token string">"WinRE_DRV"</span> UUID<span class="token operator">=</span><span class="token string">"E60CA85F0CA82C8D"</span> TYPE<span class="token operator">=</span><span class="token string">"ntfs"</span> PARTLABEL<span class="token operator">=</span><span class="token string">"Basic data partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"58abc9c9-e11e-4dd8-9a3f-2dab172fa72c"</span>/dev/nvme0n1p5: UUID<span class="token operator">=</span><span class="token string">"2f6b6a4f-29e2-4a7e-a790-523499851033"</span> TYPE<span class="token operator">=</span><span class="token string">"ext4"</span> PARTUUID<span class="token operator">=</span><span class="token string">"150f0697-4ae7-4957-830f-a91e40d03577"</span> <span class="token comment" spellcheck="true">#ext4文件系统</span>$ dumpe2fs -h /dev/nvme0n1p5dumpe2fs 1.44.1 <span class="token punctuation">(</span>24-Mar-2018<span class="token punctuation">)</span>Filesystem volume name:   <span class="token operator">&lt;</span>none<span class="token operator">></span>Last mounted on:          /Filesystem UUID:          2f6b6a4f-29e2-4a7e-a790-523499851033Filesystem magic number:  0xEF53Filesystem revision <span class="token comment" spellcheck="true">#:    1 (dynamic)</span>Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csumFilesystem flags:         signed_directory_hashDefault <span class="token function">mount</span> options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              6225920Block count:              24903680Reserved block count:     1245184Free blocks:              5501844Free inodes:              5360200First block:              0Block size:               4096Fragment size:            4096Group descriptor size:    64Reserved GDT blocks:      1024Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Flex block group size:    16Filesystem created:       Sat Aug 25 09:19:21 2018Last <span class="token function">mount</span> time:          Thu Apr 11 08:37:34 2019Last <span class="token function">write</span> time:          Thu Apr 11 08:37:34 2019Mount count:              676Maximum <span class="token function">mount</span> count:      -1Last checked:             Sat Aug 25 09:19:21 2018Check interval:           0 <span class="token punctuation">(</span><span class="token operator">&lt;</span>none<span class="token operator">></span><span class="token punctuation">)</span>Lifetime writes:          2040 GBReserved blocks uid:      0 <span class="token punctuation">(</span>user root<span class="token punctuation">)</span>Reserved blocks gid:      0 <span class="token punctuation">(</span>group root<span class="token punctuation">)</span>First inode:              11Inode size:              256Required extra isize:     32Desired extra isize:      32Journal inode:            8First orphan inode:       3408086Default directory hash:   half_md4Directory Hash Seed:      b1992519-4a57-44b1-a21c-5a97eaff4950Journal backup:           inode blocksChecksum type:            crc32cChecksum:                 0xc872187fJournal features:         journal_incompat_revoke journal_64bit journal_checksum_v3Journal size:             512MJournal length:           131072Journal sequence:         0x001fb5bdJournal start:            1Journal checksum type:    crc32cJournal checksum:         0x3e35097a</code></pre><h4 id="与目录树的关系"><a href="#与目录树的关系" class="headerlink" title="与目录树的关系"></a>与目录树的关系</h4><ul><li>目录</li></ul><p>当我们在Linux下建立一个目录时， <strong>文件系统会分配一个inode与至少一个区块给该目录</strong>， inode记录目录的权限和属性，而区块记录目录下的文件名和文件名占用的inode号码。这也体现了 <strong>Linux下一切都是文件</strong>的本质，回忆，、之前的bolg中我们讨论过如果只拥有目录的r权限就可以用ls列出所有的文件内容，其实目录就是一个文件只要有r权限就可以阅读，w权限只能修改或删除该目录下的文件，而x执行权限才能执行并通过目录树访问该目录下的其他文件。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ls</span> -li <span class="token comment" spellcheck="true">#-i选项可以观察inode号码</span>total 125379387 drwxr-xr-x 3 root root 4096 8月  26  2018 Android5244055 drwxr-xr-x 3 root root 4096 8月  26  2018 AndroidStudioProjects5259883 drwxr-xr-x 3 root root 4096 11月 10 10:09 PycharmProjects$ ll -d / /boot /usr/sbin /proc /sysdrwxr-xr-x  27 root root  4096 4月   7 11:41 // <span class="token comment" spellcheck="true">#一个4k区块</span>drwxr-xr-x   4 root root  4096 4月   7 11:41 /boot/dr-xr-xr-x 326 root root     0 4月  11 08:37 /proc/ <span class="token comment" spellcheck="true">#内存数据，不占磁盘容量</span>dr-xr-xr-x  13 root root     0 4月  11 08:37 /sys/drwxr-xr-x   2 root root 12288 3月  22 09:16 /usr/sbin/ <span class="token comment" spellcheck="true">#3个4K区块</span></code></pre><ul><li>文件</li></ul><p>文件系统会分配一个inode与正好的区块给新建文件。</p><ul><li>目录树读取</li></ul><pre class=" language-c"><code class="language-c">inode<span class="token operator">--</span><span class="token operator">></span>目录文件区块<span class="token operator">--</span><span class="token operator">></span>inode号码<span class="token operator">--</span><span class="token operator">></span>目录文件区块<span class="token operator">--</span><span class="token operator">-></span>……<span class="token operator">--</span><span class="token operator">-></span>inode号码<span class="token operator">--</span><span class="token operator">-></span>文件区块</code></pre><ul><li>文件系统大小与磁盘读取性能</li></ul><p>文件写入通常是离散的，如果离散的程度较大，即使我们使用索引式文件系统，也还是会造成文件读取效率下降的问题。</p><h4 id="ext2-ext3-ext4文件的存取与日志式文件系统的功能"><a href="#ext2-ext3-ext4文件的存取与日志式文件系统的功能" class="headerlink" title="ext2/ext3/ext4文件的存取与日志式文件系统的功能"></a>ext2/ext3/ext4文件的存取与日志式文件系统的功能</h4><p>在我们想要新增一个文件时，，文件系统的操作是：</p><ul><li>1.确定用户是否对目录有w或x的权限</li><li>2.根据inode对照表找出没有使用的inode号码，并写入权限/文件</li><li>3.根据区块对照表找到没有使用的区块号码，将数据写入区块中，并更新inode的区块指向数据</li><li>4.将刚刚写入的inode区块与区块数据同步更新inode对照表和区块对照表，并更新超级区块的内容</li></ul><p>数据的不一致状态（Inconsistent）状态，如果在某些计算条件下，比如机房突然断电，系统内核发生错误的情况，文件系统只写入了inode对照表与数据区块，最后一个同步更新元数据的步骤还未完成。面对这种情况，早期ext2我们要对整个文件系统进行检查使用<code>e2fsck</code>命令，这样消耗大量的时间也就催生了后来的日志式文件系统（Journaling filesystem）。</p><p>日志式文件系统记录一个文件时，：</p><ul><li>首先在日志记录区块中记录某个文件准备要写入的信息</li><li>世界写入更新metadata的数据</li><li>完成更新后，在日志记录区块中完成该文件的记录</li></ul><p>在日志式文件系统中，我们只要检查日志文件区块就可以知道那个文件发生了问题</p><h4 id="Linux文件系统的运行"><a href="#Linux文件系统的运行" class="headerlink" title="Linux文件系统的运行"></a>Linux文件系统的运行</h4><p>Linux 通过异步处理(asynchronously)的方式来解决磁盘读写的效率问题。当系统加载一个文件到内存后，如果文件爱你未被修改 则状态为 <strong><em>Clean</em></strong> ，如果被修改过了，则状态为<strong><em>Dirty</em></strong>，此时操作都在内存中执行，并没有写入到磁盘中。</p><ul><li>系统会将常用文件放入磁盘中，来加速文件的读写操作</li><li>sync命令可以将内存中dirty文件写入磁盘</li><li>正常关机是会调用sync</li><li>不正常关机可能会造成文件系统的损坏<h4 id="挂载点的意义（mount-point）"><a href="#挂载点的意义（mount-point）" class="headerlink" title="挂载点的意义（mount point）"></a>挂载点的意义（mount point）</h4></li></ul><p><strong><em>挂载点一定是目录，该目录为进入该文件系统的入口</em></strong>，所谓挂载就是文件系统与目录树的结合。文件系统必须挂载之后才能使用。</p><p><strong><em>同一个文件系统的某个inode只会对应到一个文件</em></strong></p><h4 id="其他Linux支持的文件系统与VFS"><a href="#其他Linux支持的文件系统与VFS" class="headerlink" title="其他Linux支持的文件系统与VFS"></a>其他Linux支持的文件系统与VFS</h4><p>每种文件系统都有自己不同的特性，比如xfs支持大容量大文件，Reiserfs支持更小型文件，一般Linux支持的系统有：</p><ul><li>传统文件系统： ext2，minix，FAT，iso9660（光盘）等</li><li>日志式文件系统：ext3,ext4,ReiserFS。Windows’NTFS，IBM’sJFS,SGI’sXFS,ZFS</li><li>网络文件系统：NFS，SMBFS</li></ul><p>Linux VFS(Virtual Filesystem Switch),这个内核功能管理整个Linux 的文件系统。我们不需要自己来指定文件系统的类型，VFS会自动提我们识别。</p><h4 id="XFS文件系统简介"><a href="#XFS文件系统简介" class="headerlink" title="XFS文件系统简介"></a>XFS文件系统简介</h4><p>ext文件系统的一个软肋是格式化的速度超慢。由于虚拟化技术的应用，性能上xfs会更站优势。</p><pre class=" language-c"><code class="language-c"><span class="token operator">|</span>数据区data section<span class="token operator">|</span>文件系统活动登录区log section<span class="token operator">|</span>实时运行区realtime section<span class="token operator">|</span><span class="token operator">|</span>i<span class="token operator">|</span>b<span class="token operator">|</span>iT<span class="token operator">|</span>bT<span class="token operator">|</span>SB<span class="token operator">|</span>dec <span class="token operator">|</span>记录文件变化可以指定为外部磁盘 <span class="token operator">|</span>     extent    stripe   <span class="token operator">|</span></code></pre><p>可以通过命令<code>xfs_info</code>来观察。</p><h3 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h3><h4 id="磁盘与目录的容量"><a href="#磁盘与目录的容量" class="headerlink" title="磁盘与目录的容量"></a>磁盘与目录的容量</h4><h6 id="df：列出文件系统的整体磁盘使用量"><a href="#df：列出文件系统的整体磁盘使用量" class="headerlink" title="df：列出文件系统的整体磁盘使用量"></a>df：列出文件系统的整体磁盘使用量</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">df</span> <span class="token punctuation">[</span>-ahikHTm<span class="token punctuation">]</span> <span class="token punctuation">[</span>目录或文件名<span class="token punctuation">]</span>选项与参数： -a :列出所有的文件系统，包括系统特有的/proc等文件系统 -k :以KBytes的容量显示各文件系统 -m :以MBytes的容量显示各文件系统*-h :以人们较易接受的GBytes等格式自行显示 -H :以M<span class="token operator">=</span>1000k替换M<span class="token operator">=</span>1024k的进位 -T :连同该硬盘分区的文件系统格式也一起列出*-i :不用磁盘容量，而以inode的数量来显示$ <span class="token function">df</span>Filesystem     1K-blocks     Used Available Use% Mounted onudev             8053080        0   8053080   0% /devtmpfs            1616676     2164   1614512   1% /run/dev/nvme0n1p5  97527092 74703772  17826200  81% /tmpfs            8083376     1908   8081468   1% /dev/shmtmpfs               5120        4      5116   1% /run/locktmpfs            8083376        0   8083376   0% /sys/fs/cgroup*Filessystem <span class="token keyword">:</span> 代表该文件系统是在哪个磁盘分区，所以列出设备名称*1K-blocks   <span class="token keyword">:</span> 说明下面的数字单位是1kb，可利用 -h或 -m来改变容量*Used        <span class="token keyword">:</span> 使用掉的磁盘空间*Available   <span class="token keyword">:</span> 剩余磁盘空间大小*Use%        <span class="token keyword">:</span> 磁盘使用率*Mounted on  <span class="token keyword">:</span> 挂载点</code></pre><p>其中的<code>/dev/shm/</code>目录是利用内存虚拟出来的磁盘空间。</p><h6 id="du：查看文件系统的磁盘使用量（查看目录所占磁盘空间）"><a href="#du：查看文件系统的磁盘使用量（查看目录所占磁盘空间）" class="headerlink" title="du：查看文件系统的磁盘使用量（查看目录所占磁盘空间）"></a>du：查看文件系统的磁盘使用量（查看目录所占磁盘空间）</h6><pre class=" language-bash"><code class="language-bash">$ <span class="token function">du</span> <span class="token punctuation">[</span>-ahskm<span class="token punctuation">]</span> 文件或目录名称选项与参数： -a <span class="token keyword">:</span> 列出所有的文件与目录容量，因为默认仅统计目录下面的文件量 -h <span class="token keyword">:</span> 以易读方式显示*-s <span class="token keyword">:</span> 仅列出总量，而不是每个别的目录的占用量 -S <span class="token keyword">:</span> 不包括子目录下的总计 -k <span class="token keyword">:</span> 以KBytes -m <span class="token keyword">:</span> 以MBytes</code></pre><h4 id="硬链接与符号链接：ln"><a href="#硬链接与符号链接：ln" class="headerlink" title="硬链接与符号链接：ln"></a>硬链接与符号链接：ln</h4><p>Linux下链接文件为两种：</p><ul><li>符号链接 类似快捷方式</li><li>硬链接 文件系统通过inode来新建的文件名</li></ul><h5 id="硬链接-Hard-Link-（实际链接）"><a href="#硬链接-Hard-Link-（实际链接）" class="headerlink" title="硬链接 Hard Link （实际链接）"></a>硬链接 Hard Link （实际链接）</h5><p>每个文件占用一个inode，读取文件必须经过目录的文件名指向到正确的inode号码。<strong><em>硬链接只是在某个目录下新增一条文件名链接到某inode号码的关联记录而已。</em></strong><br><img src="https://s2.ax1x.com/2019/04/16/AxKOvn.png" alt="AxKOvn.png"></p><p>这样建立硬链接的一好处是安全，如图，当我们删除掉block1的对应目录时，真正的inode与文件内容实际上仍然存在，这样不会删除真正的文件。但是硬链接也是有限制的：</p><ul><li>不能跨文件系统（这个显而易见）</li><li>不能链接目录 如果要建立一个目录的硬链接，不仅仅是要为目录名建立硬链接，还要为目录下的每一个文件都建立硬链接，这样会造成非常大的环境复杂度，所以目前还不支持目录建立硬链接。</li></ul><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ln</span> <span class="token operator">&lt;</span>源文件<span class="token operator">></span> <span class="token operator">&lt;</span>目标文件目录<span class="token operator">></span></code></pre><h5 id="符号链接-Symbolic-Link-（快捷方式）"><a href="#符号链接-Symbolic-Link-（快捷方式）" class="headerlink" title="符号链接 Symbolic Link （快捷方式）"></a>符号链接 Symbolic Link （快捷方式）</h5><p>符号链接就是建立一个独立的文件，这个文件会让数据的读取指向它链接的文件的文件名。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ln</span> -s <span class="token operator">&lt;</span>源文件<span class="token operator">></span> <span class="token operator">&lt;</span>目标文件目录<span class="token operator">></span></code></pre><p><a href="https://imgchr.com/i/AxQKe0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/16/AxQKe0.png" alt="AxQKe0.png"></a></p><h3 id="磁盘的分区，格式化，检验与挂载"><a href="#磁盘的分区，格式化，检验与挂载" class="headerlink" title="磁盘的分区，格式化，检验与挂载"></a>磁盘的分区，格式化，检验与挂载</h3><p>新增磁盘的操作：</p><ul><li>对磁盘进行划分</li><li>对磁盘进行格式化，建立西欧他那个可用的文件系统</li><li>建立挂载点，将文件系统挂载上来</li></ul><h4 id="观察磁盘分区状态"><a href="#观察磁盘分区状态" class="headerlink" title="观察磁盘分区状态"></a>观察磁盘分区状态</h4><h6 id="lsblk（list-block-device）"><a href="#lsblk（list-block-device）" class="headerlink" title="lsblk（list block device）"></a>lsblk（list block device）</h6><pre class=" language-bash"><code class="language-bash">$ lsblk <span class="token punctuation">[</span>-dfimpt<span class="token punctuation">]</span> <span class="token punctuation">[</span>device<span class="token punctuation">]</span>选项与参数： -d <span class="token keyword">:</span> 仅列出磁盘本身，不列出磁盘的分区数据×-f <span class="token keyword">:</span> 列出磁盘内的文件系统名称 -i <span class="token keyword">:</span> 使用ASCII字符输出 -m <span class="token keyword">:</span> 输出设备的权限信息 -p <span class="token keyword">:</span> 列出完整文件名 -t <span class="token keyword">:</span> 列出磁盘设备的详细文件数据，包括磁盘阵列信息等NAME <span class="token keyword">:</span> 设备文件名MAJ:MIN <span class="token keyword">:</span> 内核识别的设备就是通过这两个代码来区分，主要与次要设备代码RM <span class="token keyword">:</span> 是否为可卸载设备SIZE <span class="token keyword">:</span> 容量RO <span class="token keyword">:</span> 是否为只读设备TYPE <span class="token keyword">:</span> 是磁盘，分区，还是制度存储器romMOUNTPOINT <span class="token keyword">:</span> 挂载点</code></pre><h6 id="blkid-列出设备的UUID等参数"><a href="#blkid-列出设备的UUID等参数" class="headerlink" title="blkid 列出设备的UUID等参数"></a>blkid 列出设备的UUID等参数</h6><p>UUID：universally unique identifier 全局唯一标识符</p><h6 id="parted-列出磁盘的分区表类型和分区信息"><a href="#parted-列出磁盘的分区表类型和分区信息" class="headerlink" title="parted 列出磁盘的分区表类型和分区信息"></a>parted 列出磁盘的分区表类型和分区信息</h6><pre class=" language-bash"><code class="language-bash">$ parted 设备名 print$ parted /dev/nvme0n1 printModel: INTEL SSDPEKKF256G8L <span class="token punctuation">(</span>nvme<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 制造厂商 模块名称</span>Disk /dev/nvme0n1: 256GB            <span class="token comment" spellcheck="true"># 磁盘容量</span>Sector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512B/512B <span class="token comment" spellcheck="true"># 磁盘的每个逻辑/物理扇区容量</span>Partition Table: gpt                <span class="token comment" spellcheck="true"># 分区表格式</span>Disk Flags:Number  Start   End    Size    File system  Name                          Flags 1      1049kB  274MB  273MB   fat32        EFI system partition          boot, hidden, esp 2      274MB   290MB  16.8MB               Microsoft reserved partition  msftres 3      290MB   153GB  153GB   ntfs         Basic data partition          msftdata 5      153GB   255GB  102GB   ext4 4      255GB   256GB  1049MB  ntfs         Basic data partition          hidden, diag</code></pre><h4 id="磁盘分区：gdisk-fdisk"><a href="#磁盘分区：gdisk-fdisk" class="headerlink" title="磁盘分区：gdisk/fdisk"></a>磁盘分区：gdisk/fdisk</h4><p><strong><em>MBR分区表使用fdisk分区，GPT使用gdisk分区</em></strong></p><h6 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h6><pre class=" language-bash"><code class="language-bash">$ gdisk /dev/nvme0n1GPT <span class="token function">fdisk</span> <span class="token punctuation">(</span>gdisk<span class="token punctuation">)</span> version 1.0.3Partition table scan:  MBR: protective  BSD: not present  APM: not present  GPT: presentFound valid GPT with protective MBR<span class="token punctuation">;</span> using GPT.Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> help<span class="token punctuation">)</span>: ?b    back up GPT data to a <span class="token function">file</span>c    change a partition<span class="token string">'s named    delete a partition  #删除一个分区i    show detailed information on a partitionl    list known partition typesn    add a new partition   #新建一个分区o    create a new empty GUID partition table (GPT)p    print the partition table  #打印分区表q    quit without saving changes #不保存分区直接离开gdiskr    recovery and transformation options (experts only)s    sort partitionst    change a partition'</span>s <span class="token function">type</span> code<span class="token function">v</span>    verify diskw    <span class="token function">write</span> table to disk and <span class="token keyword">exit</span>  <span class="token comment" spellcheck="true">#保存分区后离开gdisk'</span>x    extra functionality <span class="token punctuation">(</span>experts only<span class="token punctuation">)</span>?    print this menu</code></pre><p>磁盘分区是针对整个磁盘而不是只是一个分区所以不要在设备文件后附带数字。</p><h6 id="gdisk新增分区"><a href="#gdisk新增分区" class="headerlink" title="gdisk新增分区"></a>gdisk新增分区</h6><pre class=" language-bash"><code class="language-bash">$ gdisk /dev/nvme0n1GPT <span class="token function">fdisk</span> <span class="token punctuation">(</span>gdisk<span class="token punctuation">)</span> version 1.0.3Partition table scan:  MBR: protective  BSD: not present  APM: not present  GPT: presentFound valid GPT with protective MBR<span class="token punctuation">;</span> using GPT.Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> help<span class="token punctuation">)</span>: pDisk /dev/nvme0n1: 500118192 sectors, 238.5 GiBModel: INTEL SSDPEKKF256G8LSector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512/512 bytesDisk identifier <span class="token punctuation">(</span>GUID<span class="token punctuation">)</span>: 7D95F9F1-8D34-4BA7-B555-9C68C5D996D6Partition table holds up to 128 entriesMain partition table begins at sector 2 and ends at sector 33First usable sector is 34, last usable sector is 500118158Partitions will be aligned on 2048-sector boundariesTotal <span class="token function">free</span> space is 4717 sectors <span class="token punctuation">(</span>2.3 MiB<span class="token punctuation">)</span>Number  Start <span class="token punctuation">(</span>sector<span class="token punctuation">)</span>    End <span class="token punctuation">(</span>sector<span class="token punctuation">)</span>  Size       Code  Name   1            2048          534527   260.0 MiB   EF00  EFI system partition   2          534528          567295   16.0 MiB    0C01  Microsoft reserved <span class="token punctuation">..</span>.   3          567296       277868543   132.2 GiB   0700  Basic data partition   4       277868544       298838015   10.0 GiB    0700  Basic data partition   5       298840064       498069503   95.0 GiB    8300   6       498069504       500117503   1000.0 MiB  2700  Basic data partitionCommand <span class="token punctuation">(</span>? <span class="token keyword">for</span> help<span class="token punctuation">)</span>: nPartition number <span class="token punctuation">(</span>7-128, default 7<span class="token punctuation">)</span>: 7First sector <span class="token punctuation">(</span>34-500118158, default <span class="token operator">=</span> 298838016<span class="token punctuation">)</span> or <span class="token punctuation">{</span>+-<span class="token punctuation">}</span>size<span class="token punctuation">{</span>KMGTP<span class="token punctuation">}</span>: 298838016Last sector <span class="token punctuation">(</span>298838016-298840063, default <span class="token operator">=</span> 298840063<span class="token punctuation">)</span> or <span class="token punctuation">{</span>+-<span class="token punctuation">}</span>size<span class="token punctuation">{</span>KMGTP<span class="token punctuation">}</span>: +1GLast sector <span class="token punctuation">(</span>298838016-298840063, default <span class="token operator">=</span> 298840063<span class="token punctuation">)</span> or <span class="token punctuation">{</span>+-<span class="token punctuation">}</span>size<span class="token punctuation">{</span>KMGTP<span class="token punctuation">}</span>: 298838017Current <span class="token function">type</span> is <span class="token string">'Linux filesystem'</span>Hex code or GUID <span class="token punctuation">(</span>L to show codes, Enter <span class="token operator">=</span> 8300<span class="token punctuation">)</span>:Changed <span class="token function">type</span> of partition to <span class="token string">'Linux filesystem'</span>Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> help<span class="token punctuation">)</span>: pDisk /dev/nvme0n1: 500118192 sectors, 238.5 GiBModel: INTEL SSDPEKKF256G8LSector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512/512 bytesDisk identifier <span class="token punctuation">(</span>GUID<span class="token punctuation">)</span>: 7D95F9F1-8D34-4BA7-B555-9C68C5D996D6Partition table holds up to 128 entriesMain partition table begins at sector 2 and ends at sector 33First usable sector is 34, last usable sector is 500118158Partitions will be aligned on 2048-sector boundariesTotal <span class="token function">free</span> space is 4715 sectors <span class="token punctuation">(</span>2.3 MiB<span class="token punctuation">)</span>Number  Start <span class="token punctuation">(</span>sector<span class="token punctuation">)</span>    End <span class="token punctuation">(</span>sector<span class="token punctuation">)</span>  Size       Code  Name   1            2048          534527   260.0 MiB   EF00  EFI system partition   2          534528          567295   16.0 MiB    0C01  Microsoft reserved <span class="token punctuation">..</span>.   3          567296       277868543   132.2 GiB   0700  Basic data partition   4       277868544       298838015   10.0 GiB    0700  Basic data partition   5       298840064       498069503   95.0 GiB    8300   6       498069504       500117503   1000.0 MiB  2700  Basic data partition   7       298838016       298838017   1024 bytes  8300  Linux filesystem</code></pre><h6 id="partprobe更新Linux内核的分区表信息"><a href="#partprobe更新Linux内核的分区表信息" class="headerlink" title="partprobe更新Linux内核的分区表信息"></a>partprobe更新Linux内核的分区表信息</h6><pre class=" language-bash"><code class="language-bash">$ partprobe <span class="token punctuation">[</span>-s<span class="token punctuation">]</span>$ lsblk /dev/nvme0n1 <span class="token comment" spellcheck="true"># 实际的磁盘分区状态</span>$ <span class="token function">cat</span> /proc/partitions <span class="token comment" spellcheck="true">#内核的分区记录</span></code></pre><h4 id="磁盘格式化，创建文件系统"><a href="#磁盘格式化，创建文件系统" class="headerlink" title="磁盘格式化，创建文件系统"></a>磁盘格式化，创建文件系统</h4><p>分区完毕以后就要进行磁盘的格式化，这样才能得到可以使用文件系统。就是使用make filesystem，mkfs指令。</p><p>首先键入<code>mkfs</code>，点击两下[Tab]，就出现了mkfs大家族。</p><pre class=" language-bash"><code class="language-bash">mkfs         mkfs.ext2    mkfs.fat     mkfs.ntfsmkfs.bfs     mkfs.ext3    mkfs.minix   mkfs.vfatmkfs.cramfs  mkfs.ext4    mkfs.msdos$ mkfs.ext4 <span class="token punctuation">[</span>-b size<span class="token punctuation">]</span> <span class="token punctuation">[</span>-L label<span class="token punctuation">]</span> 设备名称$ mkfs.ext4 /dev/nvme0n1p4 <span class="token comment" spellcheck="true">#格式化为ext4文件系统</span>mke2fs 1.44.1 <span class="token punctuation">(</span>24-Mar-2018<span class="token punctuation">)</span>/dev/nvme0n1p4 contains a ntfs <span class="token function">file</span> system labelled <span class="token string">'New Volume'</span>Proceed anyway? <span class="token punctuation">(</span>y,N<span class="token punctuation">)</span> yDiscarding device blocks: <span class="token keyword">done</span>Creating filesystem with 2621184 4k blocks and 655360 inodesFilesystem UUID: 38cdd582-dff7-4be3-8e55-0cb51fea7c4aSuperblock backups stored on blocks:    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632Allocating group tables: <span class="token keyword">done</span>Writing inode tables: <span class="token keyword">done</span>Creating journal <span class="token punctuation">(</span>16384 blocks<span class="token punctuation">)</span>: <span class="token keyword">done</span>Writing superblocks and filesystem accounting information: <span class="token keyword">done</span></code></pre><h4 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h4><h6 id="xfs-repair处理XFS文件系统"><a href="#xfs-repair处理XFS文件系统" class="headerlink" title="xfs_repair处理XFS文件系统"></a>xfs_repair处理XFS文件系统</h6><pre class=" language-bash"><code class="language-bash">$ xfs_repair <span class="token punctuation">[</span>-fnd<span class="token punctuation">]</span> 设备名称选项与参数：-f ： 后面的设备其实是个文件而不是实体设备-n ： 单纯检查而不修改文件系统的任何数据-d ： 单人维护模式下，针对根目录的修复，很危险</code></pre><p>需要注意的是文件系统修复时不能被挂载。</p><ul><li>fsck.ext4处理ext4文件系统</li></ul><pre class=" language-bash"><code class="language-bash">$ fsck.ext4 <span class="token punctuation">[</span>-pf<span class="token punctuation">]</span> <span class="token punctuation">[</span>-b 超级区块<span class="token punctuation">]</span> 设备名称选项与参数：-p ： 当文件系统修复时如果有需要回复y的动作，直接回复y-f ： 强制检查，一般来说fsck弱国没有发现unclean的标识不会检查-D ： 针对文件系统下的目录进行最优化配置-b ： 后接超级区块的位置$ dumpe2fs -h /dev/nvme0n1p4 <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'Blocks per group'</span>dumpe2fs 1.44.1 <span class="token punctuation">(</span>24-Mar-2018<span class="token punctuation">)</span>Blocks per group:         32768$  fsck.ext4 -b 32768 /dev/nvme0n1p4e2fsck 1.44.1 <span class="token punctuation">(</span>24-Mar-2018<span class="token punctuation">)</span>/dev/nvme0n1p4 was not cleanly unmounted, check forced.Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary informationBlock bitmap differences:  +<span class="token punctuation">(</span>32768--33794<span class="token punctuation">)</span> +<span class="token punctuation">(</span>98304--99330<span class="token punctuation">)</span> +<span class="token punctuation">(</span>163840--164866<span class="token punctuation">)</span> +<span class="token punctuation">(</span>229376--230402<span class="token punctuation">)</span> +<span class="token punctuation">(</span>294912--295938<span class="token punctuation">)</span> +<span class="token punctuation">(</span>819200--820226<span class="token punctuation">)</span> +<span class="token punctuation">(</span>884736--885762<span class="token punctuation">)</span> +<span class="token punctuation">(</span>1605632--1606658<span class="token punctuation">)</span>Fix<span class="token operator">&lt;</span>y<span class="token operator">></span>? <span class="token function">yes</span>Inode bitmap differences: Group 1 inode bitmap does not match checksum.FIXED./dev/nvme0n1p4: ***** FILE SYSTEM WAS MODIFIED *****/dev/nvme0n1p4: 11/655360 files <span class="token punctuation">(</span>0.0% non-contiguous<span class="token punctuation">)</span>, 66753/2621184 blocks$ fsck.ext4 /dev/nvme0n1p4e2fsck 1.44.1 <span class="token punctuation">(</span>24-Mar-2018<span class="token punctuation">)</span>/dev/nvme0n1p4: clean, 11/655360 files, 66753/2621184 blocks$  fsck.ext4 -f /dev/nvme0n1p4e2fsck 1.44.1 <span class="token punctuation">(</span>24-Mar-2018<span class="token punctuation">)</span>Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary information/dev/nvme0n1p4: 11/655360 files <span class="token punctuation">(</span>0.0% non-contiguous<span class="token punctuation">)</span>, 66753/2621184 blocks</code></pre><h4 id="文件系统挂载与卸载mount"><a href="#文件系统挂载与卸载mount" class="headerlink" title="文件系统挂载与卸载mount"></a>文件系统挂载与卸载mount</h4><ul><li>单一文件系统不应该被重复挂载在不同的挂载点中</li><li>单一目录不应该重复挂载多个文件系统</li><li>作为挂载点的目录。理论上都应该是空目录</li></ul><p>假设挂载点目录并不为空那么挂载了文件系统之后，<strong><em>目录下的问家你会暂时消失</em></strong></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mount</span> -a$ <span class="token function">mount</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span>$ <span class="token function">mount</span> <span class="token punctuation">[</span>-t 文件系统<span class="token punctuation">]</span> LABEL<span class="token operator">=</span><span class="token string">''</span> 挂载点$ <span class="token function">mount</span> <span class="token punctuation">[</span>-t 文件系统<span class="token punctuation">]</span> UUID<span class="token operator">=</span><span class="token string">''</span> 挂载点$ <span class="token function">mount</span> <span class="token punctuation">[</span>-t 文件系统<span class="token punctuation">]</span> 设备文件名 挂载点选项与参数：-a ：依照配置文件/etc/fstab的数据将所有未挂载的磁盘都挂在上来-l ：显示label信息-t ：加制定的文件系统种类-n ：不将数据写入/etc/mtab中-o ：加参数</code></pre><p>Linux通过：</p><ul><li><code>/etc/filesystem</code>：系统制定的测试挂载文件系统的优先级</li><li><code>/proc/filesystem</code>：Linux系统已经加载的文件系统类型<br>```bash<br>$ unmount [-fn] 设备文件名或挂载点<br>选项与参数：</li></ul><p>-f : 强制卸载，可用在类似网络文件系统NFS无法读取到的前提下<br>-l : 立刻卸载文件系统<br>-n : 不更新/etc/mtab</p><pre><code>#### 磁盘文件系统参数自定义###### mknodLinux下一切都是文件，那么文件如何代表设备，***是通过major和minor这两个数值来替代***。```bash$ mknod 设备文件名 [bcp] [Major] [Minor]选项与参数：设备种类：b ： 设置设备名称为一个外接储存设备文件c ： 设置设备名称为一个外接输入设备文件f ： 设置设备名称为一个FIFO文件</code></pre><h6 id="xfs-admin修改UUID与Label-name"><a href="#xfs-admin修改UUID与Label-name" class="headerlink" title="xfs_admin修改UUID与Label name"></a>xfs_admin修改UUID与Label name</h6><pre class=" language-bash"><code class="language-bash">$ xfs_admin <span class="token punctuation">[</span>-lu<span class="token punctuation">]</span> <span class="token punctuation">[</span>-L label<span class="token punctuation">]</span> <span class="token punctuation">[</span>-U UUID<span class="token punctuation">]</span> 设备文件名选项与参数：-l <span class="token keyword">:</span> 列出设备的label name-u <span class="token keyword">:</span> 列出设备的UUID-L <span class="token keyword">:</span> 设置设备的label name-U <span class="token keyword">:</span> 设置设备的UUID$ uuidgen <span class="token comment" spellcheck="true">#产生一个UUID</span></code></pre><h6 id="tune2fs修改ext4的label-name-与UUID"><a href="#tune2fs修改ext4的label-name-与UUID" class="headerlink" title="tune2fs修改ext4的label name 与UUID"></a>tune2fs修改ext4的label name 与UUID</h6><pre class=" language-bash"><code class="language-bash">$ tune2fs <span class="token punctuation">[</span>-l<span class="token punctuation">]</span> <span class="token punctuation">[</span>-L label<span class="token punctuation">]</span> <span class="token punctuation">[</span>-U UUID<span class="token punctuation">]</span> 设备文件名选项与参数：-l <span class="token keyword">:</span> 类似于dump2fs的功能，将superblock内的数据读出-L <span class="token keyword">:</span> 设置设备的label name-U <span class="token keyword">:</span> 设置设备的UUID</code></pre><h3 id="设置启动挂载"><a href="#设置启动挂载" class="headerlink" title="设置启动挂载"></a>设置启动挂载</h3><p>一个很自然的诉求，就是我们希望系统在开机时自己主动挂载磁盘，否则每次都要mount操作一通实在是有些麻烦。</p><h4 id="启动挂载-etc-fstab及-etc-mtab"><a href="#启动挂载-etc-fstab及-etc-mtab" class="headerlink" title="启动挂载/etc/fstab及/etc/mtab"></a>启动挂载/etc/fstab及/etc/mtab</h4><p>系统挂载的限制：</p><ul><li><strong><em>根目录是必须挂载的而且要先于其他任何挂载点</em></strong></li><li><strong><em>其他挂载点必须为已经建立的目录，遵循FHS</em></strong></li><li><strong><em>所有挂载点在同一时间之内，只能挂载一次</em></strong></li><li><strong><em>所有硬盘分区在统一时间之内，只能挂载一下</em></strong></li><li><strong><em>如果卸载，必须先将工作目录移动到挂载点之外</em></strong></li></ul><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/fstab<span class="token comment" spellcheck="true"># /etc/fstab: static file system information.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Use 'blkid' to print the universally unique identifier for a</span><span class="token comment" spellcheck="true"># device; this may be used with UUID= as a more robust way to name devices</span><span class="token comment" spellcheck="true"># that works even if disks are added and removed. See fstab(5).</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># &lt;file system> &lt;mount point>   &lt;type>  &lt;options>       &lt;dump>  &lt;pass></span><span class="token comment" spellcheck="true"># / was on /dev/nvme0n1p5 during installation</span>UUID<span class="token operator">=</span>2f6b6a4f-29e2-4a7e-a790-523499851033 /               ext4    errors<span class="token operator">=</span>remount-ro 0       1<span class="token comment" spellcheck="true"># /boot/efi was on /dev/nvme0n1p1 during installation</span>UUID<span class="token operator">=</span>C6A3-B7DE  /boot/efi       vfat    umask<span class="token operator">=</span>0077      0       1/swapfile                                 none            swap    sw              0       0</code></pre><p><code>/etc/fstab</code>存储的就像我们利用mount命令挂载时所有参数和选项都写入的一个文件。还多余一个dump备份命令，和启动时是否使用fsck系统欧冠你检验有关。</p><p>这六个字段的内容 <strong><em>十分重要！</em></strong></p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>file system<span class="token operator">></span> <span class="token operator">&lt;</span>mount point<span class="token operator">></span>   <span class="token operator">&lt;</span>type<span class="token operator">></span>      <span class="token operator">&lt;</span>options<span class="token operator">></span>       <span class="token operator">&lt;</span>dump<span class="token operator">></span>  <span class="token operator">&lt;</span>pass<span class="token operator">></span><span class="token operator">&lt;</span> 设备/UUID等<span class="token operator">></span> <span class="token operator">&lt;</span>  挂 载 点  <span class="token operator">></span>   <span class="token operator">&lt;</span>文件系统<span class="token operator">></span>  <span class="token operator">&lt;</span>文件系统参数<span class="token operator">></span>      <span class="token operator">&lt;</span>dump<span class="token operator">></span>  <span class="token operator">&lt;</span>pass<span class="token operator">></span></code></pre><ul><li>第一栏：磁盘设备文件名/UUID/LABEL name</li></ul><p>这里的三个参数，填写任意一个都可以，建议使用blkid命令查询uuid来填写。</p><ul><li>第二栏：挂载点（mount name）</li></ul><p><strong><em>一定是目录</em></strong></p><ul><li>第三栏：磁盘分区的文件系统</li></ul><p>磁盘分区的文件系统，手动挂载时，系统可以自动检测，但是刚开机时系统并不能分析磁盘的文件系统格式，所以必须要手动写入。</p><ul><li>第四栏：文件系统参数</li></ul><table><thead><tr><th>参数</th><th>内容意义</th></tr></thead><tbody><tr><td>async/sync  异步/同步</td><td>设置磁盘是否以是否以异步方式运行，默认为async（性能较佳）</td></tr><tr><td>auto/noauto  自动/非自动</td><td>当执行mount -a时，此文件系统是否会被主动的检测挂载，默认为auto</td></tr><tr><td>rw/ro 可擦写/只读</td><td>设置ro后，不论是否设置w权限，都无法写入数据</td></tr><tr><td>exec/noexec 可执行/不可执行</td><td>限制文件系统是否可以[执行]的操作，不要随便使用</td></tr><tr><td>user/nouser 允许/不允许用户挂载</td><td>是否希望一般身份的用户是用moount命令挂载，</td></tr><tr><td>suid/nosuid 具有/不具有suid权限</td><td>是否允许SUID的存在</td></tr><tr><td>defaults</td><td>是否使用默认参数配置</td></tr></tbody></table><ul><li>第五栏：能否被dump备份命令作用</li><li>第六栏：是否检查过</li></ul><p>所以设置自动挂载只要将磁盘的信息写入<code>/etc/fstab</code>文件即可</p><pre class=" language-bash"><code class="language-bash">$ blkid/dev/nvme0n1: PTUUID<span class="token operator">=</span><span class="token string">"7d95f9f1-8d34-4ba7-b555-9c68c5d996d6"</span> PTTYPE<span class="token operator">=</span><span class="token string">"gpt"</span>/dev/nvme0n1p1: LABEL<span class="token operator">=</span><span class="token string">"SYSTEM"</span> UUID<span class="token operator">=</span><span class="token string">"C6A3-B7DE"</span> TYPE<span class="token operator">=</span><span class="token string">"vfat"</span> PARTLABEL<span class="token operator">=</span><span class="token string">"EFI system partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"3e25bbec-3e10-4901-8c33-ceeadbc12d69"</span>/dev/nvme0n1p2: PARTLABEL<span class="token operator">=</span><span class="token string">"Microsoft reserved partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"6396a370-a595-4cd8-80a4-3931e3d3df28"</span>/dev/nvme0n1p3: LABEL<span class="token operator">=</span><span class="token string">"Windows"</span> UUID<span class="token operator">=</span><span class="token string">"B438A7FA38A7BA2E"</span> TYPE<span class="token operator">=</span><span class="token string">"ntfs"</span> PARTLABEL<span class="token operator">=</span><span class="token string">"Basic data partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"f6d4beeb-a0dc-48ed-827b-b63cf7cd1084"</span>/dev/nvme0n1p4: UUID<span class="token operator">=</span><span class="token string">"38cdd582-dff7-4be3-8e55-0cb51fea7c4a"</span> TYPE<span class="token operator">=</span><span class="token string">"ext4"</span> PARTLABEL<span class="token operator">=</span><span class="token string">"Basic data partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"57487810-e2b8-47ff-a2f3-531981effd18"</span>/dev/nvme0n1p5: UUID<span class="token operator">=</span><span class="token string">"2f6b6a4f-29e2-4a7e-a790-523499851033"</span> TYPE<span class="token operator">=</span><span class="token string">"ext4"</span> PARTUUID<span class="token operator">=</span><span class="token string">"150f0697-4ae7-4957-830f-a91e40d03577"</span>/dev/nvme0n1p6: LABEL<span class="token operator">=</span><span class="token string">"WinRE_DRV"</span> UUID<span class="token operator">=</span><span class="token string">"E60CA85F0CA82C8D"</span> TYPE<span class="token operator">=</span><span class="token string">"ntfs"</span> PARTLABEL<span class="token operator">=</span><span class="token string">"Basic data partition"</span> PARTUUID<span class="token operator">=</span><span class="token string">"58abc9c9-e11e-4dd8-9a3f-2dab172fa72c"</span>$ <span class="token function">nano</span> /etc/fstab <span class="token comment" spellcheck="true">#可以自己修改一下文件排版</span>UUID<span class="token operator">=</span><span class="token string">"38cdd582-dff7-4be3-8e55-0cb51fea7c4a"</span> /home/jason/Device ext4 defaults 0 1$ <span class="token function">df</span> <span class="token comment" spellcheck="true">#观察一下磁盘是否已经挂载</span>Filesystem     1K-blocks     Used Available Use% Mounted onudev             8053080        0   8053080   0% /devtmpfs            1616676     2196   1614480   1% /run/dev/nvme0n1p5  97527092 75489768  17040204  82% /tmpfs            8083376     2156   8081220   1% /dev/shmtmpfs               5120        4      5116   1% /run/locktmpfs            8083376        0   8083376   0% /sys/fs/cgrouptmpfs            1616672       12   1616660   1% /run/user/121tmpfs            1616672       36   1616636   1% /run/user/1000/dev/sda1       15666400 11506912   4159488  74% /media/jason/E86B-1D06tmpfs            1616672        0   1616672   0% /run/user/0<span class="token comment" spellcheck="true"># 并没有被挂载</span>$ <span class="token function">umount</span> 磁盘 <span class="token comment" spellcheck="true">#如果被挂载，先卸载</span>$ <span class="token function">mount</span> -a <span class="token comment" spellcheck="true">#测试我们文件力度语法是否有错误，因为如果写错了，Linux可能无法启动</span>$ <span class="token function">df</span> /home/jason/Device <span class="token comment" spellcheck="true">#挂载成功</span>Filesystem     1K-blocks  Used Available Use% Mounted on/dev/nvme0n1p4  10254612    36888   9677104   1% /home/jason/Device</code></pre><p><code>/etc/fstab</code>是启动事配置文件，实际文件系统的挂载是记录到<code>/etc/mtab</code>和<code>/proc/mounts</code>中的，如果你的配置文件有问题，无法顺利启动进入担任模式中，<code>/etc/fstab</code>文件是只读模式时：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mount</span> -n -o remount,rw /</code></pre><p>即可。</p><p>重启df查看，发现设备已经自动挂载</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">reboot</span>$ <span class="token function">df</span>Filesystem     1K-blocks     Used Available Use% Mounted onudev             8053080        0   8053080   0% /devtmpfs            1616676     2164   1614512   1% /run/dev/nvme0n1p5  97527092 75506300  17023672  82% /tmpfs            8083376      648   8082728   1% /dev/shmtmpfs               5120        4      5116   1% /run/locktmpfs            8083376        0   8083376   0% /sys/fs/cgroup/dev/loop0         15104    15104         0 100% /snap/gnome-characters/206/dev/nvme0n1p4  10254612    36888   9677104   1% /home/jason/Devicetmpfs            1616672       12   1616660   1% /run/user/121tmpfs            1616672       32   1616640   1% /run/user/1000/dev/sda1       15666400 11506912   4159488  74% /media/jason/E86B-1D06tmpfs            1616672        0   1616672   0% /run/user/0</code></pre><h4 id="特殊设备loop挂载"><a href="#特殊设备loop挂载" class="headerlink" title="特殊设备loop挂载"></a>特殊设备loop挂载</h4><p>如果有光盘镜像文件，过着使用文件作为磁盘的方式时，就要用特别的方法挂在起来，不需要刻录。</p><ul><li>挂载CD/DVD镜像文件</li></ul><p>挂载镜像文件</p><pre class=" language-bash"><code class="language-bash">$ ll -h CentOS-7-x86_64-DVD-1810.iso-rw-rw-r-- 1 jason jason 4.3G 12月  5 23:22 CentOS-7-x86_64-DVD-1810.iso$ <span class="token function">mkdir</span> ./centos_dvd$ <span class="token function">mount</span> -o loop ./CentOS-7-x86_64-DVD-1810.iso ./centos_dvdmount: /home/jason/Downloads/google/centos_dvd: WARNING: device write-protected, mounted read-only.$ <span class="token function">df</span> ./centos_dvdFilesystem     1K-blocks    Used Available Use% Mounted on/dev/loop29      4480476 4480476         0 100% /home/jason/Downloads/google/centos_dvd$ ll ./centos_dvdtotal 693drwxrwxr-x 8 root  root    2048 11月 26 07:53 ./drwxrwxr-x 9 jason jason   4096 4月  18 09:57 <span class="token punctuation">..</span>/-rw-rw-r-- 1 root  root      14 11月 26 00:01 CentOS_BuildTag-rw-r--r-- 1 root  root      29 11月 26 00:16 .discinfodrwxr-xr-x 3 root  root    2048 11月 26 00:20 EFI/-rw-rw-r-- 1 root  root     227 8月  30  2017 EULA-rw-rw-r-- 1 root  root   18009 12月 10  2015 GPLdrwxr-xr-x 3 root  root    2048 11月 26 00:21 images/drwxr-xr-x 2 root  root    2048 11月 26 00:20 isolinux/drwxr-xr-x 2 root  root    2048 11月 26 00:20 LiveOS/drwxrwxr-x 2 root  root  663552 11月 26 07:52 Packages/drwxrwxr-x 2 root  root    4096 11月 26 07:53 repodata/-rw-rw-r-- 1 root  root    1690 12月 10  2015 RPM-GPG-KEY-CentOS-7-rw-rw-r-- 1 root  root    1690 12月 10  2015 RPM-GPG-KEY-CentOS-Testing-7-r--r--r-- 1 root  root    2883 11月 26 07:54 TRANS.TBL-rw-r--r-- 1 root  root     354 11月 26 00:21 .treeinfo$ unmount ./centos_dvd <span class="token comment" spellcheck="true">#测试完成记得卸载</span></code></pre><p>MD5验证码可以确保设备内部文件的验证。</p><ul><li>建立大文件以制作loop设备文件</li></ul><p>比如分配系统的时候，犯懒只设置了一个根目录，这样就无法机型额外的分区了，我们可以话分出一个打文件，然后将这个文件loop挂载，这样感觉上就多了一个分区。</p><p>Linux下我们可以通过dd命令来建立一个空文件</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>/srv/loopdev bs<span class="token operator">=</span>1M count<span class="token operator">=</span>512512+0 records <span class="token keyword">in</span>512+0 records out536870912 bytes <span class="token punctuation">(</span>537 MB, 512 MiB<span class="token punctuation">)</span> copied, 0.479746 s, 1.1 GB/s<span class="token comment" spellcheck="true"># 命令解释</span><span class="token comment" spellcheck="true"># if input file 输入文件，/dev/zero是一直输出0的设备文件</span><span class="token comment" spellcheck="true"># of output file 输出文件</span><span class="token comment" spellcheck="true"># bs 每个block的大小</span><span class="token comment" spellcheck="true"># count 总共几个bs</span>$ ll -h /srv/loopdev-rw-r--r-- 1 root root 512M 4月  18 10:28 /srv/loopdev$ mkfs.ext4  /srv/loopdev <span class="token comment" spellcheck="true">#对文件进行格式化</span>mke2fs 1.44.1 <span class="token punctuation">(</span>24-Mar-2018<span class="token punctuation">)</span>Discarding device blocks: <span class="token keyword">done</span>Creating filesystem with 131072 4k blocks and 32768 inodesFilesystem UUID: 908d7f09-4ab2-4704-a509-d4721e3e4dccSuperblock backups stored on blocks:    32768, 98304Allocating group tables: <span class="token keyword">done</span>Writing inode tables: <span class="token keyword">done</span>Creating journal <span class="token punctuation">(</span>4096 blocks<span class="token punctuation">)</span>: <span class="token keyword">done</span>Writing superblocks and filesystem accounting information: <span class="token keyword">done</span>$ blkid /srv/loopdev/srv/loopdev: UUID<span class="token operator">=</span><span class="token string">"908d7f09-4ab2-4704-a509-d4721e3e4dcc"</span> TYPE<span class="token operator">=</span><span class="token string">"ext4"</span><span class="token comment" spellcheck="true"># 挂载</span>$ <span class="token function">mount</span> -o loop UUID<span class="token operator">=</span><span class="token string">"908d7f09-4ab2-4704-a509-d4721e3e4dcc"</span> /mnt$ <span class="token function">df</span> /mntFilesystem     1K-blocks  Used Available Use% Mounted on/dev/loop29       499656   780    462180   1% /mnt</code></pre><p>通过这个方法可以在不改变原来的环境的情况下，进行分区操作，其实Linux下的虚拟机软件也是基于这个原理来进行的。</p><p>下面将这个文件永久的挂载起来</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">nano</span> /etc/fstab/srv/loopdev /media/jason/file ext4 defaults 0 1$ <span class="token function">umount</span> /mnt$ <span class="token function">mkdir</span> /media/jason/file$ <span class="token function">mount</span> -a$ <span class="token function">df</span> /media/jason/fileFilesystem     1K-blocks  Used Available Use% Mounted on/dev/loop29       499656   780    462180   1% /media/jason/file</code></pre><h3 id="内存交换分区swap之创建"><a href="#内存交换分区swap之创建" class="headerlink" title="内存交换分区swap之创建"></a>内存交换分区swap之创建</h3><p><code>/swap</code>是在物理内存不够时，用来临时存放内粗你数据的地方，现在个人pc的内存基本上都是足够的，但是到了服务器的场景下就不一定了，所以还是预留好<code>/swap</code>分区以备不时之需。</p><ul><li>设置一个内存交换分区</li><li>建立一个虚拟内存文件<h4 id="使用物理分区创建内存交换分区"><a href="#使用物理分区创建内存交换分区" class="headerlink" title="使用物理分区创建内存交换分区"></a>使用物理分区创建内存交换分区</h4></li><li>1.分区：使用gdisk在磁盘中划分一个分区作为内存交换分区</li><li>2.格式化：利用建立内存交换分区的格式的mkswap格式化为内存交换分区格式</li><li>3.使用：swapon</li><li>4.观察：free和swapon -s观察内存使用量</li></ul><pre class=" language-bash"><code class="language-bash">$ gdisk /dev/nvme0n1GPT <span class="token function">fdisk</span> <span class="token punctuation">(</span>gdisk<span class="token punctuation">)</span> version 1.0.3Partition table scan:  MBR: not present  BSD: not present  APM: not present  GPT: not presentCreating new GPT entries.Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> help<span class="token punctuation">)</span>: nPartition number <span class="token punctuation">(</span>1-128, default 1<span class="token punctuation">)</span>:First sector <span class="token punctuation">(</span>34-20969438, default <span class="token operator">=</span> 2048<span class="token punctuation">)</span> or <span class="token punctuation">{</span>+-<span class="token punctuation">}</span>size<span class="token punctuation">{</span>KMGTP<span class="token punctuation">}</span>:Last sector <span class="token punctuation">(</span>2048-20969438, default <span class="token operator">=</span> 20969438<span class="token punctuation">)</span> or <span class="token punctuation">{</span>+-<span class="token punctuation">}</span>size<span class="token punctuation">{</span>KMGTP<span class="token punctuation">}</span>: +512MCurrent <span class="token function">type</span> is <span class="token string">'Linux filesystem'</span>Hex code or GUID <span class="token punctuation">(</span>L to show codes, Enter <span class="token operator">=</span> 8300<span class="token punctuation">)</span>: 8200Changed <span class="token function">type</span> of partition to <span class="token string">'Linux swap'</span>Command <span class="token punctuation">(</span>? <span class="token keyword">for</span> help<span class="token punctuation">)</span>: pDisk /dev/nvme0n1p4: 20969472 sectors, 10.0 GiBSector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512/512 bytesDisk identifier <span class="token punctuation">(</span>GUID<span class="token punctuation">)</span>: 2A01F71D-7DD6-446D-B3E6-65A6FDF8C79BPartition table holds up to 128 entriesMain partition table begins at sector 2 and ends at sector 33First usable sector is 34, last usable sector is 20969438Partitions will be aligned on 2048-sector boundariesTotal <span class="token function">free</span> space is 19920829 sectors <span class="token punctuation">(</span>9.5 GiB<span class="token punctuation">)</span>Number  Start <span class="token punctuation">(</span>sector<span class="token punctuation">)</span>    End <span class="token punctuation">(</span>sector<span class="token punctuation">)</span>  Size       Code  Name   1            2048         1050623   512.0 MiB   8200  Linux swapCommand <span class="token punctuation">(</span>? <span class="token keyword">for</span> help<span class="token punctuation">)</span>: wFinal checks complete. About to <span class="token function">write</span> GPT data. THIS WILL OVERWRITE EXISTINGPARTITIONS<span class="token operator">!</span><span class="token operator">!</span>Do you want to proceed? <span class="token punctuation">(</span>Y/N<span class="token punctuation">)</span>: yOK<span class="token punctuation">;</span> writing new GUID partition table <span class="token punctuation">(</span>GPT<span class="token punctuation">)</span> to /dev/nvme0n1p4.Warning: The kernel is still using the old partition table.The new table will be used at the next <span class="token function">reboot</span> or after yourun partprobe<span class="token punctuation">(</span>8<span class="token punctuation">)</span> or kpartx<span class="token punctuation">(</span>8<span class="token punctuation">)</span>The operation has completed successfully.$ mkswap /dev/nvme0n1p6$ blkid /dev/nvme0n1p6$ <span class="token function">free</span>              total        used        <span class="token function">free</span>      shared  buff/cache   availableMem:       16166752     1845564    11269080      848860     3052108    13156136 <span class="token comment" spellcheck="true">#物理内存</span>Swap:       2097148           0     2097148                                     <span class="token comment" spellcheck="true">#swap相关</span>$ swapon /dev/nvme0n1p6$ <span class="token function">free</span>total        used        <span class="token function">free</span>      shared  buff/cache   availableMem:       16166752     1845564    11269080      848860     3052108    13156136 <span class="token comment" spellcheck="true">#物理内存</span>Swap:       2597148           0     2597148                                     <span class="token comment" spellcheck="true">#swap相关</span>$ swapon -s$ <span class="token function">nano</span> /etc/fstabUUID<span class="token operator">=</span><span class="token string">"38cdd582-dff7-4be3-8e55-0cb51fea7c4a"</span> swap swap defaults 0 1</code></pre><h4 id="使用文件创建文件交换分区"><a href="#使用文件创建文件交换分区" class="headerlink" title="使用文件创建文件交换分区"></a>使用文件创建文件交换分区</h4><pre class=" language-bash"><code class="language-bash">$ <span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>/tmp/swap bs<span class="token operator">=</span>1M count<span class="token operator">=</span>128128+0 records <span class="token keyword">in</span>128+0 records out134217728 bytes <span class="token punctuation">(</span>134 MB, 128 MiB<span class="token punctuation">)</span> copied, 0.183657 s, 731 MB/s$ ll -h /tmp/swap-rw-r--r-- 1 root root 128M 4月  18 11:21 /tmp/swap$ mkswap /tmp/swapmkswap: /tmp/swap: insecure permissions 0644, 0600 suggested.Setting up swapspace version 1, size <span class="token operator">=</span> 128 MiB <span class="token punctuation">(</span>134213632 bytes<span class="token punctuation">)</span>no label, UUID<span class="token operator">=</span>8237d888-982a-46d2-b753-bc38b2d6d588$ swapon /tmp/swapswapon: /tmp/swap: insecure permissions 0644, 0600 suggested.$ swapon -sFilename                Type        Size    Used    Priority/swapfile                                  <span class="token function">file</span>        2097148    0    -2/tmp/swap                                  <span class="token function">file</span>        131068    0    -3$ <span class="token function">nano</span> /etc/fstab/tmp/swap                                   swap                 swap   defaults            0       1<span class="token comment" spellcheck="true"># 这里不使用UIUD，因为系统仅会查询区块设备文件，不会查询文件</span>$ swapoff /tmp/swap$ swapon -sFilename                Type        Size    Used    Priority/swapfile                                  <span class="token function">file</span>        2097148    0    -2$ swapon -a$ swapon -s</code></pre><h3 id="文件系统的特殊观察与操作"><a href="#文件系统的特殊观察与操作" class="headerlink" title="文件系统的特殊观察与操作"></a>文件系统的特殊观察与操作</h3><h4 id="磁盘空间之浪费问题"><a href="#磁盘空间之浪费问题" class="headerlink" title="磁盘空间之浪费问题"></a>磁盘空间之浪费问题</h4><p>其实整个文件系统中的超级区块，inode对照表等其他中介数据都会浪费容量，</p><pre class=" language-bash"><code class="language-bash">$ ll -shtotal 204K4.0K drwx------ 26 root  root  4.0K 4月  15 16:52 ./4.0K drwxr-xr-x 27 root  root  4.0K 4月  15 09:53 <span class="token punctuation">..</span>/4.0K drwxr-xr-x  3 root  root  4.0K 8月  26  2018 .android/4.0K drwxr-xr-x  3 root  root  4.0K 8月  26  2018 Android/4.0K drwxr-xr-x  4 root  root  4.0K 8月  26  2018 .AndroidStudio3.1/4.0K drwxr-xr-x  3 root  root  4.0K 8月  26  2018 AndroidStudioProjects/4.0K -rw-r--r--  1 root  root   113 9月   6  2018 .apport-ignore.xml <span class="token operator">&lt;</span>--这个文件只有113b，去占用了一个4k的区块 40K -rw-------  1 root  root   34K 4月  18 10:23 .bash_history4.0K -rwxrwxrwx  1 root  root  3.3K 3月  29 14:17 .bashrc*4.0K drwx------  8 root  root  4.0K 4月  15 16:52 .cache/4.0K drwx------ 10 root  root  4.0K 4月  15 16:52 .config/4.0K drwx------  3 root  root  4.0K 8月  26  2018 .dbus/4.0K drwx------  2 root  root  4.0K 4月   8 08:29 .gconf/4.0K -rw-r--r--  1 root  root    55 11月 29 20:56 .gitconfig<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre><h4 id="利用GNU的parted进行分区操作"><a href="#利用GNU的parted进行分区操作" class="headerlink" title="利用GNU的parted进行分区操作"></a>利用GNU的parted进行分区操作</h4><pre class=" language-bash"><code class="language-bash">$ parted <span class="token punctuation">[</span>设备<span class="token punctuation">]</span> <span class="token punctuation">[</span>命令<span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">]</span>选项与参数：命令功能：      新增分区： mkpart <span class="token punctuation">[</span>primary<span class="token operator">|</span>logical<span class="token operator">|</span>Extended<span class="token punctuation">]</span> <span class="token punctuation">[</span>ext4<span class="token operator">|</span>vfat<span class="token operator">|</span>xfs<span class="token punctuation">]</span> 开始 结束      显示分区： print      删除分区： <span class="token function">rm</span> <span class="token punctuation">[</span>partition<span class="token punctuation">]</span>$ parted /dev/nvme0n1 print <span class="token comment" spellcheck="true">#列出本机分区表</span>Model: INTEL SSDPEKKF256G8L <span class="token punctuation">(</span>nvme<span class="token punctuation">)</span>Disk /dev/nvme0n1: 256GBSector size <span class="token punctuation">(</span>logical/physical<span class="token punctuation">)</span>: 512B/512BPartition Table: gptDisk Flags:Number  Start   End    Size    File system  Name                          Flags 1      1049kB  274MB  273MB   fat32        EFI system partition          boot, hidden, esp 2      274MB   290MB  16.8MB               Microsoft reserved partition  msftres 3      290MB   142GB  142GB   ntfs         Basic data partition          msftdata 4      142GB   153GB  10.7GB  ext4         Basic data partition          msftdata 5      153GB   255GB  102GB   ext4 6      255GB   256GB  1049MB  ntfs         Basic data partition          hidden, diag$ parted /dev/nvme0n1p5 mklabel mbr <span class="token comment" spellcheck="true">#改变分区表格式，这样会损坏整个文件系统</span>$ parted /dev/nvme0n1p5 mkpart primary fat32 36.0G 36.5G <span class="token comment" spellcheck="true">#建立新的分区</span></code></pre><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li>压缩指令为透过一些运算方法去将原本的文件进行压缩,以减少文件所占用的磁盘容量。 压缩前与压缩后<br>的文件所占用的磁盘容量比值, 就可以被称为是『压缩比』</li><li>压缩的好处是可以减少磁盘容量的浪费,在 WWW 网站也可以利用文件压缩的技术来进行数据的传送,好<br>让网站带宽的可利用率上升喔</li><li>压缩文件案的扩展名大多是:『*.gz, *.bz2, *.xz, *.tar, *.tar.gz, *.tar.bz2, *.tar.xz』</li><li>常见的压缩指令有 gzip, bzip2, xz。压缩率最佳的是 xz,若可以不计时间成本,建议使用 xz 进行压缩。</li><li>tar 可以用来进行文件打包,并可支持 gzip, bzip2, xz 的压缩。</li><li>压缩:tar -Jcv -f filename.tar.xz 要被压缩的文件或目录名称</li><li>查询:tar -Jtv -f filename.tar.xz</li><li>解压缩:tar -Jxv -f filename.tar.xz -C 欲解压缩的目录</li><li>xfsdump 指令可备份文件系统或单一目录</li><li>xfsdump 的备份若针对文件系统时,可进行 0-9 的 level 差异备份!其中 level 0 为完整备份;</li><li>xfsrestore 指令可还原被 xfsdump 建置的备份档;</li><li>要建立光盘刻录数据时,可透过 mkisofs 指令来建置;<br>= 可透过 wodim 来写入 CD 或 DVD 刻录机</li><li>dd 可备份完整的 partition 或 disk ,因为 dd 可读取磁盘的 sector 表面数据</li><li>cpio 为相当优秀的备份指令,不过必须要搭配类似 find 指令来读入欲备份的文件名数据,方可进行备份动作。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;认识Linux文件系统&quot;&gt;&lt;a href=&quot;#认识Linux文件系统&quot; class=&quot;headerlink&quot; title=&quot;认识Linux文件系统&quot;&gt;&lt;/a&gt;认识Linux文件系统&lt;/h3&gt;&lt;p&gt;Linux 文件系统最“正统”的是 &lt;strong&gt;&lt;em&gt;ext2
      
    
    </summary>
    
      <category term="底层" scheme="http://jinzhengxu.github.io/categories/%E5%BA%95%E5%B1%82/"/>
    
    
      <category term="Linux" scheme="http://jinzhengxu.github.io/tags/Linux/"/>
    
      <category term="文件系统" scheme="http://jinzhengxu.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
