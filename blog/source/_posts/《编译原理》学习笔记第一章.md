---
title: 《编译原理》学习笔记第一章
date: 2019-02-27 19:27:18
tags:
- 编译原理
categoties: 拉普拉斯妖
copyright: jinzhengxu
---
## 引论
### 1.1语言处理器
编译器：将源程序转化为目标程序

解释器(interpreter)：直接利用用户提供的输入执行源程序中指定的操作。

e.g. Java语言处理器结合了`编译`和`解释`的过程:
```
1.首先被编译为一个称为字节码的中间表示形式
2.有jvm对得到的虚拟机加以解释执行
```
1.1.2 编译器生成的目标文件可以被直接执行，而解释器生成的目标文件不能被直接执行。

1.1.3编译器产生的汇编语言相较机器语言更加容易理解，方便程序员优化程序性能并调试。

1.1.4c语言贴近底层逻辑简单清晰，没有面向对象等复杂机制，语法词义较易理解。

1.1.5根据运行程序的机器的架构（arm，x86）等特征生成适合于该机器的机器码

一个混合编译器:
```
源程序->翻译器->中间程序->
                          |->虚拟机->输出
                    输入->
 ```
 一个语言处理器:
 ```
 源程序->预处理器->经过预处理的源程序
 ->编译器->目标汇编程序
 ->汇编器->可可重定位机器代码
 ->连接器/加载器 <-库文件可重定位对象文件
 ->目标机器代码
 ```
 ### 1.2 一个编译器的结构
 一个编译器的各个步骤:
 ```
 字符流
 ->词法分析器->符号流
 ->语法分析->语法树
 ->语义分析->语法树
 ->中间代码生成器->中间表示形式
 ->机器无关代码优化器->中间表示形式
 ->代码生成器->目标机器语言
 ->机器相关代码优化器->目标机器语言
 ```
 #### 1.2.1词法分析
 编译器的结构：
 ```
分析部分,前段(frootend):
字符流
->词法分析器->词法单元流
->语法分析器->语法树
->语义分析器->语法树
->中间代码生成器->中间表示形式

综合部分,后端部分(backend与硬件有关):
->机器无关代码优化器->中间表示方式
->目标代码生成器->目标机器语言
->机器代码优化器->目标机器语言

辅助工具:表格管理,出错处理.
```
 词法分析将字符流组织为有意义的词素(lexeme),对于每个词素语法分析器产生词法单元`tocken <tocken-name,attribute-value>`,其中`tocken-name`是由语法分析步骤使用的抽象符号.而第二个分量`attribute-value`指向符号表中关于这个词法单元的条目。(符号表：分析阶段会将从源程序收集的信息存放在符号表（symbo table）的数据结构中，符号表将和中间表示形式一起传递给综合部分)。
 e.g.
 ```
 position =  initial  +    rate      *    60
 <id,1><=><id,2><+><id,3><*><60>
 (从技术上讲,应该为<60>创建一个形如<number,4>的词法单元)
 ```
 #### 1.2.2语法分析
 语法树:每个内部节点表示一个运算，而该节点的叶子节点表示该运算的分量。
 #### 1.2.3语义分析
 使用语法树和符号表中的信息检查源程序是否和语言定义的语义一致，它同时也收集类型信息，并把这些信息存放在语法树或符号表中。

 类型检查：检查每个运算符是否具有匹配的运算分量（如数组下标），有些程序语言允许自动类型转换，这是编译器应该自动将分量的类型转换。在前面的示例中，语法分析器会为60
创造一个关于运算符inttofloat的额外节点。
#### 1.2.4中间代码生成
中间表示形式可以有一个或多个，语法树是其中一种。
性质
```
1.易于生成
2.能够被轻松的翻译为目标机器上的语言
```
##### 三地址代码
一种中间表示形式，每个指令具有三个运算分量，每个运算分量都像一个寄存器。
```
1.每个三地址赋值指令的右部最多只有一个运算符。因此这些指令确定了运算的完成顺序。
2.编译器应该生成一个临时名字以存放一个三地址指令得到的值
3.有些三地址指令的运算分量小于3个
```
#### 1.2.5代码优化
能耗更低，运行更快，优化是编译时的可选项
#### 1.2.6代码生成
将中间表示形式映射为目标语言，如果目标语言是机器代码则需要为每个变量选择寄存器位置或内存位置。
#### 1.2.7符号表管理
即表格管理
#### 1.2.8将多个步骤组合成趟（pass）
一趟就是读入一个文件并产生一个输出文件的过程。
e.g.
```
前段步骤中的词法分析,语法分析,语义分析,中间代码生成可以组合为一趟
代码优化作为一个可选的趟
生成特定目标代码的后端趟
```
不同的前端和某个目标机的后端结合起来为不同的源语言建立该目标机上的编译器。

一个前端和不同的目标机后端结合建立针对不同目标机的编译器。
#### 编译器构造工具
```
1）语法分析器的生成器
2）扫描器的生成器
3）语法制导的翻译引擎
4）代码生成器的生成器
5）数据流分析引擎
6）编译器构造工具集
```
### 程序设计语言的历史
20世纪40年代第一台电子计算机
#### 1.3.1走向高级程序设计语言
汇编语言->Fortran,Cobol,Lisp->new language
```
第一代语言:机器语言
第二代语言:汇编语言
第三代语言:Fortran,Cobol,C,C++,C#,Java等高级程序设计语言
第四代语言:为特定应用设计,生成表格的NOMAD,SQL,Markdown
第五代语言:基于逻辑和约束的语言,如Prolog和OPS5
```
```
强制式语言:c,java
声明式语言:函数式语言:ML,Haskell;
           约束逻辑式语言:Prolog
```
冯诺依曼语言:以冯诺依曼计算机体系结构为计算模型

面向对象语言:C++,Ruby

脚本语言:具有高层次预算福的解释型语言,用于将多个计算过程粘和在一起,PHP,Awk,Ruby。

#### 对编译器的影响
程序语言的设计和编译器是密切相关的。
1.3.3
```
强制式的 C，C++，VB
声明式的 ML，Haskell
冯诺依曼式的Fortran，C，VB
面向对象的C++
函数式的ML，Haskell
第三代 C，C++，Fortran，VB，Lisp
第四代
脚本语言 Perl，Python
```
### 构建一个编译器的相关科学
#### 1.4.1编译器设计和现实中的建模
`有穷状态自动机`和`正则表达式`可以用来描述最基本的词法单位以及识别这些单位的算法。
`上下文无关法`用来描述语法结构。
#### 1.4.2代码优化的科学
编译器优化必须满足下面的设计目标
```
优化必须是正确的，不能改变被编译程序的含义
优化必须能够改善很多程序的性能
优化所需的时间必须保持在合理的范围内
所需要的工程方面的工作必须是可管理的
```
虽然代码不能真正达到最优化，但提高代码效率的科学非常重要，是编译器技术研究的重要部分。
### 编译技术的应用
#### 1.5.1高级程序设计语言的实现
语言的易用性和编译过程的复杂性是负相关的，越是低级的语言，编译过程中花掉的时间越少。

随着时间的流失，程序语言负担起了越来越多本来程序员的工作，图内存管理，类型一致性检查和代码的并发执行。
#### 1.5.2针对计算机体系结构的优化
并行和内存层次结构
###### 并行性
编译器可以改变指令的顺序获得更高的性能
###### 内存层次结构
改变数据的布局或数据访问代码的顺序来提高内存层次结构的效率。
#### 新计算机体系结构的设计
###### RISC
精简指令集
###### 专用体系结构
数据流机器，向量机，VLIW机器，SIMD处理器阵列
#### 程序翻译
编译器不仅可以用于将高级语言程序翻译为机器语言，还可以将一种语言翻译为另一种语言。
###### 二进制翻译器
###### 硬件合成
###### 数据查询解释器
###### 编译然后模拟
#### 软件成产率工具
静态分析技术可以帮助找出程序中的错误，但是错误探测器不可能找出所有错误，也不能保证找出的错误都是真正的错误。
###### 类型检查
###### 边界检查
###### 内存管理工具
### 程序设计语言基础
#### 1.6.1 动态和静态的区别
```
静态策略：语言使用的策略支持编译器静态的决定某个问题（编译时刻compile time决定）
动态策略：只允许在运行程序时候做出决定（运行时runtime做出决定）
```
##### 1.6.2 环境与状态
```
名字---环境--->内存变量(位置)---状态--->值
```
1)从名字到位置的静态绑定和动态绑定.大部分都是动态的,但如全局变量这种操作就可以为编译器生成目标代码时一劳永逸的分配一个储存位置。

2)从位置到值的静态绑定和动态绑定.一般来说也是动态的,但比如宏`#define ARRAYSIZE 1000`就静态的绑定为1000。
#### 1.6.3 静态作用域和块结构
C中括号{}可以界定一个块。


C语言中静态作用域策略可以概述如下：
```
1）一个C程序由一个顶层的变量和函数声明的序列组成
2）函数内部可以声明变量，变量包括局部变量解参数，每个这样的声明的作用域被限制在它们所出现的那个函数内。
3）名字x的一个顶层声明的作用域包括其后的所有程序，但是如果一个函数中也有一个x是声明，那么函数中的语句就不在这个顶层函数内。
```
子C语言中有关块的语法如下：
```
1）块是一种语句。
2）一个块包含了一个声明的序列然后再跟着另一个语句序列
```
#### 1.6.4显示访问控制
声明告诉我们事物的类型,而定义告诉我们事物的值.
#### 1.6.5动态作用域
对一个名字x的使用指向的是最近被调用但还没有终止且声明了x的过程中的声明。例如：C预处理器中的宏扩展，面向对象编程中的方法解析。
#### 1.6.6参数传递机制
参数可以通过值或引用的方式从调用过程传递给被调用过程。当通过值传递方式传递大型对象时，实际被传递的值是指向这些对象本身的引用，这样就变成了一个高效的引用调用。
#### 1.6.7别名
当参数被以引用传递的方式高效的传递时，两个形式参数可能会指向同一个对象。这会造成一个变量的修改改变了另一个变量的值。
