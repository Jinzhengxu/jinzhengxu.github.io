---
title: 《现代编译原理-C语言描述》（4）- 抽象语法
date: 2019-04-09 10:46:51
tags:
- 虎书
- 编译原理
categoties: 拉普拉斯妖
copyright:
---
### 第四章 抽象语法
> 抽象的(ab-stract):从所有具体实例中提取出来的。
> ----韦氏词典

#### 语义动作
语法分析器中的语义动作（semantic action），可以作用于正在分析的短语。
+ 对于递归下降分析器来说，语义动作是分散在实现语法分析的控制流中
+ 对于遵循Yacc说明的语法分析器，语义动作是附带在文法产生式之后的c程序代码

##### 递归下降
对于递归下降语法分析器，语义动作是语法分析函数的返回值，或是语法分析函数的副作用，抑或是兼而有之。

每个非终结符和终结符（type）都关联一种语义值，语义值代表了由这个符号导出的短语。

对于消除左递归的情况，我们通过将左操作数作为参数传递给下一个语法分析函数的犯法来解决。

也就是说我们为了消除左递归，必须要引入新的符号，但是新引入的符号的产生式不一定符合运算符的操作规范，于是我们必须要将上一层分析中的左操作数传递到下一层并返回。
##### Yacc生成的分析器
对于遵循Yacc说明的语法分析器,语法动作是附加在产生式之后的一段c代码。当Yacc利用，某一条规则进行归约时，就会执行其后的语义动作。例如文法3-13Yacc语法分析器：
```c
%{ declarations of yylex and yyerror %}
%union {int num; string id;}
%token <num> INT
%token <id> ID
%type <num> exp
%start exp
%left PLUS MINUS
%left TIMES
%left UMINUS
%%
exp : INT             {$$ = $1;}
    | exp PLUS exp    {$$ = $1 + $3;}
    | exp MINUS exp   {$$ = $1 - $3;}
    | exp TIMES exp   {$$ = $1 * $3;}
    | MINUS exp   %prec UMINUS {$$ = - $2;}
```
Yacc中语义动作的使用是用`$i`来引用第i个右部符号的语义值，它为左部非终结符产生的值可以赋给`$$`。`%union`说明了各种可能携带的语义值类型，每个非终结符通过`<variant>`，注释指明该非终结符应该使用哪一个`%union`声明中的形式。

遵循Yacc说明的语法分析器会维护一个 ***状态栈*** 和一个 ***语义值栈*** 来实现对语义值的操作，在原来简单分析栈的基础上增添了一个与分析栈符号一一对应的语义值栈。在语法分析器执行一个归约动作时，它会从一个简单栈中弹出k个字符，并将归约得到的非终结符压栈，对于语义值栈的操作也是如此，从语义值栈弹出k个语义值，并将执行语义动作c代码返回的语义值重新压栈。

如下图：

终结符携带的语义值是无意义的占位符。
##### 语义动作的解释器
上面的程序设计语言的例子中，并没有语义动作能够影响全局的副作用，所以右部符号的求值顺序并不能影响最终的结果。

但是我们可以知道，LR分析是自底向上，从左至右的遍历语法分析树，即后序遍历的方式来执行归约和语义动作。利用这一特性，我们可以编写出带有全局副作用的语义动作，并且可以明确了解副作用的发生顺序。

下面的例子是绪论中直线式程序设计的解释器。通过使用一个符号表的全局变量：

```c
```

#### 抽象语法分析树
##### 位置
##### Tiger的抽象语法
#### 程序设计：抽象语法
#### 推荐阅读
#### 习题
